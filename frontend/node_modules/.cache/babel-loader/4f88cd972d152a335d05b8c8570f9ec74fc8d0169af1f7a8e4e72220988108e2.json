{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport UniformBuffer from './UniformBuffer.js';\nimport { GPU_CHUNK_BYTES } from './Constants.js';\nclass UniformsGroup extends UniformBuffer {\n  constructor(name) {\n    super(name);\n    this.isUniformsGroup = true;\n\n    // the order of uniforms in this array must match the order of uniforms in the shader\n\n    this.uniforms = [];\n  }\n  addUniform(uniform) {\n    this.uniforms.push(uniform);\n    return this;\n  }\n  removeUniform(uniform) {\n    const index = this.uniforms.indexOf(uniform);\n    if (index !== -1) {\n      this.uniforms.splice(index, 1);\n    }\n    return this;\n  }\n  get buffer() {\n    let buffer = this._buffer;\n    if (buffer === null) {\n      const byteLength = this.byteLength;\n      buffer = new Float32Array(new ArrayBuffer(byteLength));\n      this._buffer = buffer;\n    }\n    return buffer;\n  }\n  get byteLength() {\n    let offset = 0; // global buffer offset in bytes\n\n    for (let i = 0, l = this.uniforms.length; i < l; i++) {\n      const uniform = this.uniforms[i];\n\n      // offset within a single chunk in bytes\n\n      const chunkOffset = offset % GPU_CHUNK_BYTES;\n      const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n      // conformance tests\n\n      if (chunkOffset !== 0 && remainingSizeInChunk - uniform.boundary < 0) {\n        // check for chunk overflow\n\n        offset += GPU_CHUNK_BYTES - chunkOffset;\n      } else if (chunkOffset % uniform.boundary !== 0) {\n        // check for correct alignment\n\n        offset += chunkOffset % uniform.boundary;\n      }\n      uniform.offset = offset / this.bytesPerElement;\n      offset += uniform.itemSize * this.bytesPerElement;\n    }\n    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;\n  }\n  update() {\n    let updated = false;\n    for (const uniform of this.uniforms) {\n      if (this.updateByType(uniform) === true) {\n        updated = true;\n      }\n    }\n    return updated;\n  }\n  updateByType(uniform) {\n    if (uniform.isFloatUniform) return this.updateNumber(uniform);\n    if (uniform.isVector2Uniform) return this.updateVector2(uniform);\n    if (uniform.isVector3Uniform) return this.updateVector3(uniform);\n    if (uniform.isVector4Uniform) return this.updateVector4(uniform);\n    if (uniform.isColorUniform) return this.updateColor(uniform);\n    if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);\n    if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);\n    console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);\n  }\n  updateNumber(uniform) {\n    let updated = false;\n    const a = this.buffer;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset] !== v) {\n      a[offset] = v;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector2(uniform) {\n    let updated = false;\n    const a = this.buffer;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {\n      a[offset + 0] = v.x;\n      a[offset + 1] = v.y;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector3(uniform) {\n    let updated = false;\n    const a = this.buffer;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {\n      a[offset + 0] = v.x;\n      a[offset + 1] = v.y;\n      a[offset + 2] = v.z;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector4(uniform) {\n    let updated = false;\n    const a = this.buffer;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {\n      a[offset + 0] = v.x;\n      a[offset + 1] = v.y;\n      a[offset + 2] = v.z;\n      a[offset + 3] = v.w;\n      updated = true;\n    }\n    return updated;\n  }\n  updateColor(uniform) {\n    let updated = false;\n    const a = this.buffer;\n    const c = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {\n      a[offset + 0] = c.r;\n      a[offset + 1] = c.g;\n      a[offset + 2] = c.b;\n      updated = true;\n    }\n    return updated;\n  }\n  updateMatrix3(uniform) {\n    let updated = false;\n    const a = this.buffer;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {\n      a[offset + 0] = e[0];\n      a[offset + 1] = e[1];\n      a[offset + 2] = e[2];\n      a[offset + 4] = e[3];\n      a[offset + 5] = e[4];\n      a[offset + 6] = e[5];\n      a[offset + 8] = e[6];\n      a[offset + 9] = e[7];\n      a[offset + 10] = e[8];\n      updated = true;\n    }\n    return updated;\n  }\n  updateMatrix4(uniform) {\n    let updated = false;\n    const a = this.buffer;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (arraysEqual(a, e, offset) === false) {\n      a.set(e, offset);\n      updated = true;\n    }\n    return updated;\n  }\n}\nfunction arraysEqual(a, b, offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    if (a[offset + i] !== b[i]) return false;\n  }\n  return true;\n}\nexport default UniformsGroup;","map":{"version":3,"names":["UniformBuffer","GPU_CHUNK_BYTES","UniformsGroup","constructor","name","isUniformsGroup","uniforms","addUniform","uniform","push","removeUniform","index","indexOf","splice","buffer","_buffer","byteLength","Float32Array","ArrayBuffer","offset","i","l","length","chunkOffset","remainingSizeInChunk","boundary","bytesPerElement","itemSize","Math","ceil","update","updated","updateByType","isFloatUniform","updateNumber","isVector2Uniform","updateVector2","isVector3Uniform","updateVector3","isVector4Uniform","updateVector4","isColorUniform","updateColor","isMatrix3Uniform","updateMatrix3","isMatrix4Uniform","updateMatrix4","console","error","a","v","getValue","x","y","z","w","c","r","g","b","e","elements","arraysEqual","set"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/common/UniformsGroup.js"],"sourcesContent":["import UniformBuffer from './UniformBuffer.js';\nimport { GPU_CHUNK_BYTES } from './Constants.js';\n\nclass UniformsGroup extends UniformBuffer {\n\n\tconstructor( name ) {\n\n\t\tsuper( name );\n\n\t\tthis.isUniformsGroup = true;\n\n\t\t// the order of uniforms in this array must match the order of uniforms in the shader\n\n\t\tthis.uniforms = [];\n\n\t}\n\n\taddUniform( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremoveUniform( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.uniforms.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tget buffer() {\n\n\t\tlet buffer = this._buffer;\n\n\t\tif ( buffer === null ) {\n\n\t\t\tconst byteLength = this.byteLength;\n\n\t\t\tbuffer = new Float32Array( new ArrayBuffer( byteLength ) );\n\n\t\t\tthis._buffer = buffer;\n\n\t\t}\n\n\t\treturn buffer;\n\n\t}\n\n\tget byteLength() {\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = this.uniforms[ i ];\n\n\t\t\t// offset within a single chunk in bytes\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES;\n\t\t\tconst remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n\t\t\t// conformance tests\n\n\t\t\tif ( chunkOffset !== 0 && ( remainingSizeInChunk - uniform.boundary ) < 0 ) {\n\n\t\t\t\t// check for chunk overflow\n\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkOffset );\n\n\t\t\t} else if ( chunkOffset % uniform.boundary !== 0 ) {\n\n\t\t\t\t// check for correct alignment\n\n\t\t\t\toffset += ( chunkOffset % uniform.boundary );\n\n\t\t\t}\n\n\t\t\tuniform.offset = ( offset / this.bytesPerElement );\n\n\t\t\toffset += ( uniform.itemSize * this.bytesPerElement );\n\n\t\t}\n\n\t\treturn Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;\n\n\t}\n\n\tupdate() {\n\n\t\tlet updated = false;\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tif ( this.updateByType( uniform ) === true ) {\n\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateByType( uniform ) {\n\n\t\tif ( uniform.isFloatUniform ) return this.updateNumber( uniform );\n\t\tif ( uniform.isVector2Uniform ) return this.updateVector2( uniform );\n\t\tif ( uniform.isVector3Uniform ) return this.updateVector3( uniform );\n\t\tif ( uniform.isVector4Uniform ) return this.updateVector4( uniform );\n\t\tif ( uniform.isColorUniform ) return this.updateColor( uniform );\n\t\tif ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );\n\t\tif ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );\n\n\t\tconsole.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );\n\n\t}\n\n\tupdateNumber( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.buffer;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset ] !== v ) {\n\n\t\t\ta[ offset ] = v;\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector2( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.buffer;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {\n\n\t\t\ta[ offset + 0 ] = v.x;\n\t\t\ta[ offset + 1 ] = v.y;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.buffer;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {\n\n\t\t\ta[ offset + 0 ] = v.x;\n\t\t\ta[ offset + 1 ] = v.y;\n\t\t\ta[ offset + 2 ] = v.z;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.buffer;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {\n\n\t\t\ta[ offset + 0 ] = v.x;\n\t\t\ta[ offset + 1 ] = v.y;\n\t\t\ta[ offset + 2 ] = v.z;\n\t\t\ta[ offset + 3 ] = v.w;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateColor( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.buffer;\n\t\tconst c = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {\n\n\t\t\ta[ offset + 0 ] = c.r;\n\t\t\ta[ offset + 1 ] = c.g;\n\t\t\ta[ offset + 2 ] = c.b;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateMatrix3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.buffer;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||\n\t\t\ta[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||\n\t\t\ta[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {\n\n\t\t\ta[ offset + 0 ] = e[ 0 ];\n\t\t\ta[ offset + 1 ] = e[ 1 ];\n\t\t\ta[ offset + 2 ] = e[ 2 ];\n\t\t\ta[ offset + 4 ] = e[ 3 ];\n\t\t\ta[ offset + 5 ] = e[ 4 ];\n\t\t\ta[ offset + 6 ] = e[ 5 ];\n\t\t\ta[ offset + 8 ] = e[ 6 ];\n\t\t\ta[ offset + 9 ] = e[ 7 ];\n\t\t\ta[ offset + 10 ] = e[ 8 ];\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateMatrix4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.buffer;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( arraysEqual( a, e, offset ) === false ) {\n\n\t\t\ta.set( e, offset );\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n}\n\nfunction arraysEqual( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\tif ( a[ offset + i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nexport default UniformsGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}