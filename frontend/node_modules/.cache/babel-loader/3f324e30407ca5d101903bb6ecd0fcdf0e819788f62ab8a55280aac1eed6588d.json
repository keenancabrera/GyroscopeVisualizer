{"ast":null,"code":"import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/vec3 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\nlet depthMaterial = null;\nclass AnalyticLightNode extends LightingNode {\n  constructor(light = null) {\n    super();\n    this.updateType = NodeUpdateType.FRAME;\n    this.light = light;\n    this.rtt = null;\n    this.shadowNode = null;\n    this.color = new Color();\n    this.colorNode = uniform(this.color);\n  }\n  getHash( /*builder*/\n  ) {\n    return this.light.uuid;\n  }\n  setupShadow(builder) {\n    let shadowNode = this.shadowNode;\n    if (shadowNode === null) {\n      if (depthMaterial === null) depthMaterial = builder.createNodeMaterial('MeshBasicNodeMaterial');\n      const shadow = this.light.shadow;\n      const rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n      const depthTexture = new DepthTexture();\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n      depthTexture.image.width = shadow.mapSize.width;\n      depthTexture.image.height = shadow.mapSize.height;\n      depthTexture.compareFunction = LessCompare;\n      rtt.depthTexture = depthTexture;\n      shadow.camera.updateProjectionMatrix();\n\n      //\n\n      const bias = reference('bias', 'float', shadow);\n      const normalBias = reference('normalBias', 'float', shadow);\n      let shadowCoord = uniform(shadow.matrix).mul(positionWorld.add(normalWorld.mul(normalBias)));\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n      shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n      // WebGPU: Flip Y\n      shadowCoord.z.add(bias).mul(2).sub(1) // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n      );\n\n      const textureCompare = (depthTexture, shadowCoord, compare) => texture(depthTexture, shadowCoord).compare(compare);\n      //const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n      // BasicShadowMap\n\n      shadowNode = textureCompare(depthTexture, shadowCoord.xy, shadowCoord.z);\n\n      // PCFShadowMap\n      /*\n      const mapSize = reference( 'mapSize', 'vec2', shadow );\n      const radius = reference( 'radius', 'float', shadow );\n      \tconst texelSize = vec2( 1 ).div( mapSize );\n      const dx0 = texelSize.x.negate().mul( radius );\n      const dy0 = texelSize.y.negate().mul( radius );\n      const dx1 = texelSize.x.mul( radius );\n      const dy1 = texelSize.y.mul( radius );\n      const dx2 = dx0.mul( 2 );\n      const dy2 = dy0.mul( 2 );\n      const dx3 = dx1.mul( 2 );\n      const dy3 = dy1.mul( 2 );\n      \tshadowNode = add(\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n      ).mul( 1 / 17 );\n      */\n      //\n\n      this.rtt = rtt;\n      this.colorNode = this.colorNode.mul(frustumTest.mix(1, shadowNode));\n      this.shadowNode = shadowNode;\n\n      //\n\n      this.updateBeforeType = NodeUpdateType.RENDER;\n    }\n  }\n  setup(builder) {\n    if (this.light.castShadow) this.setupShadow(builder);\n  }\n  updateShadow(frame) {\n    const {\n      rtt,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    scene.overrideMaterial = depthMaterial;\n    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);\n    light.shadow.updateMatrices(light);\n    renderer.setRenderTarget(rtt);\n    renderer.render(scene, light.shadow.camera);\n    renderer.setRenderTarget(null);\n    scene.overrideMaterial = null;\n  }\n  updateBefore(frame) {\n    const {\n      light\n    } = this;\n    if (light.castShadow) this.updateShadow(frame);\n  }\n  update( /*frame*/\n  ) {\n    const {\n      light\n    } = this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  }\n}\nexport default AnalyticLightNode;\naddNodeClass('AnalyticLightNode', AnalyticLightNode);","map":{"version":3,"names":["LightingNode","NodeUpdateType","uniform","addNodeClass","vec3","reference","texture","positionWorld","normalWorld","Color","DepthTexture","NearestFilter","LessCompare","depthMaterial","AnalyticLightNode","constructor","light","updateType","FRAME","rtt","shadowNode","color","colorNode","getHash","uuid","setupShadow","builder","createNodeMaterial","shadow","getRenderTarget","mapSize","width","height","depthTexture","minFilter","magFilter","image","compareFunction","camera","updateProjectionMatrix","bias","normalBias","shadowCoord","matrix","mul","add","xyz","div","w","frustumTest","x","greaterThanEqual","and","lessThanEqual","y","z","oneMinus","sub","textureCompare","compare","xy","mix","updateBeforeType","RENDER","setup","castShadow","updateShadow","frame","renderer","scene","overrideMaterial","setSize","updateMatrices","setRenderTarget","render","updateBefore","update","copy","multiplyScalar","intensity"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js"],"sourcesContent":["import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/ vec3 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\n\nlet depthMaterial = null;\n\nclass AnalyticLightNode extends LightingNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\tthis.light = light;\n\n\t\tthis.rtt = null;\n\t\tthis.shadowNode = null;\n\n\t\tthis.color = new Color();\n\t\tthis.colorNode = uniform( this.color );\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tlet shadowNode = this.shadowNode;\n\n\t\tif ( shadowNode === null ) {\n\n\t\t\tif ( depthMaterial === null ) depthMaterial = builder.createNodeMaterial( 'MeshBasicNodeMaterial' );\n\n\t\t\tconst shadow = this.light.shadow;\n\t\t\tconst rtt = builder.getRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\t\tconst depthTexture = new DepthTexture();\n\t\t\tdepthTexture.minFilter = NearestFilter;\n\t\t\tdepthTexture.magFilter = NearestFilter;\n\t\t\tdepthTexture.image.width = shadow.mapSize.width;\n\t\t\tdepthTexture.image.height = shadow.mapSize.height;\n\t\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\t\trtt.depthTexture = depthTexture;\n\n\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t//\n\n\t\t\tconst bias = reference( 'bias', 'float', shadow );\n\t\t\tconst normalBias = reference( 'normalBias', 'float', shadow );\n\n\t\t\tlet shadowCoord = uniform( shadow.matrix ).mul( positionWorld.add( normalWorld.mul( normalBias ) ) );\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\t\tshadowCoord = vec3(\n\t\t\t\tshadowCoord.x,\n\t\t\t\tshadowCoord.y.oneMinus(), // WebGPU: Flip Y\n\t\t\t\tshadowCoord.z.add( bias ).mul( 2 ).sub( 1 ) // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n\t\t\t);\n\n\t\t\tconst textureCompare = ( depthTexture, shadowCoord, compare ) => texture( depthTexture, shadowCoord ).compare( compare );\n\t\t\t//const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n\t\t\t// BasicShadowMap\n\n\t\t\tshadowNode = textureCompare( depthTexture, shadowCoord.xy, shadowCoord.z );\n\n\t\t\t// PCFShadowMap\n\t\t\t/*\n\t\t\tconst mapSize = reference( 'mapSize', 'vec2', shadow );\n\t\t\tconst radius = reference( 'radius', 'float', shadow );\n\n\t\t\tconst texelSize = vec2( 1 ).div( mapSize );\n\t\t\tconst dx0 = texelSize.x.negate().mul( radius );\n\t\t\tconst dy0 = texelSize.y.negate().mul( radius );\n\t\t\tconst dx1 = texelSize.x.mul( radius );\n\t\t\tconst dy1 = texelSize.y.mul( radius );\n\t\t\tconst dx2 = dx0.mul( 2 );\n\t\t\tconst dy2 = dy0.mul( 2 );\n\t\t\tconst dx3 = dx1.mul( 2 );\n\t\t\tconst dy3 = dy1.mul( 2 );\n\n\t\t\tshadowNode = add(\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t\t\t).mul( 1 / 17 );\n\t\t\t*/\n\t\t\t//\n\n\t\t\tthis.rtt = rtt;\n\t\t\tthis.colorNode = this.colorNode.mul( frustumTest.mix( 1, shadowNode ) );\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\t//\n\n\t\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.light.castShadow ) this.setupShadow( builder );\n\n\t}\n\n\tupdateShadow( frame ) {\n\n\t\tconst { rtt, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tscene.overrideMaterial = depthMaterial;\n\n\t\trtt.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );\n\n\t\tlight.shadow.updateMatrices( light );\n\n\t\trenderer.setRenderTarget( rtt );\n\t\trenderer.render( scene, light.shadow.camera );\n\t\trenderer.setRenderTarget( null );\n\n\t\tscene.overrideMaterial = null;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tif ( light.castShadow ) this.updateShadow( frame );\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nexport default AnalyticLightNode;\n\naddNodeClass( 'AnalyticLightNode', AnalyticLightNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}