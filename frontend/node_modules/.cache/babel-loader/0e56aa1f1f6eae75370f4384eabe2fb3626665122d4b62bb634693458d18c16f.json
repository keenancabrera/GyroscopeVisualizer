{"ast":null,"code":"import * as THREE from 'three';\nclass Cylinder {\n  constructor(parameters, cartesian) {\n    this.parameters = parameters;\n    this.oldPosition = new THREE.Vector3();\n    this.geometry = new THREE.CylinderGeometry(parameters.a.value,\n    // top radius\n    parameters.a.value,\n    // bottom radius\n    parameters.h.value,\n    // height\n    32,\n    // radial segments (default = 32)\n    1,\n    // height segments (default = 1)\n    0,\n    // theta start\n    Math.PI // theta end\n    );\n\n    this.material = new THREE.MeshBasicMaterial({\n      color: \"red\",\n      wireframe: true\n    });\n    // this.material = [new THREE.MeshPhongMaterial({ color: 'blue', shininess: 200 }),new THREE.MeshPhongMaterial({ color: 'red', shininess: 200 })]\n    this.cylinder = new THREE.Mesh(this.geometry, this.material);\n\n    // Adjust cylinder position, set oldPosition vector which we will need to perform rotations.\n    this.cylinder.rotation.set(Math.PI / 2, 0, 0);\n    this.cylinder.position.set(0, 0, this.parameters.l.value);\n    this.cylinder.getWorldPosition(this.oldPosition);\n    this.updateCylinder(cartesian);\n  }\n  get object() {\n    return this.cylinder;\n  }\n  updateCylinder(cartesian, rotate = true) {\n    if (rotate == false) {\n      this.cylinder.position.set(cartesian['x'], cartesian['y'], cartesian['z']);\n      return;\n    }\n    let currentPosition = new THREE.Vector3(cartesian['x'], cartesian['y'], cartesian['z']);\n    let angle = this.oldPosition.angleTo(currentPosition);\n    let difference = currentPosition.clone().sub(this.oldPosition);\n    let rotationVector = new THREE.Vector3().crossVectors(difference, this.oldPosition);\n\n    // Move cylinder to new location\n    this.cylinder.position.set(cartesian['x'], cartesian['y'], cartesian['z']);\n\n    // theta and phi rotations\n    this.cylinder.rotateOnWorldAxis(rotationVector.normalize(), -angle);\n\n    // psi rotation\n    this.cylinder.rotateOnWorldAxis(currentPosition.normalize(), this.state.psi.value);\n\n    // set oldPosition so the next rotation can be calculated properly\n    this.oldPosition = currentPosition.clone();\n  }\n}\nexport { Cylinder };","map":{"version":3,"names":["THREE","Cylinder","constructor","parameters","cartesian","oldPosition","Vector3","geometry","CylinderGeometry","a","value","h","Math","PI","material","MeshBasicMaterial","color","wireframe","cylinder","Mesh","rotation","set","position","l","getWorldPosition","updateCylinder","object","rotate","currentPosition","angle","angleTo","difference","clone","sub","rotationVector","crossVectors","rotateOnWorldAxis","normalize","state","psi"],"sources":["/Users/cabrera/Documents/PortfolioWebiste/frontend/src/gyroscopeRenderer/components/cylinder.js"],"sourcesContent":["import * as THREE from 'three';\n\nclass Cylinder {\n  constructor(parameters, cartesian){\n  this.parameters = parameters\n  this.oldPosition = new THREE.Vector3()\n  this.geometry = new THREE.CylinderGeometry(\n    parameters.a.value, // top radius\n    parameters.a.value, // bottom radius\n    parameters.h.value, // height\n    32, // radial segments (default = 32)\n    1, // height segments (default = 1)\n    0, // theta start\n    Math.PI // theta end\n    ); \n  this.material = new THREE.MeshBasicMaterial({color : \"red\", wireframe : true})\n  // this.material = [new THREE.MeshPhongMaterial({ color: 'blue', shininess: 200 }),new THREE.MeshPhongMaterial({ color: 'red', shininess: 200 })]\n  this.cylinder = new THREE.Mesh(this.geometry, this.material);\n\n\n  // Adjust cylinder position, set oldPosition vector which we will need to perform rotations.\n  this.cylinder.rotation.set(Math.PI/2,0,0) \n  this.cylinder.position.set(0,0,this.parameters.l.value)\n  this.cylinder.getWorldPosition(this.oldPosition)\n  this.updateCylinder(cartesian)\n  \n  }\n  get object() {\n    return this.cylinder\n  }\n\n  updateCylinder(cartesian, rotate = true){\n\n    if (rotate == false) {\n      this.cylinder.position.set(cartesian['x'], cartesian['y'], cartesian['z'])\n      return\n    }\n\n\n    let currentPosition = new THREE.Vector3(cartesian['x'], cartesian['y'], cartesian['z'])\n\n    let angle = this.oldPosition.angleTo(currentPosition)\n    let difference = currentPosition.clone().sub(this.oldPosition)\n    let rotationVector = new THREE.Vector3().crossVectors(difference, this.oldPosition)\n\n    // Move cylinder to new location\n    this.cylinder.position.set(cartesian['x'], cartesian['y'], cartesian['z'])\n\n    // theta and phi rotations\n    this.cylinder.rotateOnWorldAxis(rotationVector.normalize(), -angle)\n\n    // psi rotation\n    this.cylinder.rotateOnWorldAxis(currentPosition.normalize(), this.state.psi.value)\n\n    // set oldPosition so the next rotation can be calculated properly\n    this.oldPosition = currentPosition.clone()\n  }\n}\n\nexport { Cylinder };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}