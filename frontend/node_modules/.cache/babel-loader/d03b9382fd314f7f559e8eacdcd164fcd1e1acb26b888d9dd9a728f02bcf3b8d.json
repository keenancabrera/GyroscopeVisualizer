{"ast":null,"code":"import DataMap from './DataMap.js';\nimport { AttributeType } from './Constants.js';\nclass Bindings extends DataMap {\n  constructor(backend, nodes, textures, attributes, pipelines, info) {\n    super();\n    this.backend = backend;\n    this.textures = textures;\n    this.pipelines = pipelines;\n    this.attributes = attributes;\n    this.nodes = nodes;\n    this.info = info;\n    this.pipelines.bindings = this; // assign bindings to pipelines\n\n    this.updateMap = new WeakMap();\n  }\n  getForRender(renderObject) {\n    const bindings = renderObject.getBindings();\n    const data = this.get(renderObject);\n    if (data.bindings !== bindings) {\n      // each object defines an array of bindings (ubos, textures, samplers etc.)\n\n      data.bindings = bindings;\n      this._init(bindings);\n      this.backend.createBindings(bindings);\n    }\n    return data.bindings;\n  }\n  getForCompute(computeNode) {\n    const data = this.get(computeNode);\n    if (data.bindings === undefined) {\n      const nodeBuilderState = this.nodes.getForCompute(computeNode);\n      const bindings = nodeBuilderState.bindings;\n      data.bindings = bindings;\n      this._init(bindings);\n      this.backend.createBindings(bindings);\n    }\n    return data.bindings;\n  }\n  updateForCompute(computeNode) {\n    this._update(computeNode, this.getForCompute(computeNode));\n  }\n  updateForRender(renderObject) {\n    this._update(renderObject, this.getForRender(renderObject));\n  }\n  _init(bindings) {\n    for (const binding of bindings) {\n      if (binding.isSampledTexture) {\n        this.textures.updateTexture(binding.texture);\n      } else if (binding.isStorageBuffer) {\n        const attribute = binding.attribute;\n        this.attributes.update(attribute, AttributeType.STORAGE);\n      }\n    }\n  }\n  _update(object, bindings) {\n    const {\n      backend\n    } = this;\n    const updateMap = this.updateMap;\n    const frame = this.info.render.frame;\n    let needsBindingsUpdate = false;\n\n    // iterate over all bindings and check if buffer updates or a new binding group is required\n\n    for (const binding of bindings) {\n      const isUpdated = updateMap.get(binding) === frame;\n      if (isUpdated) continue;\n      if (binding.isUniformBuffer) {\n        const needsUpdate = binding.update();\n        if (needsUpdate) {\n          backend.updateBinding(binding);\n        }\n      } else if (binding.isSampledTexture) {\n        if (binding.needsBindingsUpdate) needsBindingsUpdate = true;\n        const needsUpdate = binding.update();\n        if (needsUpdate) {\n          this.textures.updateTexture(binding.texture);\n        }\n      }\n      updateMap.set(binding, frame);\n    }\n    if (needsBindingsUpdate === true) {\n      const pipeline = this.pipelines.getForRender(object);\n      this.backend.updateBindings(bindings, pipeline);\n    }\n  }\n  dispose() {\n    super.dispose();\n    this.updateMap = new WeakMap();\n  }\n}\nexport default Bindings;","map":{"version":3,"names":["DataMap","AttributeType","Bindings","constructor","backend","nodes","textures","attributes","pipelines","info","bindings","updateMap","WeakMap","getForRender","renderObject","getBindings","data","get","_init","createBindings","getForCompute","computeNode","undefined","nodeBuilderState","updateForCompute","_update","updateForRender","binding","isSampledTexture","updateTexture","texture","isStorageBuffer","attribute","update","STORAGE","object","frame","render","needsBindingsUpdate","isUpdated","isUniformBuffer","needsUpdate","updateBinding","set","pipeline","updateBindings","dispose"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/common/Bindings.js"],"sourcesContent":["import DataMap from './DataMap.js';\nimport { AttributeType } from './Constants.js';\n\nclass Bindings extends DataMap {\n\n\tconstructor( backend, nodes, textures, attributes, pipelines, info ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\t\tthis.textures = textures;\n\t\tthis.pipelines = pipelines;\n\t\tthis.attributes = attributes;\n\t\tthis.nodes = nodes;\n\t\tthis.info = info;\n\n\t\tthis.pipelines.bindings = this; // assign bindings to pipelines\n\n\t\tthis.updateMap = new WeakMap();\n\n\t}\n\n\tgetForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( data.bindings !== bindings ) {\n\n\t\t\t// each object defines an array of bindings (ubos, textures, samplers etc.)\n\n\t\t\tdata.bindings = bindings;\n\n\t\t\tthis._init( bindings );\n\n\t\t\tthis.backend.createBindings( bindings );\n\n\t\t}\n\n\t\treturn data.bindings;\n\n\t}\n\n\tgetForCompute( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( data.bindings === undefined ) {\n\n\t\t\tconst nodeBuilderState = this.nodes.getForCompute( computeNode );\n\n\t\t\tconst bindings = nodeBuilderState.bindings;\n\n\t\t\tdata.bindings = bindings;\n\n\t\t\tthis._init( bindings );\n\n\t\t\tthis.backend.createBindings( bindings );\n\n\t\t}\n\n\t\treturn data.bindings;\n\n\t}\n\n\tupdateForCompute( computeNode ) {\n\n\t\tthis._update( computeNode, this.getForCompute( computeNode ) );\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tthis._update( renderObject, this.getForRender( renderObject ) );\n\n\t}\n\n\t_init( bindings ) {\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tif ( binding.isSampledTexture ) {\n\n\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\n\t\t\t\tthis.attributes.update( attribute, AttributeType.STORAGE );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_update( object, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst updateMap = this.updateMap;\n\t\tconst frame = this.info.render.frame;\n\n\t\tlet needsBindingsUpdate = false;\n\n\t\t// iterate over all bindings and check if buffer updates or a new binding group is required\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tconst isUpdated = updateMap.get( binding ) === frame;\n\n\t\t\tif ( isUpdated ) continue;\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst needsUpdate = binding.update();\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tbackend.updateBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tif ( binding.needsBindingsUpdate ) needsBindingsUpdate = true;\n\n\t\t\t\tconst needsUpdate = binding.update();\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tupdateMap.set( binding, frame );\n\n\t\t}\n\n\t\tif ( needsBindingsUpdate === true ) {\n\n\t\t\tconst pipeline = this.pipelines.getForRender( object );\n\n\t\t\tthis.backend.updateBindings( bindings, pipeline );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.updateMap = new WeakMap();\n\n\t}\n\n}\n\nexport default Bindings;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}