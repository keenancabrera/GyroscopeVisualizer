{"ast":null,"code":"import * as THREE from 'three';\nimport { MeshStandardNodeMaterial } from 'three/examples/jsm/nodes/Nodes.js';\nclass Cylinder {\n  constructor(state, parameters, thetaStart, color) {\n    this.thetaStart = thetaStart;\n    this.oldPsi = state.psi;\n    this.parameters = parameters;\n    this.oldPosition = new THREE.Vector3();\n    let geometry = new THREE.CylinderGeometry(parameters.a.value,\n    // top radius\n    parameters.a.value,\n    // bottom radius\n    parameters.h.value,\n    // height\n    32,\n    // radial segments (default = 32)\n    1,\n    // height segments (default = 1)\n    false,\n    // true = open ended, false = filled\n    thetaStart,\n    // theta start\n    Math.PI // theta length\n    );\n    // let material = new THREE.MeshBasicMaterial({color : color, wireframe : false})\n    // let material = new THREE.MeshPhongMaterial({ color: color, shininess: 200 })\n    // let material = new THREE.MeshLambertMaterial({color : color})\n    let material = new THREE.MeshStandardNodeMaterial();\n    material.colorNode = color(color);\n    this.cylinder = new THREE.Mesh(geometry, material);\n    this.cylinder.layers.enable(1); // Ensuring ambient light only applies to the cylinder.\n    this.cylinder.castShadow = true;\n\n    // Adjust cylinder position, set oldPosition vector which we will need to perform rotations.\n    this.cylinder.rotation.set(Math.PI / 2, 0, 0);\n    this.cylinder.position.set(0, 0, this.parameters.l.value);\n    this.cylinder.getWorldPosition(this.oldPosition);\n    this.tick(state);\n  }\n  get object() {\n    return this.cylinder;\n  }\n  changeParameters(parameters) {\n    let geometry = new THREE.CylinderGeometry(parameters.a.value,\n    // top radius\n    parameters.a.value,\n    // bottom radius\n    parameters.h.value,\n    // height\n    32,\n    // radial segments (default = 32)\n    1,\n    // height segments (default = 1)\n    false,\n    // 0: open ended, 1: filled\n    this.thetaStart,\n    // theta start\n    Math.PI // theta end\n    );\n\n    this.cylinder.geometry.dispose();\n    this.cylinder.geometry = geometry;\n    // this.tick(state, false)\n  }\n\n  tick(state, rotate = true) {\n    if (rotate == false) {\n      this.cylinder.position.set(state['x'], state['y'], state['z']);\n      return;\n    }\n    let currentPosition = new THREE.Vector3(state['x'], state['y'], state['z']);\n    let angle = this.oldPosition.angleTo(currentPosition);\n    let difference = currentPosition.clone().sub(this.oldPosition);\n    let rotationVector = new THREE.Vector3().crossVectors(difference, this.oldPosition);\n\n    // Move cylinder to new location\n    this.cylinder.position.set(state['x'], state['y'], state['z']);\n\n    // theta and phi rotations\n    this.cylinder.rotateOnWorldAxis(rotationVector.normalize(), -angle);\n\n    // psi rotation\n    this.cylinder.rotateOnWorldAxis(currentPosition.normalize(), state['psi'] - this.oldPsi);\n\n    // set oldPosition and old.Psi so the next rotation can be calculated properly\n    this.oldPosition = currentPosition.clone();\n    this.oldPsi = state['psi'];\n  }\n}\nexport { Cylinder };","map":{"version":3,"names":["THREE","MeshStandardNodeMaterial","Cylinder","constructor","state","parameters","thetaStart","color","oldPsi","psi","oldPosition","Vector3","geometry","CylinderGeometry","a","value","h","Math","PI","material","colorNode","cylinder","Mesh","layers","enable","castShadow","rotation","set","position","l","getWorldPosition","tick","object","changeParameters","dispose","rotate","currentPosition","angle","angleTo","difference","clone","sub","rotationVector","crossVectors","rotateOnWorldAxis","normalize"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/src/gyroscopeRenderer/components/cylinder.js"],"sourcesContent":["import * as THREE from 'three';\nimport { MeshStandardNodeMaterial } from 'three/examples/jsm/nodes/Nodes.js'\nclass Cylinder {\n  constructor(state, parameters, thetaStart, color){\n  this.thetaStart = thetaStart\n  this.oldPsi = state.psi\n  this.parameters = parameters\n  this.oldPosition = new THREE.Vector3()\n  let geometry = new THREE.CylinderGeometry(\n    parameters.a.value, // top radius\n    parameters.a.value, // bottom radius\n    parameters.h.value, // height\n    32, // radial segments (default = 32)\n    1, // height segments (default = 1)\n    false, // true = open ended, false = filled\n    thetaStart, // theta start\n    Math.PI // theta length\n    ); \n  // let material = new THREE.MeshBasicMaterial({color : color, wireframe : false})\n  // let material = new THREE.MeshPhongMaterial({ color: color, shininess: 200 })\n  // let material = new THREE.MeshLambertMaterial({color : color})\n  let material = new THREE.MeshStandardNodeMaterial()\n    material.colorNode = color(color)\n  this.cylinder = new THREE.Mesh(geometry, material);\n  this.cylinder.layers.enable(1) // Ensuring ambient light only applies to the cylinder.\n  this.cylinder.castShadow = true\n\n\n  // Adjust cylinder position, set oldPosition vector which we will need to perform rotations.\n  this.cylinder.rotation.set(Math.PI/2,0,0) \n  this.cylinder.position.set(0,0,this.parameters.l.value)\n  this.cylinder.getWorldPosition(this.oldPosition)\n  this.tick(state)\n  \n  }\n  get object() {\n    return this.cylinder\n  }\n\n  changeParameters(parameters){\n    let geometry = new THREE.CylinderGeometry(\n      parameters.a.value, // top radius\n      parameters.a.value, // bottom radius\n      parameters.h.value, // height\n      32, // radial segments (default = 32)\n      1, // height segments (default = 1)\n      false, // 0: open ended, 1: filled\n      this.thetaStart, // theta start\n      Math.PI // theta end\n      ); \n    this.cylinder.geometry.dispose()\n    this.cylinder.geometry = geometry\n      // this.tick(state, false)\n  }\n\n  tick(state, rotate = true){\n    if (rotate == false) {\n      this.cylinder.position.set(state['x'], state['y'], state['z'])\n      return\n    }\n\n\n    let currentPosition = new THREE.Vector3(state['x'], state['y'], state['z'])\n\n    let angle = this.oldPosition.angleTo(currentPosition)\n    let difference = currentPosition.clone().sub(this.oldPosition)\n    let rotationVector = new THREE.Vector3().crossVectors(difference, this.oldPosition)\n\n    // Move cylinder to new location\n    this.cylinder.position.set(state['x'], state['y'], state['z'])\n\n    // theta and phi rotations\n    this.cylinder.rotateOnWorldAxis(rotationVector.normalize(), -angle)\n\n    // psi rotation\n    this.cylinder.rotateOnWorldAxis(currentPosition.normalize(), state['psi'] - this.oldPsi)\n\n    // set oldPosition and old.Psi so the next rotation can be calculated properly\n    this.oldPosition = currentPosition.clone()\n    this.oldPsi = state['psi']\n  }\n}\n\nexport { Cylinder };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}