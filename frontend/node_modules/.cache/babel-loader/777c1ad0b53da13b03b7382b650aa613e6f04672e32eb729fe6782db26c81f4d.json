{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport { createNodeMaterialFromType } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\nimport { FloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform, ColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform } from '../../renderers/common/nodes/NodeUniform.js';\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\nimport { stack } from './StackNode.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nconst typeFromLength = new Map([[2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nconst typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nconst isNonPaddingElementArray = new Set([Int32Array, Uint32Array, Float32Array]);\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser, scene = null, material = null) {\n    this.object = object;\n    this.material = material || object && object.material || null;\n    this.geometry = object && object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.scene = scene;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.hashNodes = {};\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.toneMappingNode = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: []\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindings = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindingsOffset = {\n      vertex: 0,\n      fragment: 0,\n      compute: 0\n    };\n    this.bindingsArray = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.vars = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.tab = '\\t';\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: this.material,\n      getMIPLevelAlgorithmNode: (textureNode, levelNode) => levelNode.mul(maxMipLevel(textureNode))\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n  }\n  getRenderTarget(width, height, options) {\n    return new RenderTarget(width, height, options);\n  }\n  getCubeRenderTarget(size, options) {\n    return new CubeRenderTarget(size, options);\n  }\n  includes(node) {\n    return this.nodes.includes(node);\n  }\n  getBindings() {\n    let bindingsArray = this.bindingsArray;\n    if (bindingsArray === null) {\n      const bindings = this.bindings;\n      this.bindingsArray = bindingsArray = this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute;\n    }\n    return bindingsArray;\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.includes(node) === false) {\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  buildUpdateNodes() {\n    for (const node of this.nodes) {\n      const updateType = node.getUpdateType();\n      const updateBeforeType = node.getUpdateBeforeType();\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node.getSelf());\n      }\n      if (updateBeforeType !== NodeUpdateType.NONE) {\n        this.updateBeforeNodes.push(node);\n      }\n    }\n  }\n  get currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n  addChain(node) {\n    /*\n    if ( this.chaining.indexOf( node ) !== - 1 ) {\n    \t\tconsole.warn( 'Recursive node: ', node );\n    \t}\n    */\n\n    this.chaining.push(node);\n  }\n  removeChain(node) {\n    const lastChain = this.chaining.pop();\n    if (lastChain !== node) {\n      throw new Error('NodeBuilder: Invalid node chaining!');\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  setCache(cache) {\n    this.cache = cache;\n  }\n  getCache() {\n    return this.cache;\n  }\n  isAvailable( /*name*/\n  ) {\n    return false;\n  }\n  getVertexIndex() {\n    console.warn('Abstract function.');\n  }\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n  isFlipY() {\n    return false;\n  }\n  getTexture( /* texture, textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  getTextureLevel( /* texture, textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  // @TODO: rename to .generateConst()\n  getConst(type, value = null) {\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const getConst = value => this.getConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      return `${this.getType(type)}( ${value.elements.map(getConst).join(', ')} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    if (type === 'color') return 'vec3';\n    return type;\n  }\n  generateMethod(method) {\n    return method;\n  }\n  hasGeometryAttribute(name) {\n    return this.geometry && this.geometry.getAttribute(name) !== undefined;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n  }\n  needsColorSpaceToLinear( /*texture*/\n  ) {\n    return false;\n  }\n\n  /** @deprecated, r152 */\n  getTextureEncodingFromMap(map) {\n    console.warn('THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.');\n    return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n  }\n  getTextureColorSpaceFromMap(map) {\n    let colorSpace;\n    if (map && map.isTexture) {\n      colorSpace = map.colorSpace;\n    } else if (map && map.isWebGLRenderTarget) {\n      colorSpace = map.texture.colorSpace;\n    } else {\n      colorSpace = NoColorSpace;\n    }\n    return colorSpace;\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(length, componentType = 'float') {\n    if (length === 1) return componentType;\n    const baseType = typeFromLength.get(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n  getTypeFromArray(array) {\n    return typeFromArray.get(array.constructor);\n  }\n  getTypeFromAttribute(attribute) {\n    let dataAttribute = attribute;\n    if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n    const array = dataAttribute.array;\n    const itemSize = isNonPaddingElementArray.has(array.constructor) ? attribute.itemSize : dataAttribute.stride || attribute.itemSize;\n    const normalized = attribute.normalized;\n    let arrayType;\n    if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    }\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n  addStack() {\n    this.stack = stack(this.stack);\n    return this.stack;\n  }\n  removeStack() {\n    const currentStack = this.stack;\n    this.stack = currentStack.parent;\n    return currentStack;\n  }\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    const cache = node.isGlobal(this) ? this.globalCache : this.cache;\n    let nodeData = cache.getNodeData(node);\n    if (nodeData === undefined) {\n      nodeData = {};\n      cache.setNodeData(node, nodeData);\n    }\n    if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n    return nodeData[shaderStage];\n  }\n  getNodeProperties(node, shaderStage = 'any') {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || (nodeData.properties = {\n      outputNode: null\n    });\n  }\n  getBufferAttributeFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node);\n    let bufferAttribute = nodeData.bufferAttribute;\n    if (bufferAttribute === undefined) {\n      const index = this.uniforms.index++;\n      bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n      this.bufferAttributes.push(bufferAttribute);\n      nodeData.bufferAttribute = bufferAttribute;\n    }\n    return bufferAttribute;\n  }\n  getStructTypeFromNode(node, shaderStage = this.shaderStage, name = null) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeStruct = nodeData.structType;\n    if (nodeStruct === undefined) {\n      const index = this.structs.index++;\n      node.name = `StructType${index}`;\n      this.structs[shaderStage].push(node);\n      nodeData.structType = node;\n    }\n    return node;\n  }\n  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, 'any');\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      nodeVarying = new NodeVarying('nodeVarying' + index, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addLineFlowCode(code) {\n    if (code === '') return this;\n    code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + ';\\n';\n    }\n    this.flow.code += code;\n    return this;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n  addFlowTab() {\n    this.tab += '\\t';\n    return this;\n  }\n  removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  }\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${this.tab + propertyName} = ${flowData.result};\\n`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributesArray() {\n    return this.attributes.concat(this.bufferAttributes);\n  }\n  getAttributes( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVaryings( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVar(type, name) {\n    return `${this.getType(type)} ${name}`;\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    for (const variable of vars) {\n      snippet += `${this.getVar(variable.type, variable.name)}; `;\n    }\n    return snippet;\n  }\n  getUniforms( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    // setup() -> stage 1: create possible new nodes and returns an output reference node\n    // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n    // generate()  -> stage 3: generate shader\n\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      }\n      for (const shaderStage of shaderStages) {\n        this.setShaderStage(shaderStage);\n        const flowNodes = this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n          if (buildStage === 'generate') {\n            this.flowNode(node);\n          } else {\n            node.build(this);\n          }\n        }\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 4: build code for a specific output\n\n    this.buildCode();\n    this.buildUpdateNodes();\n    return this;\n  }\n  getNodeUniform(uniformNode, type) {\n    if (type === 'float') return new FloatNodeUniform(uniformNode);\n    if (type === 'vec2') return new Vector2NodeUniform(uniformNode);\n    if (type === 'vec3') return new Vector3NodeUniform(uniformNode);\n    if (type === 'vec4') return new Vector4NodeUniform(uniformNode);\n    if (type === 'color') return new ColorNodeUniform(uniformNode);\n    if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n    if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" not declared.`);\n  }\n  createNodeMaterial(type) {\n    return createNodeMaterialFromType(type);\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n    }\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n}\nexport default NodeBuilder;","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeKeywords","NodeCache","createNodeMaterialFromType","NodeUpdateType","defaultBuildStages","shaderStages","FloatNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","REVISION","RenderTarget","NoColorSpace","LinearEncoding","sRGBEncoding","SRGBColorSpace","Color","Vector2","Vector3","Vector4","Float16BufferAttribute","stack","maxMipLevel","CubeRenderTarget","typeFromLength","Map","typeFromArray","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","isNonPaddingElementArray","Set","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","scene","material","geometry","nodes","updateNodes","updateBeforeNodes","hashNodes","lightsNode","environmentNode","fogNode","toneMappingNode","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","structs","codes","bindings","bindingsOffset","bindingsArray","attributes","bufferAttributes","varyings","vars","flow","code","chaining","tab","context","keywords","getMIPLevelAlgorithmNode","textureNode","levelNode","mul","cache","globalCache","flowsData","WeakMap","shaderStage","buildStage","getRenderTarget","width","height","options","getCubeRenderTarget","size","includes","node","getBindings","setHashNode","hash","addNode","push","getHash","buildUpdateNodes","updateType","getUpdateType","updateBeforeType","getUpdateBeforeType","NONE","getSelf","currentNode","length","addChain","removeChain","lastChain","pop","Error","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","setCache","getCache","isAvailable","getVertexIndex","console","warn","getInstanceIndex","getFrontFacing","getFragCoord","isFlipY","getTexture","getTextureLevel","getConst","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","isMatrix3","isMatrix4","elements","map","join","generateMethod","hasGeometryAttribute","name","getAttribute","undefined","attribute","getPropertyName","isVector","test","isMatrix","isReference","needsColorSpaceToLinear","getTextureEncodingFromMap","getTextureColorSpaceFromMap","colorSpace","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","baseType","get","prefix","getTypeFromArray","array","getTypeFromAttribute","dataAttribute","isInterleavedBufferAttribute","data","itemSize","has","stride","normalized","arrayType","vecType","vecNum","getVectorFromMatrix","replace","changeComponentType","newComponentType","getIntegerType","addStack","removeStack","currentStack","parent","getDataFromNode","isGlobal","nodeData","getNodeData","setNodeData","getNodeProperties","properties","outputNode","getBufferAttributeFromNode","bufferAttribute","getStructTypeFromNode","nodeStruct","structType","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","getVaryingFromNode","nodeVarying","varying","getCodeFromNode","nodeCode","addLineFlowCode","addFlowCode","addFlowTab","removeFlowTab","slice","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","set","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributesArray","concat","getAttributes","getVaryings","getVar","getVars","snippet","getUniforms","getCodes","getShaderStage","setBuildStage","getBuildStage","buildCode","isNode","getNodeUniform","uniformNode","createNodeMaterial","format","fromType","toType","fromTypeLength","toTypeLength","getSignature"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport { createNodeMaterialFromType } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\n\nimport {\n\tFloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform,\n\tColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform\n} from '../../renderers/common/nodes/NodeUniform.js';\n\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\n\nimport { stack } from './StackNode.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\n\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\n\nconst typeFromLength = new Map( [\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst isNonPaddingElementArray = new Set( [ Int32Array, Uint32Array, Float32Array ] );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser, scene = null, material = null ) {\n\n\t\tthis.object = object;\n\t\tthis.material = material || ( object && object.material ) || null;\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\t\tthis.scene = scene;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.updateBeforeNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.lightsNode = null;\n\t\tthis.environmentNode = null;\n\t\tthis.fogNode = null;\n\t\tthis.toneMappingNode = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.codes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.bindings = { vertex: [], fragment: [], compute: [] };\n\t\tthis.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };\n\t\tthis.bindingsArray = null;\n\t\tthis.attributes = [];\n\t\tthis.bufferAttributes = [];\n\t\tthis.varyings = [];\n\t\tthis.vars = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flow = { code: '' };\n\t\tthis.chaining = [];\n\t\tthis.stack = stack();\n\t\tthis.tab = '\\t';\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: this.material,\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => levelNode.mul( maxMipLevel( textureNode ) )\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t}\n\n\tgetRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\tgetCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\tgetBindings() {\n\n\t\tlet bindingsArray = this.bindingsArray;\n\n\t\tif ( bindingsArray === null ) {\n\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tthis.bindingsArray = bindingsArray = ( this.material !== null ) ? [ ...bindings.vertex, ...bindings.fragment ] : bindings.compute;\n\n\t\t}\n\n\t\treturn bindingsArray;\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgetTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetTextureLevel( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t// @TODO: rename to .generateConst()\n\tgetConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst getConst = value => this.getConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( getConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n\n\t}\n\n\tneedsColorSpaceToLinear( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/** @deprecated, r152 */\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tconsole.warn( 'THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.' );\n\t\treturn this.getTextureColorSpaceFromMap( map ) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n\n\t}\n\n\tgetTextureColorSpaceFromMap( map ) {\n\n\t\tlet colorSpace;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tcolorSpace = map.colorSpace;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tcolorSpace = map.texture.colorSpace;\n\n\t\t} else {\n\n\t\t\tcolorSpace = NoColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = typeFromLength.get( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = isNonPaddingElementArray.has( array.constructor ) ? attribute.itemSize : dataAttribute.stride || attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\tremoveStack() {\n\n\t\tconst currentStack = this.stack;\n\n\t\tthis.stack = currentStack.parent;\n\n\t\treturn currentStack;\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst cache = node.isGlobal( this ) ? this.globalCache : this.cache;\n\n\t\tlet nodeData = cache.getNodeData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setNodeData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\tgetStructTypeFromNode( node, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeStruct = nodeData.structType;\n\n\t\tif ( nodeStruct === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tnode.name = `StructType${index}`;\n\t\t\tthis.structs[ shaderStage ].push( node );\n\n\t\t\tnodeData.structType = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ];\n\t\t\tconst index = vars.length;\n\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tnodeVarying = new NodeVarying( 'nodeVarying' + index, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ];\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddLineFlowCode( code ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: '',\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( const variable of vars ) {\n\n\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tfor ( const nodeCode of codes ) {\n\n\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' ) return new FloatNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\tcreateNodeMaterial( type ) {\n\n\t\treturn createNodeMaterialFromType( type );\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}