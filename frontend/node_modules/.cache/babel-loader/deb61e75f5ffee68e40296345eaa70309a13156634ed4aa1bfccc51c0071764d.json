{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport DataMap from './DataMap.js';\nimport { Color, Mesh, SphereGeometry, BackSide } from 'three';\nimport { context, normalWorld, backgroundBlurriness, backgroundIntensity, NodeMaterial, modelViewProjection } from '../../nodes/Nodes.js';\nlet _clearAlpha;\nconst _clearColor = new Color();\nclass Background extends DataMap {\n  constructor(renderer, nodes) {\n    super();\n    this.renderer = renderer;\n    this.nodes = nodes;\n    this.backgroundMesh = null;\n    this.backgroundMeshNode = null;\n  }\n  update(scene, renderList, renderContext) {\n    const renderer = this.renderer;\n    const background = this.nodes.getBackgroundNode(scene) || scene.background;\n    let forceClear = false;\n    if (background === null) {\n      // no background settings, use clear color configuration from the renderer\n\n      _clearColor.copyLinearToSRGB(renderer._clearColor);\n      _clearAlpha = renderer._clearAlpha;\n    } else if (background.isColor === true) {\n      // background is an opaque color\n\n      _clearColor.copyLinearToSRGB(background);\n      _clearAlpha = 1;\n      forceClear = true;\n    } else if (background.isNode === true) {\n      const sceneData = this.get(scene);\n      const backgroundNode = background;\n      _clearColor.copy(renderer._clearColor);\n      _clearAlpha = renderer._clearAlpha;\n      let backgroundMesh = this.backgroundMesh;\n      if (backgroundMesh === null) {\n        this.backgroundMeshNode = context(backgroundNode, {\n          // @TODO: Add Texture2D support using node context\n          getUVNode: () => normalWorld,\n          getSamplerLevelNode: () => backgroundBlurriness\n        }).mul(backgroundIntensity);\n        let viewProj = modelViewProjection();\n        viewProj = viewProj.setZ(viewProj.w);\n        const nodeMaterial = new NodeMaterial();\n        nodeMaterial.outputNode = this.backgroundMeshNode;\n        nodeMaterial.side = BackSide;\n        nodeMaterial.depthTest = false;\n        nodeMaterial.depthWrite = false;\n        nodeMaterial.fog = false;\n        nodeMaterial.vertexNode = viewProj;\n        this.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);\n        backgroundMesh.frustumCulled = false;\n        backgroundMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        };\n      }\n      const backgroundCacheKey = backgroundNode.getCacheKey();\n      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {\n        this.backgroundMeshNode.node = backgroundNode;\n        backgroundMesh.material.needsUpdate = true;\n        sceneData.backgroundCacheKey = backgroundCacheKey;\n      }\n      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null);\n    } else {\n      console.error('THREE.Renderer: Unsupported background configuration.', background);\n    }\n\n    //\n\n    if (renderer.autoClear === true || forceClear === true) {\n      _clearColor.multiplyScalar(_clearAlpha);\n      const clearColorValue = renderContext.clearColorValue;\n      clearColorValue.r = _clearColor.r;\n      clearColorValue.g = _clearColor.g;\n      clearColorValue.b = _clearColor.b;\n      clearColorValue.a = _clearAlpha;\n      renderContext.depthClearValue = renderer._clearDepth;\n      renderContext.stencilClearValue = renderer._clearStencil;\n      renderContext.clearColor = renderer.autoClearColor === true;\n      renderContext.clearDepth = renderer.autoClearDepth === true;\n      renderContext.clearStencil = renderer.autoClearStencil === true;\n    } else {\n      renderContext.clearColor = false;\n      renderContext.clearDepth = false;\n      renderContext.clearStencil = false;\n    }\n  }\n}\nexport default Background;","map":{"version":3,"names":["DataMap","Color","Mesh","SphereGeometry","BackSide","context","normalWorld","backgroundBlurriness","backgroundIntensity","NodeMaterial","modelViewProjection","_clearAlpha","_clearColor","Background","constructor","renderer","nodes","backgroundMesh","backgroundMeshNode","update","scene","renderList","renderContext","background","getBackgroundNode","forceClear","copyLinearToSRGB","isColor","isNode","sceneData","get","backgroundNode","copy","getUVNode","getSamplerLevelNode","mul","viewProj","setZ","w","nodeMaterial","outputNode","side","depthTest","depthWrite","fog","vertexNode","frustumCulled","onBeforeRender","camera","matrixWorld","copyPosition","backgroundCacheKey","getCacheKey","node","material","needsUpdate","unshift","geometry","console","error","autoClear","multiplyScalar","clearColorValue","r","g","b","a","depthClearValue","_clearDepth","stencilClearValue","_clearStencil","clearColor","autoClearColor","clearDepth","autoClearDepth","clearStencil","autoClearStencil"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/common/Background.js"],"sourcesContent":["import DataMap from './DataMap.js';\nimport { Color, Mesh, SphereGeometry, BackSide } from 'three';\nimport { context, normalWorld, backgroundBlurriness, backgroundIntensity, NodeMaterial, modelViewProjection } from '../../nodes/Nodes.js';\n\nlet _clearAlpha;\nconst _clearColor = new Color();\n\nclass Background extends DataMap {\n\n\tconstructor( renderer, nodes ) {\n\n\t\tsuper();\n\n\t\tthis.renderer = renderer;\n\t\tthis.nodes = nodes;\n\n\t\tthis.backgroundMesh = null;\n\t\tthis.backgroundMeshNode = null;\n\n\t}\n\n\tupdate( scene, renderList, renderContext ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst background = this.nodes.getBackgroundNode( scene ) || scene.background;\n\n\t\tlet forceClear = false;\n\n\t\tif ( background === null ) {\n\n\t\t\t// no background settings, use clear color configuration from the renderer\n\n\t\t\t_clearColor.copyLinearToSRGB( renderer._clearColor );\n\t\t\t_clearAlpha = renderer._clearAlpha;\n\n\t\t} else if ( background.isColor === true ) {\n\n\t\t\t// background is an opaque color\n\n\t\t\t_clearColor.copyLinearToSRGB( background );\n\t\t\t_clearAlpha = 1;\n\t\t\tforceClear = true;\n\n\t\t} else if ( background.isNode === true ) {\n\n\t\t\tconst sceneData = this.get( scene );\n\t\t\tconst backgroundNode = background;\n\n\t\t\t_clearColor.copy( renderer._clearColor );\n\t\t\t_clearAlpha = renderer._clearAlpha;\n\n\t\t\tlet backgroundMesh = this.backgroundMesh;\n\n\t\t\tif ( backgroundMesh === null ) {\n\n\t\t\t\tthis.backgroundMeshNode = context( backgroundNode, {\n\t\t\t\t\t// @TODO: Add Texture2D support using node context\n\t\t\t\t\tgetUVNode: () => normalWorld,\n\t\t\t\t\tgetSamplerLevelNode: () => backgroundBlurriness\n\t\t\t\t} ).mul( backgroundIntensity );\n\n\t\t\t\tlet viewProj = modelViewProjection();\n\t\t\t\tviewProj = viewProj.setZ( viewProj.w );\n\n\t\t\t\tconst nodeMaterial = new NodeMaterial();\n\t\t\t\tnodeMaterial.outputNode = this.backgroundMeshNode;\n\t\t\t\tnodeMaterial.side = BackSide;\n\t\t\t\tnodeMaterial.depthTest = false;\n\t\t\t\tnodeMaterial.depthWrite = false;\n\t\t\t\tnodeMaterial.fog = false;\n\t\t\t\tnodeMaterial.vertexNode = viewProj;\n\n\t\t\t\tthis.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );\n\t\t\t\tbackgroundMesh.frustumCulled = false;\n\n\t\t\t\tbackgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst backgroundCacheKey = backgroundNode.getCacheKey();\n\n\t\t\tif ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {\n\n\t\t\t\tthis.backgroundMeshNode.node = backgroundNode;\n\n\t\t\t\tbackgroundMesh.material.needsUpdate = true;\n\n\t\t\t\tsceneData.backgroundCacheKey = backgroundCacheKey;\n\n\t\t\t}\n\n\t\t\trenderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Renderer: Unsupported background configuration.', background );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderer.autoClear === true || forceClear === true ) {\n\n\t\t\t_clearColor.multiplyScalar( _clearAlpha );\n\n\t\t\tconst clearColorValue = renderContext.clearColorValue;\n\n\t\t\tclearColorValue.r = _clearColor.r;\n\t\t\tclearColorValue.g = _clearColor.g;\n\t\t\tclearColorValue.b = _clearColor.b;\n\t\t\tclearColorValue.a = _clearAlpha;\n\n\t\t\trenderContext.depthClearValue = renderer._clearDepth;\n\t\t\trenderContext.stencilClearValue = renderer._clearStencil;\n\n\t\t\trenderContext.clearColor = renderer.autoClearColor === true;\n\t\t\trenderContext.clearDepth = renderer.autoClearDepth === true;\n\t\t\trenderContext.clearStencil = renderer.autoClearStencil === true;\n\n\t\t} else {\n\n\t\t\trenderContext.clearColor = false;\n\t\t\trenderContext.clearDepth = false;\n\t\t\trenderContext.clearStencil = false;\n\n\t\t}\n\n\t}\n\n}\n\nexport default Background;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}