{"ast":null,"code":"import { GPUTextureViewDimension, GPUIndexFormat, GPUFilterMode, GPUPrimitiveTopology, GPULoadOp, GPUStoreOp } from './WebGPUConstants.js';\nclass WebGPUTexturePassUtils {\n  constructor(device) {\n    this.device = device;\n    const mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n    const mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n    const flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n    this.mipmapSampler = device.createSampler({\n      minFilter: GPUFilterMode.Linear\n    });\n    this.flipYSampler = device.createSampler({\n      minFilter: GPUFilterMode.Nearest\n    }); //@TODO?: Consider using textureLoad()\n\n    // We'll need a new pipeline for every texture format used.\n    this.transferPipelines = {};\n    this.flipYPipelines = {};\n    this.mipmapVertexShaderModule = device.createShaderModule({\n      label: 'mipmapVertex',\n      code: mipmapVertexSource\n    });\n    this.mipmapFragmentShaderModule = device.createShaderModule({\n      label: 'mipmapFragment',\n      code: mipmapFragmentSource\n    });\n    this.flipYFragmentShaderModule = device.createShaderModule({\n      label: 'flipYFragment',\n      code: flipYFragmentSource\n    });\n  }\n  getTransferPipeline(format) {\n    let pipeline = this.transferPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.mipmapFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.transferPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  getFlipYPipeline(format) {\n    let pipeline = this.flipYPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.flipYFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.flipYPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {\n    const format = textureGPUDescriptor.format;\n    const {\n      width,\n      height\n    } = textureGPUDescriptor.size;\n    const transferPipeline = this.getTransferPipeline(format);\n    const flipYPipeline = this.getFlipYPipeline(format);\n    const tempTexture = this.device.createTexture({\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 1\n      },\n      format,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n    });\n    const srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    const dstView = tempTexture.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer: 0\n    });\n    const commandEncoder = this.device.createCommandEncoder({});\n    const pass = (pipeline, sourceView, destinationView) => {\n      const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.flipYSampler\n        }, {\n          binding: 1,\n          resource: sourceView\n        }]\n      });\n      const passEncoder = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n          view: destinationView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n    };\n    pass(transferPipeline, srcView, dstView);\n    pass(flipYPipeline, dstView, srcView);\n    this.device.queue.submit([commandEncoder.finish()]);\n    tempTexture.destroy();\n  }\n  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {\n    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n    let srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.mipmapSampler\n        }, {\n          binding: 1,\n          resource: srcView\n        }]\n      });\n      const dstView = textureGPU.createView({\n        baseMipLevel: i,\n        mipLevelCount: 1,\n        dimension: GPUTextureViewDimension.TwoD,\n        baseArrayLayer\n      });\n      const passEncoder = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n          view: dstView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n      srcView = dstView;\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n  }\n}\nexport default WebGPUTexturePassUtils;","map":{"version":3,"names":["GPUTextureViewDimension","GPUIndexFormat","GPUFilterMode","GPUPrimitiveTopology","GPULoadOp","GPUStoreOp","WebGPUTexturePassUtils","constructor","device","mipmapVertexSource","mipmapFragmentSource","flipYFragmentSource","mipmapSampler","createSampler","minFilter","Linear","flipYSampler","Nearest","transferPipelines","flipYPipelines","mipmapVertexShaderModule","createShaderModule","label","code","mipmapFragmentShaderModule","flipYFragmentShaderModule","getTransferPipeline","format","pipeline","undefined","createRenderPipeline","vertex","module","entryPoint","fragment","targets","primitive","topology","TriangleStrip","stripIndexFormat","Uint32","layout","getFlipYPipeline","flipY","textureGPU","textureGPUDescriptor","baseArrayLayer","width","height","size","transferPipeline","flipYPipeline","tempTexture","createTexture","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","srcView","createView","baseMipLevel","mipLevelCount","dimension","TwoD","dstView","commandEncoder","createCommandEncoder","pass","sourceView","destinationView","bindGroupLayout","getBindGroupLayout","bindGroup","createBindGroup","entries","binding","resource","passEncoder","beginRenderPass","colorAttachments","view","loadOp","Clear","storeOp","Store","clearValue","setPipeline","setBindGroup","draw","end","queue","submit","finish","destroy","generateMipmaps","i"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUTexturePassUtils.js"],"sourcesContent":["import { GPUTextureViewDimension, GPUIndexFormat, GPUFilterMode, GPUPrimitiveTopology, GPULoadOp, GPUStoreOp } from './WebGPUConstants.js';\n\nclass WebGPUTexturePassUtils {\n\n\tconstructor( device ) {\n\n\t\tthis.device = device;\n\n\t\tconst mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n\n\t\tconst mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n\n\t\tconst flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n\t\tthis.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\n\t\tthis.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()\n\n\t\t// We'll need a new pipeline for every texture format used.\n\t\tthis.transferPipelines = {};\n\t\tthis.flipYPipelines = {};\n\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapVertex',\n\t\t\tcode: mipmapVertexSource\n\t\t} );\n\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapFragment',\n\t\t\tcode: mipmapFragmentSource\n\t\t} );\n\n\t\tthis.flipYFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'flipYFragment',\n\t\t\tcode: flipYFragmentSource\n\t\t} );\n\n\t}\n\n\tgetTransferPipeline( format ) {\n\n\t\tlet pipeline = this.transferPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.transferPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tgetFlipYPipeline( format ) {\n\n\t\tlet pipeline = this.flipYPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.flipYFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.flipYPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tflipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst format = textureGPUDescriptor.format;\n\t\tconst { width, height } = textureGPUDescriptor.size;\n\n\t\tconst transferPipeline = this.getTransferPipeline( format );\n\t\tconst flipYPipeline = this.getFlipYPipeline( format );\n\n\t\tconst tempTexture = this.device.createTexture( {\n\t\t\tsize: { width, height, depthOrArrayLayers: 1 },\n\t\t\tformat,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n\t\t} );\n\n\t\tconst srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst dstView = tempTexture.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer: 0\n\t\t} );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tconst pass = ( pipeline, sourceView, destinationView ) => {\n\n\t\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.flipYSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: sourceView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: destinationView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t};\n\n\t\tpass( transferPipeline, srcView, dstView );\n\t\tpass( flipYPipeline, dstView, srcView );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttempTexture.destroy();\n\n\t}\n\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst pipeline = this.getTransferPipeline( textureGPUDescriptor.format );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\tlet srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.mipmapSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: srcView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst dstView = textureGPU.createView( {\n\t\t\t\tbaseMipLevel: i,\n\t\t\t\tmipLevelCount: 1,\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\tbaseArrayLayer\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: dstView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t\tsrcView = dstView;\n\n\t\t}\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t}\n\n}\n\nexport default WebGPUTexturePassUtils;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}