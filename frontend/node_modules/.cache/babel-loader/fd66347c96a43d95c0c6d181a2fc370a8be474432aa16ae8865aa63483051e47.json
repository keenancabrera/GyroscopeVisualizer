{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { Float16BufferAttribute } from 'three';\nimport { GPUInputStepMode } from './WebGPUConstants.js';\nconst typedArraysToVertexFormatPrefix = new Map([[Int8Array, ['sint8', 'snorm8']], [Uint8Array, ['uint8', 'unorm8']], [Int16Array, ['sint16', 'snorm16']], [Uint16Array, ['uint16', 'unorm16']], [Int32Array, ['sint32', 'snorm32']], [Uint32Array, ['uint32', 'unorm32']], [Float32Array, ['float32']]]);\nconst typedAttributeToVertexFormatPrefix = new Map([[Float16BufferAttribute, ['float16']]]);\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map([[Int32Array, 'sint32'], [Uint32Array, 'uint32'], [Float32Array, 'float32']]);\nclass WebGPUAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, usage) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const bufferData = backend.get(bufferAttribute);\n    let buffer = bufferData.buffer;\n    if (buffer === undefined) {\n      const device = backend.device;\n      const array = bufferAttribute.array;\n      const size = array.byteLength + (4 - array.byteLength % 4) % 4; // ensure 4 byte alignment, see #20441\n\n      buffer = device.createBuffer({\n        label: bufferAttribute.name,\n        size: size,\n        usage: usage,\n        mappedAtCreation: true\n      });\n      new array.constructor(buffer.getMappedRange()).set(array);\n      buffer.unmap();\n      bufferData.buffer = buffer;\n    }\n  }\n  updateAttribute(attribute) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = backend.get(bufferAttribute).buffer;\n    const array = bufferAttribute.array;\n    const updateRange = bufferAttribute.updateRange;\n    if (updateRange.count === -1) {\n      // Not using update ranges\n\n      device.queue.writeBuffer(buffer, 0, array, 0);\n    } else {\n      device.queue.writeBuffer(buffer, 0, array, updateRange.offset * array.BYTES_PER_ELEMENT, updateRange.count * array.BYTES_PER_ELEMENT);\n      updateRange.count = -1; // reset range\n    }\n  }\n\n  createShaderVertexBuffers(renderObject) {\n    const attributes = renderObject.getAttributes();\n    const vertexBuffers = new Map();\n    for (let slot = 0; slot < attributes.length; slot++) {\n      const geometryAttribute = attributes[slot];\n      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n      const bufferAttribute = this._getBufferAttribute(geometryAttribute);\n      let vertexBufferLayout = vertexBuffers.get(bufferAttribute);\n      if (vertexBufferLayout === undefined) {\n        let arrayStride, stepMode;\n        if (geometryAttribute.isInterleavedBufferAttribute === true) {\n          arrayStride = geometryAttribute.data.stride * bytesPerElement;\n          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        } else {\n          arrayStride = geometryAttribute.itemSize * bytesPerElement;\n          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        }\n        vertexBufferLayout = {\n          arrayStride,\n          attributes: [],\n          stepMode\n        };\n        vertexBuffers.set(bufferAttribute, vertexBufferLayout);\n      }\n      const format = this._getVertexFormat(geometryAttribute);\n      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;\n      vertexBufferLayout.attributes.push({\n        shaderLocation: slot,\n        offset,\n        format\n      });\n    }\n    return Array.from(vertexBuffers.values());\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    data.buffer.destroy();\n    backend.delete(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    const backend = this.backend;\n    const device = backend.device;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    const bufferGPU = data.buffer;\n    const size = bufferGPU.size;\n    let readBufferGPU = data.readBuffer;\n    let needsUnmap = true;\n    if (readBufferGPU === undefined) {\n      readBufferGPU = device.createBuffer({\n        label: attribute.name,\n        size,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n      });\n      needsUnmap = false;\n      data.readBuffer = readBufferGPU;\n    }\n    const cmdEncoder = device.createCommandEncoder({});\n    cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);\n    if (needsUnmap) readBufferGPU.unmap();\n    const gpuCommands = cmdEncoder.finish();\n    device.queue.submit([gpuCommands]);\n    await readBufferGPU.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = readBufferGPU.getMappedRange();\n    return arrayBuffer;\n  }\n  _getVertexFormat(geometryAttribute) {\n    const {\n      itemSize,\n      normalized\n    } = geometryAttribute;\n    const ArrayType = geometryAttribute.array.constructor;\n    const AttributeType = geometryAttribute.constructor;\n    let format;\n    if (itemSize == 1) {\n      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);\n    } else {\n      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);\n      const prefix = prefixOptions[normalized ? 1 : 0];\n      if (prefix) {\n        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;\n        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n        if (paddedItemSize % 1) {\n          throw new Error('THREE.WebGPUAttributeUtils: Bad vertex format item size.');\n        }\n        format = `${prefix}x${paddedItemSize}`;\n      }\n    }\n    if (!format) {\n      console.error('THREE.WebGPUAttributeUtils: Vertex format not supported yet.');\n    }\n    return format;\n  }\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\nexport default WebGPUAttributeUtils;","map":{"version":3,"names":["Float16BufferAttribute","GPUInputStepMode","typedArraysToVertexFormatPrefix","Map","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","typedAttributeToVertexFormatPrefix","typeArraysToVertexFormatPrefixForItemSize1","WebGPUAttributeUtils","constructor","backend","createAttribute","attribute","usage","bufferAttribute","_getBufferAttribute","bufferData","get","buffer","undefined","device","array","size","byteLength","createBuffer","label","name","mappedAtCreation","getMappedRange","set","unmap","updateAttribute","updateRange","count","queue","writeBuffer","offset","BYTES_PER_ELEMENT","createShaderVertexBuffers","renderObject","attributes","getAttributes","vertexBuffers","slot","length","geometryAttribute","bytesPerElement","vertexBufferLayout","arrayStride","stepMode","isInterleavedBufferAttribute","data","stride","isInstancedInterleavedBuffer","Instance","Vertex","itemSize","isInstancedBufferAttribute","format","_getVertexFormat","push","shaderLocation","Array","from","values","destroyAttribute","destroy","delete","getArrayBufferAsync","bufferGPU","readBufferGPU","readBuffer","needsUnmap","GPUBufferUsage","COPY_DST","MAP_READ","cmdEncoder","createCommandEncoder","copyBufferToBuffer","gpuCommands","finish","submit","mapAsync","GPUMapMode","READ","arrayBuffer","normalized","ArrayType","AttributeType","prefixOptions","prefix","bytesPerUnit","paddedBytesPerUnit","Math","floor","paddedItemSize","Error","console","error"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUAttributeUtils.js"],"sourcesContent":["import { Float16BufferAttribute } from 'three';\nimport { GPUInputStepMode } from './WebGPUConstants.js';\n\nconst typedArraysToVertexFormatPrefix = new Map( [\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\n\t[ Float32Array, [ 'float32', ]],\n] );\n\nconst typedAttributeToVertexFormatPrefix = new Map( [\n\t[ Float16BufferAttribute, [ 'float16', ]],\n] );\n\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\n\t[ Int32Array, 'sint32' ],\n\t[ Uint32Array, 'uint32' ],\n\t[ Float32Array, 'float32' ]\n] );\n\nclass WebGPUAttributeUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateAttribute( attribute, usage ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet buffer = bufferData.buffer;\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tconst device = backend.device;\n\n\t\t\tconst array = bufferAttribute.array;\n\t\t\tconst size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441\n\n\t\t\tbuffer = device.createBuffer( {\n\t\t\t\tlabel: bufferAttribute.name,\n\t\t\t\tsize: size,\n\t\t\t\tusage: usage,\n\t\t\t\tmappedAtCreation: true\n\t\t\t} );\n\n\t\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\n\n\t\t\tbuffer.unmap();\n\n\t\t\tbufferData.buffer = buffer;\n\n\t\t}\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = backend.get( bufferAttribute ).buffer;\n\n\t\tconst array = bufferAttribute.array;\n\t\tconst updateRange = bufferAttribute.updateRange;\n\n\t\tif ( updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\t0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\tupdateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\tupdateRange.count * array.BYTES_PER_ELEMENT\n\t\t\t);\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t}\n\n\tcreateShaderVertexBuffers( renderObject ) {\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst vertexBuffers = new Map();\n\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\n\n\t\t\tconst geometryAttribute = attributes[ slot ];\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n\t\t\tconst bufferAttribute = this._getBufferAttribute( geometryAttribute );\n\n\t\t\tlet vertexBufferLayout = vertexBuffers.get( bufferAttribute );\n\n\t\t\tif ( vertexBufferLayout === undefined ) {\n\n\t\t\t\tlet arrayStride, stepMode;\n\n\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarrayStride = geometryAttribute.itemSize * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertexBufferLayout = {\n\t\t\t\t\tarrayStride,\n\t\t\t\t\tattributes: [],\n\t\t\t\t\tstepMode\n\t\t\t\t};\n\n\t\t\t\tvertexBuffers.set( bufferAttribute, vertexBufferLayout );\n\n\t\t\t}\n\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\n\t\t\tconst offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;\n\n\t\t\tvertexBufferLayout.attributes.push( {\n\t\t\t\tshaderLocation: slot,\n\t\t\t\toffset,\n\t\t\t\tformat\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Array.from( vertexBuffers.values() );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tdata.buffer.destroy();\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tconst bufferGPU = data.buffer;\n\t\tconst size = bufferGPU.size;\n\n\t\tlet readBufferGPU = data.readBuffer;\n\t\tlet needsUnmap = true;\n\n\t\tif ( readBufferGPU === undefined ) {\n\n\t\t\treadBufferGPU = device.createBuffer( {\n\t\t\t\tlabel: attribute.name,\n\t\t\t\tsize,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t} );\n\n\t\t\tneedsUnmap = false;\n\n\t\t\tdata.readBuffer = readBufferGPU;\n\n\t\t}\n\n\t\tconst cmdEncoder = device.createCommandEncoder( {} );\n\n\t\tcmdEncoder.copyBufferToBuffer(\n\t\t\tbufferGPU,\n\t\t\t0,\n\t\t\treadBufferGPU,\n\t\t\t0,\n\t\t\tsize\n\t\t);\n\n\t\tif ( needsUnmap ) readBufferGPU.unmap();\n\n\t\tconst gpuCommands = cmdEncoder.finish();\n\t\tdevice.queue.submit( [ gpuCommands ] );\n\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\n\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\n\n\t\treturn arrayBuffer;\n\n\t}\n\n\t_getVertexFormat( geometryAttribute ) {\n\n\t\tconst { itemSize, normalized } = geometryAttribute;\n\t\tconst ArrayType = geometryAttribute.array.constructor;\n\t\tconst AttributeType = geometryAttribute.constructor;\n\n\t\tlet format;\n\n\t\tif ( itemSize == 1 ) {\n\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\n\n\t\t} else {\n\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\n\n\t\t\tif ( prefix ) {\n\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n\n\t\t\t\tif ( paddedItemSize % 1 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\n\n\t\t\t\t}\n\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! format ) {\n\n\t\t\tconsole.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\nexport default WebGPUAttributeUtils;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}