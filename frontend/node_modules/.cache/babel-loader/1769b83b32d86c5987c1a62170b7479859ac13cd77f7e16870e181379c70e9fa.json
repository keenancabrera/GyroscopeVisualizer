{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { MathNode, GLSLNodeParser, NodeBuilder, NodeMaterial } from '../../../nodes/Nodes.js';\nimport UniformsGroup from '../../common/UniformsGroup.js';\nimport { NodeSampledTexture, NodeSampledCubeTexture } from '../../common/nodes/NodeSampledTexture.js';\nconst glslMethods = {\n  [MathNode.ATAN2]: 'atan',\n  textureDimensions: 'textureSize'\n};\nconst precisionLib = {\n  low: 'lowp',\n  medium: 'mediump',\n  high: 'highp'\n};\nclass GLSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer, scene = null) {\n    super(object, renderer, new GLSLNodeParser(), scene);\n    this.uniformsGroup = {};\n  }\n  getMethod(method) {\n    return glslMethods[method] || method;\n  }\n  getPropertyName(node, shaderStage) {\n    if (node.isOutputStructVar) return '';\n    return super.getPropertyName(node, shaderStage);\n  }\n  getTexture(texture, textureProperty, uvSnippet) {\n    if (texture.isTextureCube) {\n      return `textureCube( ${textureProperty}, ${uvSnippet} )`;\n    } else if (texture.isDepthTexture) {\n      return `texture( ${textureProperty}, ${uvSnippet} ).x`;\n    } else {\n      return `texture( ${textureProperty}, ${uvSnippet} )`;\n    }\n  }\n  getTextureLevel(texture, textureProperty, uvSnippet, biasSnippet) {\n    return `textureLod( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;\n  }\n  getTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    for (const variable of vars) {\n      if (variable.isOutputStructVar) continue;\n      snippets.push(`${this.getVar(variable.type, variable.name)};`);\n    }\n    return snippets.join('\\n\\t');\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const groupSnippets = [];\n    for (const uniform of uniforms) {\n      let snippet = null;\n      let group = false;\n      if (uniform.type === 'texture') {\n        if (uniform.node.value.compareFunction) {\n          snippet = `sampler2DShadow ${uniform.name};`;\n        } else {\n          snippet = `sampler2D ${uniform.name};`;\n        }\n      } else if (uniform.type === 'cubeTexture') {\n        snippet = `samplerCube ${uniform.name};`;\n      } else {\n        const vectorType = this.getVectorType(uniform.type);\n        snippet = `${vectorType} ${uniform.name};`;\n        group = true;\n      }\n      const precision = uniform.node.precision;\n      if (precision !== null) {\n        snippet = precisionLib[precision] + ' ' + snippet;\n      }\n      if (group) {\n        snippet = '\\t' + snippet;\n        groupSnippets.push(snippet);\n      } else {\n        snippet = 'uniform ' + snippet;\n        bindingSnippets.push(snippet);\n      }\n    }\n    let output = '';\n    if (groupSnippets.length > 0) {\n      output += this._getGLSLUniformStruct(shaderStage + 'NodeUniforms', groupSnippets.join('\\n')) + '\\n';\n    }\n    output += bindingSnippets.join('\\n');\n    return output;\n  }\n  getAttributes(shaderStage) {\n    let snippet = '';\n    if (shaderStage === 'vertex') {\n      const attributes = this.attributes;\n      let location = 0;\n      for (const attribute of attributes) {\n        snippet += `layout( location = ${location++} ) in ${attribute.type} ${attribute.name};\\n`;\n      }\n    }\n    return snippet;\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`layout( location = ${i} ) out ${member} m${i};`);\n    }\n    return snippets.join('\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    if (structs.length === 0) {\n      return \"layout( location = 0 ) out vec4 fragColor;\\n\";\n    }\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      let snippet = `\\n`;\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n';\n      snippets.push(snippet);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVaryings(shaderStage) {\n    let snippet = '';\n    const varyings = this.varyings;\n    if (shaderStage === 'vertex') {\n      for (const varying of varyings) {\n        snippet += `${varying.needsInterpolation ? 'out' : '/*out*/'} ${varying.type} ${varying.name};\\n`;\n      }\n    } else if (shaderStage === 'fragment') {\n      for (const varying of varyings) {\n        if (varying.needsInterpolation) {\n          snippet += `in ${varying.type} ${varying.name};\\n`;\n        }\n      }\n    }\n    return snippet;\n  }\n  getVertexIndex() {\n    return 'gl_VertexID';\n  }\n  getFrontFacing() {\n    return 'gl_FrontFacing';\n  }\n  getFragCoord() {\n    return 'gl_FragCoord';\n  }\n  isFlipY() {\n    return true;\n  }\n  _getGLSLUniformStruct(name, vars) {\n    return `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n  }\n  _getGLSLVertexCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// precision\nprecision highp float;\nprecision highp int;\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n  }\n  _getGLSLFragmentCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// precision\nprecision highp float;\nprecision highp int;\nprecision lowp sampler2DShadow;\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    for (const shaderStage in shadersData) {\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += 'gl_Position = ';\n            flow += `${flowSlotData.result};`;\n          } else if (shaderStage === 'fragment') {\n            if (!node.outputNode.isOutputStructNode) {\n              flow += 'fragColor = ';\n              flow += `${flowSlotData.result};`;\n            }\n          }\n        }\n      }\n      const stageData = shadersData[shaderStage];\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);\n\n      //console.log( this.vertexShader );\n      //console.log( this.fragmentShader );\n    } else {\n      console.warn('GLSLNodeBuilder: compute shaders are not supported.');\n      //this.computeShader = this._getGLSLComputeCode( shadersData.compute );\n    }\n  }\n\n  getUniformFromNode(node, type, shaderStage, name = null) {\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let uniformGPU = nodeData.uniformGPU;\n    if (uniformGPU === undefined) {\n      if (type === 'texture') {\n        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node);\n        this.bindings[shaderStage].push(uniformGPU);\n      } else if (type === 'cubeTexture') {\n        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node);\n        this.bindings[shaderStage].push(uniformGPU);\n      } else {\n        let uniformsGroup = this.uniformsGroup[shaderStage];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new UniformsGroup(shaderStage + 'NodeUniforms');\n          //uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n          this.uniformsGroup[shaderStage] = uniformsGroup;\n          this.bindings[shaderStage].push(uniformsGroup);\n        }\n        uniformGPU = this.getNodeUniform(uniformNode, type);\n        uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = uniformGPU;\n    }\n    return uniformNode;\n  }\n  build() {\n    // @TODO: Move this code to super.build()\n\n    const {\n      object,\n      material\n    } = this;\n    if (material !== null) {\n      NodeMaterial.fromMaterial(material).build(this);\n    } else {\n      this.addFlow('compute', object);\n    }\n    return super.build();\n  }\n}\nexport default GLSLNodeBuilder;","map":{"version":3,"names":["MathNode","GLSLNodeParser","NodeBuilder","NodeMaterial","UniformsGroup","NodeSampledTexture","NodeSampledCubeTexture","glslMethods","ATAN2","textureDimensions","precisionLib","low","medium","high","GLSLNodeBuilder","constructor","object","renderer","scene","uniformsGroup","getMethod","method","getPropertyName","node","shaderStage","isOutputStructVar","getTexture","texture","textureProperty","uvSnippet","isTextureCube","isDepthTexture","getTextureLevel","biasSnippet","getTextureCompare","compareSnippet","console","error","getVars","snippets","vars","variable","push","getVar","type","name","join","getUniforms","uniforms","bindingSnippets","groupSnippets","uniform","snippet","group","value","compareFunction","vectorType","getVectorType","precision","output","length","_getGLSLUniformStruct","getAttributes","attributes","location","attribute","getStructMembers","struct","members","getMemberTypes","i","member","getStructs","structs","index","getVaryings","varyings","varying","needsInterpolation","getVertexIndex","getFrontFacing","getFragCoord","isFlipY","_getGLSLVertexCode","shaderData","getSignature","codes","flow","_getGLSLFragmentCode","buildCode","shadersData","material","fragment","vertex","compute","flowCode","flowNodes","mainNode","flowSlotData","getFlowData","slotName","code","result","outputNode","isOutputStructNode","stageData","getCodes","vertexShader","fragmentShader","warn","getUniformFromNode","uniformNode","nodeData","getDataFromNode","uniformGPU","undefined","bindings","getNodeUniform","addUniform","build","fromMaterial","addFlow"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgl/nodes/GLSLNodeBuilder.js"],"sourcesContent":["import { MathNode, GLSLNodeParser, NodeBuilder, NodeMaterial } from '../../../nodes/Nodes.js';\n\nimport UniformsGroup from '../../common/UniformsGroup.js';\nimport { NodeSampledTexture, NodeSampledCubeTexture } from '../../common/nodes/NodeSampledTexture.js';\n\nconst glslMethods = {\n\t[ MathNode.ATAN2 ]: 'atan',\n\ttextureDimensions: 'textureSize'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer, scene = null ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser(), scene );\n\n\t\tthis.uniformsGroup = {};\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\tgetPropertyName( node, shaderStage ) {\n\n\t\tif ( node.isOutputStructVar ) return '';\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\tgetTexture( texture, textureProperty, uvSnippet ) {\n\n\t\tif ( texture.isTextureCube ) {\n\n\t\t\treturn `textureCube( ${textureProperty}, ${uvSnippet} )`;\n\n\t\t} else if ( texture.isDepthTexture ) {\n\n\t\t\treturn `texture( ${textureProperty}, ${uvSnippet} ).x`;\n\n\t\t} else {\n\n\t\t\treturn `texture( ${textureProperty}, ${uvSnippet} )`;\n\n\t\t}\n\n\t}\n\n\tgetTextureLevel( texture, textureProperty, uvSnippet, biasSnippet ) {\n\n\t\treturn `textureLod( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;\n\n\t}\n\n\tgetTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( const variable of vars ) {\n\n\t\t\tif ( variable.isOutputStructVar ) continue;\n\n\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst groupSnippets = [];\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' ) {\n\n\t\t\t\tif ( uniform.node.value.compareFunction ) {\n\n\t\t\t\t\tsnippet = `sampler2DShadow ${uniform.name};`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `sampler2D ${uniform.name};`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${uniform.name};`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${vectorType} ${uniform.name};`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tif ( groupSnippets.length > 0 ) {\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + 'NodeUniforms', groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst attributes = this.attributes;\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `layout( location = ${i} ) out ${ member} m${i};` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length === 0 ) {\n\n\t\t\treturn \"layout( location = 0 ) out vec4 fragColor;\\n\";\n\n\t\t}\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\n\t\t\tlet snippet = `\\n`;\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n';\n\n\t\t\tsnippets.push( snippet );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tsnippet += `${varying.needsInterpolation ? 'out' : '/*out*/'} ${varying.type} ${varying.name};\\n`;\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tsnippet += `in ${varying.type} ${varying.name};\\n`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\treturn 'gl_VertexID';\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord';\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// precision\nprecision highp float;\nprecision highp int;\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// precision\nprecision highp float;\nprecision highp int;\nprecision lowp sampler2DShadow;\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t\t//console.log( this.vertexShader );\n\t\t\t//console.log( this.fragmentShader );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'GLSLNodeBuilder: compute shaders are not supported.' );\n\t\t\t//this.computeShader = this._getGLSLComputeCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node );\n\n\t\t\t\tthis.bindings[ shaderStage ].push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node );\n\n\t\t\t\tthis.bindings[ shaderStage ].push( uniformGPU );\n\n\t\t\t} else {\n\n\t\t\t\tlet uniformsGroup = this.uniformsGroup[ shaderStage ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new UniformsGroup( shaderStage + 'NodeUniforms' );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tthis.uniformsGroup[ shaderStage ] = uniformsGroup;\n\n\t\t\t\t\tthis.bindings[ shaderStage ].push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\tbuild() {\n\n\t\t// @TODO: Move this code to super.build()\n\n\t\tconst { object, material } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tNodeMaterial.fromMaterial( material ).build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\treturn super.build();\n\n\t}\n\n}\n\nexport default GLSLNodeBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}