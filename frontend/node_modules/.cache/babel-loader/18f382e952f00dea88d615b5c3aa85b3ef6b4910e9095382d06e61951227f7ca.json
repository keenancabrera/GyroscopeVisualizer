{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport NodeFunction from '../../../nodes/core/NodeFunction.js';\nimport NodeFunctionInput from '../../../nodes/core/NodeFunctionInput.js';\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+)?/i;\nconst propertiesRegexp = /[a-z_0-9]+|<(.*?)>+/ig;\nconst wgslTypeLib = {\n  f32: 'float'\n};\nconst parse = source => {\n  source = source.trim();\n  const declaration = source.match(declarationRegexp);\n  if (declaration !== null && declaration.length === 4) {\n    // tokenizer\n\n    const inputsCode = declaration[2];\n    const propsMatches = [];\n    let nameMatch = null;\n    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push(nameMatch);\n    }\n\n    // parser\n\n    const inputs = [];\n    let i = 0;\n    while (i < propsMatches.length) {\n      // default\n\n      const name = propsMatches[i++][0];\n      let type = propsMatches[i++][0];\n      type = wgslTypeLib[type] || type;\n\n      // precision\n\n      if (i < propsMatches.length && propsMatches[i][0].startsWith('<') === true) i++;\n\n      // add input\n\n      inputs.push(new NodeFunctionInput(type, name));\n    }\n\n    //\n\n    const blockCode = source.substring(declaration[0].length);\n    const name = declaration[1] !== undefined ? declaration[1] : '';\n    const type = declaration[3] || 'void';\n    return {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a WGSL code.');\n  }\n};\nclass WGSLNodeFunction extends NodeFunction {\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode\n    } = parse(source);\n    super(type, inputs, name);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n  }\n  getCode(name = this.name) {\n    const type = this.type !== 'void' ? '-> ' + this.type : '';\n    return `fn ${name} ( ${this.inputsCode.trim()} ) ${type}` + this.blockCode;\n  }\n}\nexport default WGSLNodeFunction;","map":{"version":3,"names":["NodeFunction","NodeFunctionInput","declarationRegexp","propertiesRegexp","wgslTypeLib","f32","parse","source","trim","declaration","match","length","inputsCode","propsMatches","nameMatch","exec","push","inputs","i","name","type","startsWith","blockCode","substring","undefined","Error","WGSLNodeFunction","constructor","getCode"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeFunction.js"],"sourcesContent":["import NodeFunction from '../../../nodes/core/NodeFunction.js';\nimport NodeFunctionInput from '../../../nodes/core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+)?/i;\nconst propertiesRegexp = /[a-z_0-9]+|<(.*?)>+/ig;\n\nconst wgslTypeLib = {\n\tf32: 'float'\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\t// default\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\t\t\tlet type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\ttype = wgslTypeLib[ type ] || type;\n\n\t\t\t// precision\n\n\t\t\tif ( i < propsMatches.length && propsMatches[ i ][ 0 ].startsWith( '<' ) === true )\n\t\t\t\ti ++;\n\n\t\t\t// add input\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = declaration[ 3 ] || 'void';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\nclass WGSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tconst type = this.type !== 'void' ? '-> ' + this.type : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ type }` + this.blockCode;\n\n\t}\n\n}\n\nexport default WGSLNodeFunction;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}