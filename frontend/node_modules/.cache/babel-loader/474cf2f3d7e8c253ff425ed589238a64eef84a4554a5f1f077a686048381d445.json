{"ast":null,"code":"import { createCamera } from './components/camera.js';\nimport { createCylinder } from './components/cylinder.js';\nimport { createScene } from './components/scene.js';\nimport { createRod } from './components/rod.js';\nimport { createRenderer } from './systems/renderer.js';\nimport * as THREE from 'three';\n// import { Resizer } from './systems/Resizer.js';\n\n// These variables are module-scoped: we cannot access them\n// from outside the module\nlet camera;\nlet renderer;\nlet scene;\nclass gyroscopeAnimation {\n  constructor(container, parameters, state) {\n    this.parameters = parameters;\n    this.state = state;\n    this.solution = {};\n    this.oldPosition = new THREE.Vector3();\n\n    // Create necessary elements, set up renderer, add to container\n    camera = createCamera(container, this.parameters);\n    scene = createScene();\n    renderer = createRenderer();\n    renderer.setSize(container.clientWidth, container.clientHeight);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    container.append(renderer.domElement);\n\n    // Add elements\n    this.cylinder = createCylinder(this.getCartesian());\n    [this.verticies, this.line] = createRod(this.getCartesian());\n    this.axesHelper = new THREE.AxesHelper(3 / 2 * this.parameters.l.value);\n    this.cylinder.position.set(0, 0, 0);\n    this.line.geometry.setAttribute('position', new THREE.BufferAttribute(this.verticies, 3));\n    scene.add(this.cylinder, this.line, this.axesHelper);\n\n    // const resizer = new Resizer(container, camera, renderer);\n  }\n\n  render() {\n    // used to render a single frame\n    renderer.render(scene, camera);\n  }\n  updateState(state) {\n    this.cylinder.getWorldPosition(this.oldPosition);\n    this.state = state;\n  }\n  updateSolution(solution) {\n    this.solution = solution;\n  }\n  getCartesian() {\n    // return cartesian coordinates from theta, phi, and psi\n    let x = this.parameters.l.value * Math.cos(this.state.theta.value) * Math.sin(this.state.phi.value);\n    let y = this.parameters.l.value * Math.sin(this.state.theta.value) * Math.sin(this.state.phi.value);\n    let z = this.parameters.l.value * Math.cos(this.state.phi.value);\n    return {\n      x: x,\n      y: y,\n      z: z\n    };\n  }\n  updateCylinder() {\n    let cartesian = this.getCartesian();\n    let currentPosition = new THREE.Vector3(cartesian['x'], cartesian['y'], cartesian['z']);\n    let angle = this.oldPosition.angleTo(currentPosition);\n    let difference = currentPosition.clone().sub(this.oldPosition);\n    let rotationVector = new THREE.Vector3().crossVectors(difference, this.oldPosition);\n    this.cylinder.position.set(cartesian['x'], cartesian['y'], cartesian['z']);\n    this.cylinder.rotateOnWorldAxis(rotationVector.normalize(), angle);\n  }\n}\nexport { gyroscopeAnimation };","map":{"version":3,"names":["createCamera","createCylinder","createScene","createRod","createRenderer","THREE","camera","renderer","scene","gyroscopeAnimation","constructor","container","parameters","state","solution","oldPosition","Vector3","setSize","clientWidth","clientHeight","setPixelRatio","window","devicePixelRatio","append","domElement","cylinder","getCartesian","verticies","line","axesHelper","AxesHelper","l","value","position","set","geometry","setAttribute","BufferAttribute","add","render","updateState","getWorldPosition","updateSolution","x","Math","cos","theta","sin","phi","y","z","updateCylinder","cartesian","currentPosition","angle","angleTo","difference","clone","sub","rotationVector","crossVectors","rotateOnWorldAxis","normalize"],"sources":["/Users/cabrera/Documents/PortfolioWebiste/frontend/src/gyroscopeRenderer/gyroscopeAnimation.js"],"sourcesContent":["import { createCamera } from './components/camera.js';\nimport { createCylinder } from './components/cylinder.js';\nimport { createScene } from './components/scene.js';\nimport { createRod } from './components/rod.js'\n\nimport { createRenderer } from './systems/renderer.js';\nimport * as THREE from 'three';\n// import { Resizer } from './systems/Resizer.js';\n\n// These variables are module-scoped: we cannot access them\n// from outside the module\nlet camera;\nlet renderer;\nlet scene;\n\nclass gyroscopeAnimation {\n  constructor(container, parameters, state) {\n    this.parameters = parameters\n    this.state = state\n    this.solution = {}\n    this.oldPosition = new THREE.Vector3()\n\n    // Create necessary elements, set up renderer, add to container\n    camera = createCamera(container, this.parameters);\n    scene = createScene();\n\n    renderer = createRenderer();\n    renderer.setSize(container.clientWidth, container.clientHeight)\n    renderer.setPixelRatio(window.devicePixelRatio)\n\n    container.append(renderer.domElement);\n\n    // Add elements\n    this.cylinder = createCylinder(this.getCartesian());\n    [this.verticies, this.line] = createRod(this.getCartesian())\n    this.axesHelper = new THREE.AxesHelper(3/2 * this.parameters.l.value)\n\n    this.cylinder.position.set(0,0,0)\n    this.line.geometry.setAttribute('position', new THREE.BufferAttribute(this.verticies, 3))\n\n    scene.add(this.cylinder, this.line, this.axesHelper);\n\n    // const resizer = new Resizer(container, camera, renderer);\n  }\n\n  \n  render() { // used to render a single frame\n    renderer.render(scene, camera);\n  }\n\n  updateState(state){\n    this.cylinder.getWorldPosition(this.oldPosition)\n    this.state = state\n  }\n\n  updateSolution(solution){\n    this.solution = solution\n  }\n\n  getCartesian(){ // return cartesian coordinates from theta, phi, and psi\n    let x = this.parameters.l.value * Math.cos(this.state.theta.value) * Math.sin(this.state.phi.value)\n    let y = this.parameters.l.value * Math.sin(this.state.theta.value) * Math.sin(this.state.phi.value)\n    let z = this.parameters.l.value * Math.cos(this.state.phi.value)\n\n    return {x:x, y:y, z:z}\n  }\n\n  updateCylinder(){\n    let cartesian = this.getCartesian()\n    let currentPosition = new THREE.Vector3(cartesian['x'], cartesian['y'], cartesian['z'])\n\n    let angle = this.oldPosition.angleTo(currentPosition)\n    let difference = currentPosition.clone().sub(this.oldPosition)\n    let rotationVector = new THREE.Vector3().crossVectors(difference, this.oldPosition)\n\n    this.cylinder.position.set(cartesian['x'], cartesian['y'], cartesian['z'])\n    this.cylinder.rotateOnWorldAxis(rotationVector.normalize(), angle)\n\n\n\n  }\n\n}\n\nexport { gyroscopeAnimation };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}