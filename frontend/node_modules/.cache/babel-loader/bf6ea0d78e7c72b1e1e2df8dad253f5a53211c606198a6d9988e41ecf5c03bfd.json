{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { dot, mix } from '../math/MathNode.js';\nimport { add } from '../math/OperatorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec3, mat3 } from '../shadernode/ShaderNode.js';\nconst saturationNode = tslFn(({\n  color,\n  adjustment\n}) => {\n  return adjustment.mix(luminance(color), color);\n});\nconst vibranceNode = tslFn(({\n  color,\n  adjustment\n}) => {\n  const average = add(color.r, color.g, color.b).div(3.0);\n  const mx = color.r.max(color.g.max(color.b));\n  const amt = mx.sub(average).mul(adjustment).mul(-3.0);\n  return mix(color, mx, amt);\n});\nconst hueNode = tslFn(({\n  color,\n  adjustment\n}) => {\n  const RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);\n  const YIQtoRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);\n  const yiq = RGBtoYIQ.mul(color);\n  const hue = yiq.z.atan2(yiq.y).add(adjustment);\n  const chroma = yiq.yz.length();\n  return YIQtoRGB.mul(vec3(yiq.x, chroma.mul(hue.cos()), chroma.mul(hue.sin())));\n});\nclass ColorAdjustmentNode extends TempNode {\n  constructor(method, colorNode, adjustmentNode = float(1)) {\n    super('vec3');\n    this.method = method;\n    this.colorNode = colorNode;\n    this.adjustmentNode = adjustmentNode;\n  }\n  setup() {\n    const {\n      method,\n      colorNode,\n      adjustmentNode\n    } = this;\n    const callParams = {\n      color: colorNode,\n      adjustment: adjustmentNode\n    };\n    let outputNode = null;\n    if (method === ColorAdjustmentNode.SATURATION) {\n      outputNode = saturationNode(callParams);\n    } else if (method === ColorAdjustmentNode.VIBRANCE) {\n      outputNode = vibranceNode(callParams);\n    } else if (method === ColorAdjustmentNode.HUE) {\n      outputNode = hueNode(callParams);\n    } else {\n      console.error(`${this.type}: Method \"${this.method}\" not supported!`);\n    }\n    return outputNode;\n  }\n}\nColorAdjustmentNode.SATURATION = 'saturation';\nColorAdjustmentNode.VIBRANCE = 'vibrance';\nColorAdjustmentNode.HUE = 'hue';\nexport default ColorAdjustmentNode;\nexport const saturation = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.SATURATION);\nexport const vibrance = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE);\nexport const hue = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.HUE);\nexport const lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);\nexport const luminance = (color, luma = lumaCoeffs) => dot(color, luma);\naddNodeElement('saturation', saturation);\naddNodeElement('vibrance', vibrance);\naddNodeElement('hue', hue);\naddNodeClass('ColorAdjustmentNode', ColorAdjustmentNode);","map":{"version":3,"names":["TempNode","dot","mix","add","addNodeClass","addNodeElement","tslFn","nodeProxy","float","vec3","mat3","saturationNode","color","adjustment","luminance","vibranceNode","average","r","g","b","div","mx","max","amt","sub","mul","hueNode","RGBtoYIQ","YIQtoRGB","yiq","hue","z","atan2","y","chroma","yz","length","x","cos","sin","ColorAdjustmentNode","constructor","method","colorNode","adjustmentNode","setup","callParams","outputNode","SATURATION","VIBRANCE","HUE","console","error","type","saturation","vibrance","lumaCoeffs","luma"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { dot, mix } from '../math/MathNode.js';\nimport { add } from '../math/OperatorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec3, mat3 } from '../shadernode/ShaderNode.js';\n\nconst saturationNode = tslFn( ( { color, adjustment } ) => {\n\n\treturn adjustment.mix( luminance( color ), color );\n\n} );\n\nconst vibranceNode = tslFn( ( { color, adjustment } ) => {\n\n\tconst average = add( color.r, color.g, color.b ).div( 3.0 );\n\n\tconst mx = color.r.max( color.g.max( color.b ) );\n\tconst amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );\n\n\treturn mix( color, mx, amt );\n\n} );\n\nconst hueNode = tslFn( ( { color, adjustment } ) => {\n\n\tconst RGBtoYIQ = mat3( 0.299, 0.587, 0.114, 0.595716, - 0.274453, - 0.321263, 0.211456, - 0.522591, 0.311135 );\n\tconst YIQtoRGB = mat3( 1.0, 0.9563, 0.6210, 1.0, - 0.2721, - 0.6474, 1.0, - 1.107, 1.7046 );\n\n\tconst yiq = RGBtoYIQ.mul( color );\n\n\tconst hue = yiq.z.atan2( yiq.y ).add( adjustment );\n\tconst chroma = yiq.yz.length();\n\n\treturn YIQtoRGB.mul( vec3( yiq.x, chroma.mul( hue.cos() ), chroma.mul( hue.sin() ) ) );\n\n} );\n\nclass ColorAdjustmentNode extends TempNode {\n\n\tconstructor( method, colorNode, adjustmentNode = float( 1 ) ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.method = method;\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.adjustmentNode = adjustmentNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { method, colorNode, adjustmentNode } = this;\n\n\t\tconst callParams = { color: colorNode, adjustment: adjustmentNode };\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === ColorAdjustmentNode.SATURATION ) {\n\n\t\t\toutputNode = saturationNode( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.VIBRANCE ) {\n\n\t\t\toutputNode = vibranceNode( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.HUE ) {\n\n\t\t\toutputNode = hueNode( callParams );\n\n\t\t} else {\n\n\t\t\tconsole.error( `${ this.type }: Method \"${ this.method }\" not supported!` );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nColorAdjustmentNode.SATURATION = 'saturation';\nColorAdjustmentNode.VIBRANCE = 'vibrance';\nColorAdjustmentNode.HUE = 'hue';\n\nexport default ColorAdjustmentNode;\n\nexport const saturation = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.SATURATION );\nexport const vibrance = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE );\nexport const hue = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.HUE );\n\nexport const lumaCoeffs = vec3( 0.2125, 0.7154, 0.0721 );\nexport const luminance = ( color, luma = lumaCoeffs ) => dot( color, luma );\n\naddNodeElement( 'saturation', saturation );\naddNodeElement( 'vibrance', vibrance );\naddNodeElement( 'hue', hue );\n\naddNodeClass( 'ColorAdjustmentNode', ColorAdjustmentNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}