{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeProxy, vec2 } from '../shadernode/ShaderNode.js';\nclass RotateUVNode extends TempNode {\n  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {\n    super('vec2');\n    this.uvNode = uvNode;\n    this.rotationNode = rotationNode;\n    this.centerNode = centerNode;\n  }\n  setup() {\n    const {\n      uvNode,\n      rotationNode,\n      centerNode\n    } = this;\n    const cosAngle = rotationNode.cos();\n    const sinAngle = rotationNode.sin();\n    const vector = uvNode.sub(centerNode);\n    const rotatedVector = vec2(\n    // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?\n    vec2(cosAngle, sinAngle).dot(vector), vec2(sinAngle.negate(), cosAngle).dot(vector));\n    return rotatedVector.add(centerNode);\n  }\n}\nexport default RotateUVNode;\nexport const rotateUV = nodeProxy(RotateUVNode);\naddNodeElement('rotateUV', rotateUV);\naddNodeClass('RotateUVNode', RotateUVNode);","map":{"version":3,"names":["TempNode","addNodeClass","addNodeElement","nodeProxy","vec2","RotateUVNode","constructor","uvNode","rotationNode","centerNode","setup","cosAngle","cos","sinAngle","sin","vector","sub","rotatedVector","dot","negate","add","rotateUV"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeProxy, vec2 } from '../shadernode/ShaderNode.js';\n\nclass RotateUVNode extends TempNode {\n\n\tconstructor( uvNode, rotationNode, centerNode = vec2( 0.5 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.rotationNode = rotationNode;\n\t\tthis.centerNode = centerNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { uvNode, rotationNode, centerNode } = this;\n\n\t\tconst cosAngle = rotationNode.cos();\n\t\tconst sinAngle = rotationNode.sin();\n\n\t\tconst vector = uvNode.sub( centerNode );\n\n\t\tconst rotatedVector = vec2( // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?\n\t\t\tvec2( cosAngle, sinAngle ).dot( vector ),\n\t\t\tvec2( sinAngle.negate(), cosAngle ).dot( vector )\n\t\t);\n\n\t\treturn rotatedVector.add( centerNode );\n\n\t}\n\n}\n\nexport default RotateUVNode;\n\nexport const rotateUV = nodeProxy( RotateUVNode );\n\naddNodeElement( 'rotateUV', rotateUV );\n\naddNodeClass( 'RotateUVNode', RotateUVNode );\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,qBAAqB;AAC1C,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,cAAc,EAAEC,SAAS,EAAEC,IAAI,QAAQ,6BAA6B;AAE7E,MAAMC,YAAY,SAASL,QAAQ,CAAC;EAEnCM,WAAWA,CAAEC,MAAM,EAAEC,YAAY,EAAEC,UAAU,GAAGL,IAAI,CAAE,GAAI,CAAC,EAAG;IAE7D,KAAK,CAAE,MAAO,CAAC;IAEf,IAAI,CAACG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,UAAU,GAAGA,UAAU;EAE7B;EAEAC,KAAKA,CAAA,EAAG;IAEP,MAAM;MAAEH,MAAM;MAAEC,YAAY;MAAEC;IAAW,CAAC,GAAG,IAAI;IAEjD,MAAME,QAAQ,GAAGH,YAAY,CAACI,GAAG,CAAC,CAAC;IACnC,MAAMC,QAAQ,GAAGL,YAAY,CAACM,GAAG,CAAC,CAAC;IAEnC,MAAMC,MAAM,GAAGR,MAAM,CAACS,GAAG,CAAEP,UAAW,CAAC;IAEvC,MAAMQ,aAAa,GAAGb,IAAI;IAAE;IAC3BA,IAAI,CAAEO,QAAQ,EAAEE,QAAS,CAAC,CAACK,GAAG,CAAEH,MAAO,CAAC,EACxCX,IAAI,CAAES,QAAQ,CAACM,MAAM,CAAC,CAAC,EAAER,QAAS,CAAC,CAACO,GAAG,CAAEH,MAAO,CACjD,CAAC;IAED,OAAOE,aAAa,CAACG,GAAG,CAAEX,UAAW,CAAC;EAEvC;AAED;AAEA,eAAeJ,YAAY;AAE3B,OAAO,MAAMgB,QAAQ,GAAGlB,SAAS,CAAEE,YAAa,CAAC;AAEjDH,cAAc,CAAE,UAAU,EAAEmB,QAAS,CAAC;AAEtCpB,YAAY,CAAE,cAAc,EAAEI,YAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}