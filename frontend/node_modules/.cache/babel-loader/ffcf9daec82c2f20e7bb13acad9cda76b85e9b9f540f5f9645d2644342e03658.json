{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NoColorSpace, FloatType } from 'three';\nimport UniformsGroup from '../../common/UniformsGroup.js';\nimport NodeSampler from '../../common/nodes/NodeSampler.js';\nimport { NodeSampledTexture, NodeSampledCubeTexture } from '../../common/nodes/NodeSampledTexture.js';\nimport UniformBuffer from '../../common/UniformBuffer.js';\nimport StorageBuffer from '../../common/StorageBuffer.js';\nimport { getVectorLength, getStrideLength } from '../../common/BufferUtils.js';\nimport { NodeBuilder, CodeNode, NodeMaterial } from '../../../nodes/Nodes.js';\nimport { getFormat } from '../utils/WebGPUTextureUtils.js';\nimport WGSLNodeParser from './WGSLNodeParser.js';\nconst gpuShaderStageLib = {\n  'vertex': GPUShaderStage.VERTEX,\n  'fragment': GPUShaderStage.FRAGMENT,\n  'compute': GPUShaderStage.COMPUTE\n};\nconst supports = {\n  instance: true\n};\nconst wgslTypeLib = {\n  float: 'f32',\n  int: 'i32',\n  uint: 'u32',\n  bool: 'bool',\n  color: 'vec3<f32>',\n  vec2: 'vec2<f32>',\n  ivec2: 'vec2<i32>',\n  uvec2: 'vec2<u32>',\n  bvec2: 'vec2<bool>',\n  vec3: 'vec3<f32>',\n  ivec3: 'vec3<i32>',\n  uvec3: 'vec3<u32>',\n  bvec3: 'vec3<bool>',\n  vec4: 'vec4<f32>',\n  ivec4: 'vec4<i32>',\n  uvec4: 'vec4<u32>',\n  bvec4: 'vec4<bool>',\n  mat3: 'mat3x3<f32>',\n  imat3: 'mat3x3<i32>',\n  umat3: 'mat3x3<u32>',\n  bmat3: 'mat3x3<bool>',\n  mat4: 'mat4x4<f32>',\n  imat4: 'mat4x4<i32>',\n  umat4: 'mat4x4<u32>',\n  bmat4: 'mat4x4<bool>'\n};\nconst wgslMethods = {\n  dFdx: 'dpdx',\n  dFdy: '- dpdy',\n  mod: 'threejs_mod',\n  lessThanEqual: 'threejs_lessThanEqual',\n  inversesqrt: 'inverseSqrt'\n};\nconst wgslPolyfill = {\n  lessThanEqual: new CodeNode(`\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\n\n}\n`),\n  mod: new CodeNode(`\nfn threejs_mod( x : f32, y : f32 ) -> f32 {\n\n\treturn x - y * floor( x / y );\n\n}\n`),\n  repeatWrapping: new CodeNode(`\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n`)\n};\nclass WGSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer, scene = null) {\n    super(object, renderer, new WGSLNodeParser(), scene);\n    this.uniformsGroup = {};\n    this.builtins = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map(),\n      attribute: new Map()\n    };\n  }\n  build() {\n    const {\n      object,\n      material\n    } = this;\n    if (material !== null) {\n      NodeMaterial.fromMaterial(material).build(this);\n    } else {\n      this.addFlow('compute', object);\n    }\n    return super.build();\n  }\n  needsColorSpaceToLinear(texture) {\n    return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n  }\n  _getSampler(texture, textureProperty, uvSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;\n    } else {\n      return this.getTextureLoad(texture, textureProperty, uvSnippet);\n    }\n  }\n  _getVideoSampler(textureProperty, uvSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);\n    }\n  }\n  _getSamplerLevel(texture, textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment' && this.isUnfilterable(texture) === false) {\n      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\n    } else {\n      return this.getTextureLoad(texture, textureProperty, uvSnippet, biasSnippet);\n    }\n  }\n  getTextureLoad(texture, textureProperty, uvSnippet, biasSnippet = '0') {\n    this._include('repeatWrapping');\n    const dimension = `textureDimensions( ${textureProperty}, 0 )`;\n    return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${biasSnippet} ) )`;\n  }\n  isUnfilterable(texture) {\n    return texture.isDataTexture === true && texture.type === FloatType;\n  }\n  getTexture(texture, textureProperty, uvSnippet, shaderStage = this.shaderStage) {\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._getVideoSampler(textureProperty, uvSnippet, shaderStage);\n    } else if (this.isUnfilterable(texture)) {\n      snippet = this.getTextureLoad(texture, textureProperty, uvSnippet);\n    } else {\n      snippet = this._getSampler(texture, textureProperty, uvSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  getTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  getTextureLevel(texture, textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage) {\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._getVideoSampler(textureProperty, uvSnippet, shaderStage);\n    } else {\n      snippet = this._getSamplerLevel(texture, textureProperty, uvSnippet, biasSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  getPropertyName(node, shaderStage = this.shaderStage) {\n    if (node.isNodeVarying === true && node.needsInterpolation === true) {\n      if (shaderStage === 'vertex') {\n        return `NodeVaryings.${node.name}`;\n      }\n    } else if (node.isNodeUniform === true) {\n      const name = node.name;\n      const type = node.type;\n      if (type === 'texture' || type === 'cubeTexture') {\n        return name;\n      } else if (type === 'buffer' || type === 'storageBuffer') {\n        return `NodeBuffer_${node.node.id}.${name}`;\n      } else {\n        return `NodeUniforms.${name}`;\n      }\n    }\n    return super.getPropertyName(node);\n  }\n  getUniformFromNode(node, type, shaderStage, name = null) {\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    if (nodeData.uniformGPU === undefined) {\n      let uniformGPU;\n      const bindings = this.bindings[shaderStage];\n      if (type === 'texture' || type === 'cubeTexture') {\n        let texture = null;\n        if (type === 'texture') {\n          texture = new NodeSampledTexture(uniformNode.name, uniformNode.node);\n        } else if (type === 'cubeTexture') {\n          texture = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node);\n        }\n        texture.store = node.isStoreTextureNode === true;\n        texture.setVisibility(gpuShaderStageLib[shaderStage]);\n\n        // add first textures in sequence and group for last\n        const lastBinding = bindings[bindings.length - 1];\n        const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\n        if (shaderStage === 'fragment' && this.isUnfilterable(node.value) === false && texture.store === false) {\n          const sampler = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node);\n          sampler.setVisibility(gpuShaderStageLib[shaderStage]);\n          bindings.splice(index, 0, sampler, texture);\n          uniformGPU = [sampler, texture];\n        } else {\n          bindings.splice(index, 0, texture);\n          uniformGPU = [texture];\n        }\n      } else if (type === 'buffer' || type === 'storageBuffer') {\n        const bufferClass = type === 'storageBuffer' ? StorageBuffer : UniformBuffer;\n        const buffer = new bufferClass('NodeBuffer_' + node.id, node.value);\n        buffer.setVisibility(gpuShaderStageLib[shaderStage]);\n\n        // add first textures in sequence and group for last\n        const lastBinding = bindings[bindings.length - 1];\n        const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\n        bindings.splice(index, 0, buffer);\n        uniformGPU = buffer;\n      } else {\n        let uniformsGroup = this.uniformsGroup[shaderStage];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new UniformsGroup('nodeUniforms');\n          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);\n          this.uniformsGroup[shaderStage] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        if (node.isArrayUniformNode === true) {\n          uniformGPU = [];\n          for (const uniformNode of node.nodes) {\n            const uniformNodeGPU = this.getNodeUniform(uniformNode, type);\n\n            // fit bounds to buffer\n            uniformNodeGPU.boundary = getVectorLength(uniformNodeGPU.itemSize);\n            uniformNodeGPU.itemSize = getStrideLength(uniformNodeGPU.itemSize);\n            uniformsGroup.addUniform(uniformNodeGPU);\n            uniformGPU.push(uniformNodeGPU);\n          }\n        } else {\n          uniformGPU = this.getNodeUniform(uniformNode, type);\n          uniformsGroup.addUniform(uniformGPU);\n        }\n      }\n      nodeData.uniformGPU = uniformGPU;\n      if (shaderStage === 'vertex') {\n        this.bindingsOffset['fragment'] = bindings.length;\n      }\n    }\n    return uniformNode;\n  }\n  isReference(type) {\n    return super.isReference(type) || type === 'texture_2d' || type === 'texture_cube' || type === 'texture_storage_2d';\n  }\n  getBuiltin(name, property, type, shaderStage = this.shaderStage) {\n    const map = this.builtins[shaderStage];\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        property,\n        type\n      });\n    }\n    return property;\n  }\n  getVertexIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('vertex_index', 'vertexIndex', 'u32', 'attribute');\n    }\n    return 'vertexIndex';\n  }\n  getInstanceIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('instance_index', 'instanceIndex', 'u32', 'attribute');\n    }\n    return 'instanceIndex';\n  }\n  getFrontFacing() {\n    return this.getBuiltin('front_facing', 'isFront', 'bool');\n  }\n  getFragCoord() {\n    return this.getBuiltin('position', 'fragCoord', 'vec4<f32>', 'fragment');\n  }\n  isFlipY() {\n    return false;\n  }\n  getAttributes(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'compute') {\n      this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      for (const {\n        name,\n        property,\n        type\n      } of this.builtins.attribute.values()) {\n        snippets.push(`@builtin( ${name} ) ${property} : ${type}`);\n      }\n      const attributes = this.getAttributesArray();\n      for (let index = 0, length = attributes.length; index < length; index++) {\n        const attribute = attributes[index];\n        const name = attribute.name;\n        const type = this.getType(attribute.type);\n        snippets.push(`@location( ${index} ) ${name} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`\\t@location( ${i} ) m${i} : ${member}<f32>`);\n    }\n    return snippets.join(',\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      const name = struct.name;\n      let snippet = `\\struct ${name} {\\n`;\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n}';\n      snippets.push(snippet);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVar(type, name) {\n    return `var ${name} : ${this.getType(type)}`;\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    for (const variable of vars) {\n      snippets.push(`\\t${this.getVar(variable.type, variable.name)};`);\n    }\n    return `\\n${snippets.join('\\n')}\\n`;\n  }\n  getVaryings(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'fragment') {\n      const varyings = this.varyings;\n      const vars = this.vars[shaderStage];\n      for (let index = 0; index < varyings.length; index++) {\n        const varying = varyings[index];\n        if (varying.needsInterpolation) {\n          let attributesSnippet = `@location( ${index} )`;\n          if (varying.type === 'int' || varying.type === 'uint') {\n            attributesSnippet += ' @interpolate( flat )';\n          }\n          snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`);\n        } else if (shaderStage === 'vertex' && vars.includes(varying) === false) {\n          vars.push(varying);\n        }\n      }\n    }\n    for (const {\n      name,\n      property,\n      type\n    } of this.builtins[shaderStage].values()) {\n      snippets.push(`@builtin( ${name} ) ${property} : ${type}`);\n    }\n    const code = snippets.join(',\\n\\t');\n    return shaderStage === 'vertex' ? this._getWGSLStruct('NodeVaryingsStruct', '\\t' + code) : code;\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const bufferSnippets = [];\n    const groupSnippets = [];\n    let index = this.bindingsOffset[shaderStage];\n    for (const uniform of uniforms) {\n      if (uniform.type === 'texture' || uniform.type === 'cubeTexture') {\n        const texture = uniform.node.value;\n        if (shaderStage === 'fragment' && this.isUnfilterable(texture) === false && uniform.node.isStoreTextureNode !== true) {\n          if (texture.isDepthTexture === true && texture.compareFunction !== null) {\n            bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform.name}_sampler : sampler_comparison;`);\n          } else {\n            bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform.name}_sampler : sampler;`);\n          }\n        }\n        let textureType;\n        if (texture.isCubeTexture === true) {\n          textureType = 'texture_cube<f32>';\n        } else if (texture.isDepthTexture === true) {\n          textureType = 'texture_depth_2d';\n        } else if (texture.isVideoTexture === true) {\n          textureType = 'texture_external';\n        } else if (uniform.node.isStoreTextureNode === true) {\n          const format = getFormat(texture);\n          textureType = 'texture_storage_2d<' + format + ', write>';\n        } else {\n          textureType = 'texture_2d<f32>';\n        }\n        bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform.name} : ${textureType};`);\n      } else if (uniform.type === 'buffer' || uniform.type === 'storageBuffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 ? ', ' + bufferCount : '';\n        const bufferSnippet = `\\t${uniform.name} : array< ${bufferType}${bufferCountSnippet} >\\n`;\n        const bufferAccessMode = bufferNode.isStorageBufferNode ? 'storage,read_write' : 'uniform';\n        bufferSnippets.push(this._getWGSLStructBinding('NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, index++));\n      } else {\n        const vectorType = this.getType(this.getVectorType(uniform.type));\n        if (Array.isArray(uniform.value) === true) {\n          const length = uniform.value.length;\n          groupSnippets.push(`uniform ${vectorType}[ ${length} ] ${uniform.name}`);\n        } else {\n          groupSnippets.push(`\\t${uniform.name} : ${vectorType}`);\n        }\n      }\n    }\n    let code = bindingSnippets.join('\\n');\n    code += bufferSnippets.join('\\n');\n    if (groupSnippets.length > 0) {\n      code += this._getWGSLStructBinding('NodeUniforms', groupSnippets.join(',\\n'), 'uniform', index++);\n    }\n    return code;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    for (const shaderStage in shadersData) {\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += 'NodeVaryings.Vertex = ';\n          } else if (shaderStage === 'fragment') {\n            flow += 'return ';\n          }\n          flow += `${flowSlotData.result};`;\n        }\n      }\n      const outputNode = mainNode.outputNode;\n      const stageData = shadersData[shaderStage];\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.returnType = outputNode !== undefined && outputNode.isOutputStructNode === true ? outputNode.nodeType : '@location( 0 ) vec4<f32>';\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(', '));\n    }\n  }\n  getMethod(method) {\n    if (wgslPolyfill[method] !== undefined) {\n      this._include(method);\n    }\n    return wgslMethods[method] || method;\n  }\n  getType(type) {\n    return wgslTypeLib[type] || type;\n  }\n  isAvailable(name) {\n    return supports[name] === true;\n  }\n  _include(name) {\n    wgslPolyfill[name].build(this);\n  }\n  _getWGSLVertexCode(shaderData) {\n    return `${this.getSignature()}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> NodeVaryingsStruct {\n\n\t// system\n\tvar NodeVaryings: NodeVaryingsStruct;\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn NodeVaryings;\n\n}\n`;\n  }\n  _getWGSLFragmentCode(shaderData) {\n    return `${this.getSignature()}\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLComputeCode(shaderData, workgroupSize) {\n    return `${this.getSignature()}\n// system\nvar<private> instanceIndex : u32;\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x;\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLStruct(name, vars) {\n    return `\nstruct ${name} {\n${vars}\n};`;\n  }\n  _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {\n    const structName = name + 'Struct';\n    const structSnippet = this._getWGSLStruct(structName, vars);\n    return `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n  }\n}\nexport default WGSLNodeBuilder;","map":{"version":3,"names":["NoColorSpace","FloatType","UniformsGroup","NodeSampler","NodeSampledTexture","NodeSampledCubeTexture","UniformBuffer","StorageBuffer","getVectorLength","getStrideLength","NodeBuilder","CodeNode","NodeMaterial","getFormat","WGSLNodeParser","gpuShaderStageLib","GPUShaderStage","VERTEX","FRAGMENT","COMPUTE","supports","instance","wgslTypeLib","float","int","uint","bool","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","wgslMethods","dFdx","dFdy","mod","lessThanEqual","inversesqrt","wgslPolyfill","repeatWrapping","WGSLNodeBuilder","constructor","object","renderer","scene","uniformsGroup","builtins","vertex","Map","fragment","compute","attribute","build","material","fromMaterial","addFlow","needsColorSpaceToLinear","texture","isVideoTexture","colorSpace","_getSampler","textureProperty","uvSnippet","shaderStage","getTextureLoad","_getVideoSampler","console","error","_getSamplerLevel","biasSnippet","isUnfilterable","_include","dimension","isDataTexture","type","getTexture","snippet","getTextureCompare","compareSnippet","getTextureLevel","getPropertyName","node","isNodeVarying","needsInterpolation","name","isNodeUniform","id","getUniformFromNode","uniformNode","nodeData","getDataFromNode","uniformGPU","undefined","bindings","store","isStoreTextureNode","setVisibility","lastBinding","length","index","isUniformsGroup","value","sampler","splice","bufferClass","buffer","push","isArrayUniformNode","nodes","uniformNodeGPU","getNodeUniform","boundary","itemSize","addUniform","bindingsOffset","isReference","getBuiltin","property","map","has","set","getVertexIndex","getInstanceIndex","getFrontFacing","getFragCoord","isFlipY","getAttributes","snippets","values","attributes","getAttributesArray","getType","join","getStructMembers","struct","members","getMemberTypes","i","member","getStructs","structs","getVar","getVars","vars","variable","getVaryings","varyings","varying","attributesSnippet","includes","code","_getWGSLStruct","getUniforms","uniforms","bindingSnippets","bufferSnippets","groupSnippets","uniform","isDepthTexture","compareFunction","textureType","isCubeTexture","format","bufferNode","bufferType","bufferCount","bufferCountSnippet","bufferSnippet","bufferAccessMode","isStorageBufferNode","_getWGSLStructBinding","vectorType","getVectorType","Array","isArray","buildCode","shadersData","flow","flowCode","flowNodes","mainNode","flowSlotData","getFlowData","slotName","result","outputNode","stageData","codes","getCodes","returnType","isOutputStructNode","nodeType","vertexShader","_getWGSLVertexCode","fragmentShader","_getWGSLFragmentCode","computeShader","_getWGSLComputeCode","workgroupSize","getMethod","method","isAvailable","shaderData","getSignature","access","binding","group","structName","structSnippet"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeBuilder.js"],"sourcesContent":["import { NoColorSpace, FloatType } from 'three';\n\nimport UniformsGroup from '../../common/UniformsGroup.js';\n\nimport NodeSampler from '../../common/nodes/NodeSampler.js';\nimport { NodeSampledTexture, NodeSampledCubeTexture } from '../../common/nodes/NodeSampledTexture.js';\n\nimport UniformBuffer from '../../common/UniformBuffer.js';\nimport StorageBuffer from '../../common/StorageBuffer.js';\nimport { getVectorLength, getStrideLength } from '../../common/BufferUtils.js';\n\nimport { NodeBuilder, CodeNode, NodeMaterial } from '../../../nodes/Nodes.js';\n\nimport { getFormat } from '../utils/WebGPUTextureUtils.js';\n\nimport WGSLNodeParser from './WGSLNodeParser.js';\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage.VERTEX,\n\t'fragment': GPUShaderStage.FRAGMENT,\n\t'compute': GPUShaderStage.COMPUTE\n};\n\nconst supports = {\n\tinstance: true\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat3: 'mat3x3<f32>',\n\timat3: 'mat3x3<i32>',\n\tumat3: 'mat3x3<u32>',\n\tbmat3: 'mat3x3<bool>',\n\n\tmat4: 'mat4x4<f32>',\n\timat4: 'mat4x4<i32>',\n\tumat4: 'mat4x4<u32>',\n\tbmat4: 'mat4x4<bool>'\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod: 'threejs_mod',\n\tlessThanEqual: 'threejs_lessThanEqual',\n\tinversesqrt: 'inverseSqrt'\n};\n\nconst wgslPolyfill = {\n\tlessThanEqual: new CodeNode( `\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\n\n}\n` ),\n\tmod: new CodeNode( `\nfn threejs_mod( x : f32, y : f32 ) -> f32 {\n\n\treturn x - y * floor( x / y );\n\n}\n` ),\n\trepeatWrapping: new CodeNode( `\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n` )\n};\n\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer, scene = null ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser(), scene );\n\n\t\tthis.uniformsGroup = {};\n\n\t\tthis.builtins = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map(),\n\t\t\tattribute: new Map()\n\t\t};\n\n\t}\n\n\tbuild() {\n\n\t\tconst { object, material } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tNodeMaterial.fromMaterial( material ).build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\treturn super.build();\n\n\t}\n\n\tneedsColorSpaceToLinear( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t_getSampler( texture, textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;\n\n\t\t} else {\n\n\t\t\treturn this.getTextureLoad( texture, textureProperty, uvSnippet );\n\n\t\t}\n\n\t}\n\n\t_getVideoSampler( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t_getSamplerLevel( texture, textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\n\n\t\t} else {\n\n\t\t\treturn this.getTextureLoad( texture, textureProperty, uvSnippet, biasSnippet );\n\n\t\t}\n\n\t}\n\n\tgetTextureLoad( texture, textureProperty, uvSnippet, biasSnippet = '0' ) {\n\n\t\tthis._include( 'repeatWrapping' );\n\n\t\tconst dimension = `textureDimensions( ${textureProperty}, 0 )`;\n\n\t\treturn `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${biasSnippet} ) )`;\n\n\t}\n\n\tisUnfilterable( texture ) {\n\n\t\treturn texture.isDataTexture === true && texture.type === FloatType;\n\n\t}\n\n\tgetTexture( texture, textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._getVideoSampler( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else if ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.getTextureLoad( texture, textureProperty, uvSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = this._getSampler( texture, textureProperty, uvSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetTextureLevel( texture, textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._getVideoSampler( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._getSamplerLevel( texture, textureProperty, uvSnippet, biasSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `NodeVaryings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' ) {\n\n\t\t\t\treturn `NodeBuffer_${node.node.id}.${name}`;\n\n\t\t\t} else {\n\n\t\t\t\treturn `NodeUniforms.${name}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst bindings = this.bindings[ shaderStage ];\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node );\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStoreTextureNode === true;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t// add first textures in sequence and group for last\n\t\t\t\tconst lastBinding = bindings[ bindings.length - 1 ];\n\t\t\t\tconst index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\n\n\t\t\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.splice( index, 0, sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.splice( index, 0, texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'storageBuffer' ? StorageBuffer : UniformBuffer;\n\t\t\t\tconst buffer = new bufferClass( 'NodeBuffer_' + node.id, node.value );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t// add first textures in sequence and group for last\n\t\t\t\tconst lastBinding = bindings[ bindings.length - 1 ];\n\t\t\t\tconst index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\n\n\t\t\t\tbindings.splice( index, 0, buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tlet uniformsGroup = this.uniformsGroup[ shaderStage ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new UniformsGroup( 'nodeUniforms' );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tthis.uniformsGroup[ shaderStage ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.isArrayUniformNode === true ) {\n\n\t\t\t\t\tuniformGPU = [];\n\n\t\t\t\t\tfor ( const uniformNode of node.nodes ) {\n\n\t\t\t\t\t\tconst uniformNodeGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\t\t\t// fit bounds to buffer\n\t\t\t\t\t\tuniformNodeGPU.boundary = getVectorLength( uniformNodeGPU.itemSize );\n\t\t\t\t\t\tuniformNodeGPU.itemSize = getStrideLength( uniformNodeGPU.itemSize );\n\n\t\t\t\t\t\tuniformsGroup.addUniform( uniformNodeGPU );\n\n\t\t\t\t\t\tuniformGPU.push( uniformNodeGPU );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\tthis.bindingsOffset[ 'fragment' ] = bindings.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn super.isReference( type ) || type === 'texture_2d' || type === 'texture_cube' || type === 'texture_storage_2d';\n\n\t}\n\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ];\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>', 'fragment' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const { name, property, type } of this.builtins.attribute.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `\\t@location( ${i} ) m${i} : ${ member }<f32>` );\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\t\t\tconst name = struct.name;\n\n\t\t\tlet snippet = `\\struct ${ name } {\\n`;\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n}';\n\n\t\t\tsnippets.push( snippet );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `var ${ name } : ${ this.getType( type ) }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( const variable of vars ) {\n\n\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( varying.type === 'int' || varying.type === 'uint' ) {\n\n\t\t\t\t\t\tattributesSnippet += ' @interpolate( flat )';\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const { name, property, type } of this.builtins[ shaderStage ].values() ) {\n\n\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t}\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'NodeVaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst groupSnippets = [];\n\n\t\tlet index = this.bindingsOffset[ shaderStage ];\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false && uniform.node.isStoreTextureNode !== true ) {\n\n\t\t\t\t\tif ( texture.isDepthTexture === true && texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${index ++} ) @group( 0 ) var ${uniform.name}_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${index ++} ) @group( 0 ) var ${uniform.name}_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_depth_2d';\n\n\t\t\t\t} else if ( texture.isVideoTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_external';\n\n\t\t\t\t} else if ( uniform.node.isStoreTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\n\t\t\t\t\ttextureType = 'texture_storage_2d<' + format + ', write>';\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureType = 'texture_2d<f32>';\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${index ++} ) @group( 0 ) var ${uniform.name} : ${textureType};` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferSnippet = `\\t${uniform.name} : array< ${bufferType}${bufferCountSnippet} >\\n`;\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? 'storage,read_write' : 'uniform';\n\n\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, index ++ ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\n\t\t\t\tif ( Array.isArray( uniform.value ) === true ) {\n\n\t\t\t\t\tconst length = uniform.value.length;\n\n\t\t\t\t\tgroupSnippets.push( `uniform ${vectorType}[ ${length} ] ${uniform.name}` );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgroupSnippets.push( `\\t${uniform.name} : ${ vectorType}` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\n\t\tif ( groupSnippets.length > 0 ) {\n\n\t\t\tcode += this._getWGSLStructBinding( 'NodeUniforms', groupSnippets.join( ',\\n' ), 'uniform', index ++ );\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'NodeVaryings.Vertex = ';\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tflow += 'return ';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.returnType = ( outputNode !== undefined && outputNode.isOutputStructNode === true ) ? outputNode.nodeType : '@location( 0 ) vec4<f32>';\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ] || method;\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\tisAvailable( name ) {\n\n\t\treturn supports[ name ] === true;\n\n\t}\n\n\t_include( name ) {\n\n\t\twgslPolyfill[ name ].build( this );\n\n\t}\n\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> NodeVaryingsStruct {\n\n\t// system\n\tvar NodeVaryings: NodeVaryingsStruct;\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn NodeVaryings;\n\n}\n`;\n\n\t}\n\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\treturn `${ this.getSignature() }\n// system\nvar<private> instanceIndex : u32;\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x;\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n\n\t}\n\n}\n\nexport default WGSLNodeBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}