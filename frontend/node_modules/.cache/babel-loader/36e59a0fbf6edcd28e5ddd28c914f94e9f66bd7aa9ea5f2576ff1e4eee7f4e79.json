{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { GPUTextureFormat, GPUAddressMode, GPUFilterMode, GPUTextureDimension, GPUFeatureName } from './WebGPUConstants.js';\nimport { CubeTexture, Texture, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, RepeatWrapping, MirroredRepeatWrapping, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBAFormat, RedFormat, RGFormat, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, UnsignedByteType, FloatType, HalfFloatType, SRGBColorSpace, DepthFormat, DepthStencilFormat, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, UnsignedIntType, UnsignedShortType, UnsignedInt248Type, NeverCompare, AlwaysCompare, LessCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare } from 'three';\nimport { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from 'three';\nimport WebGPUTexturePassUtils from './WebGPUTexturePassUtils.js';\nconst _compareToWebGPU = {\n  [NeverCompare]: 'never',\n  [LessCompare]: 'less',\n  [EqualCompare]: 'equal',\n  [LessEqualCompare]: 'less-equal',\n  [GreaterCompare]: 'greater',\n  [GreaterEqualCompare]: 'greater-equal',\n  [AlwaysCompare]: 'always',\n  [NotEqualCompare]: 'not-equal'\n};\nconst _flipMap = [0, 1, 3, 2, 4, 5];\nclass WebGPUTextureUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this._passUtils = null;\n    this.defaultTexture = null;\n    this.defaultCubeTexture = null;\n  }\n  createSampler(texture) {\n    const backend = this.backend;\n    const device = backend.device;\n    const textureGPU = backend.get(texture);\n    const samplerDescriptorGPU = {\n      addressModeU: this._convertAddressMode(texture.wrapS),\n      addressModeV: this._convertAddressMode(texture.wrapT),\n      addressModeW: this._convertAddressMode(texture.wrapR),\n      magFilter: this._convertFilterMode(texture.magFilter),\n      minFilter: this._convertFilterMode(texture.minFilter),\n      mipmapFilter: this._convertFilterMode(texture.minFilter),\n      maxAnisotropy: texture.anisotropy\n    };\n    if (texture.isDepthTexture && texture.compareFunction !== null) {\n      samplerDescriptorGPU.compare = _compareToWebGPU[texture.compareFunction];\n    }\n    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);\n  }\n  createDefaultTexture(texture) {\n    let textureGPU;\n    if (texture.isCubeTexture) {\n      textureGPU = this._getDefaultCubeTextureGPU();\n    } else {\n      textureGPU = this._getDefaultTextureGPU();\n    }\n    this.backend.get(texture).texture = textureGPU;\n  }\n  createTexture(texture, options = {}) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    if (textureData.initialized) {\n      throw new Error('WebGPUTextureUtils: Texture already initialized.');\n    }\n    if (options.needsMipmaps === undefined) options.needsMipmaps = false;\n    if (options.levels === undefined) options.levels = 1;\n    if (options.depth === undefined) options.depth = 1;\n    const {\n      width,\n      height,\n      depth,\n      levels\n    } = options;\n    const dimension = this._getDimension(texture);\n    const format = texture.internalFormat || getFormat(texture, this.device);\n    const sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;\n    const primarySampleCount = texture.isRenderTargetTexture ? 1 : sampleCount;\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n    if (texture.isStorageTexture === true) {\n      usage |= GPUTextureUsage.STORAGE_BINDING;\n    }\n    if (texture.isCompressedTexture !== true) {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    }\n    const textureDescriptorGPU = {\n      label: texture.name,\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: depth\n      },\n      mipLevelCount: levels,\n      sampleCount: primarySampleCount,\n      dimension: dimension,\n      format: format,\n      usage: usage\n    };\n\n    // texture creation\n\n    if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      const videoFrame = new VideoFrame(video);\n      textureDescriptorGPU.size.width = videoFrame.displayWidth;\n      textureDescriptorGPU.size.height = videoFrame.displayHeight;\n      videoFrame.close();\n      textureData.externalTexture = video;\n    } else {\n      if (format === undefined) {\n        console.warn('WebGPURenderer: Texture format not supported.');\n        return this.createDefaultTexture(texture);\n      }\n      textureData.texture = backend.device.createTexture(textureDescriptorGPU);\n    }\n    if (texture.isRenderTargetTexture && sampleCount > 1) {\n      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);\n      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n      msaaTextureDescriptorGPU.sampleCount = sampleCount;\n      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);\n    }\n    textureData.initialized = true;\n    textureData.textureDescriptorGPU = textureDescriptorGPU;\n  }\n  destroyTexture(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    textureData.texture.destroy();\n    if (textureData.msaaTexture !== undefined) textureData.msaaTexture.destroy();\n    backend.delete(texture);\n  }\n  destroySampler(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    delete textureData.sampler;\n  }\n  generateMipmaps(texture) {\n    const textureData = this.backend.get(texture);\n    if (texture.isCubeTexture) {\n      for (let i = 0; i < 6; i++) {\n        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);\n      }\n    } else {\n      this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU);\n    }\n  }\n  updateTexture(texture, options) {\n    const textureData = this.backend.get(texture);\n    const {\n      textureDescriptorGPU\n    } = textureData;\n    if (texture.isRenderTargetTexture || textureDescriptorGPU === undefined /* unsupported texture format */) return;\n\n    // transfer texture data\n\n    if (texture.isDataTexture || texture.isDataArrayTexture || texture.isData3DTexture) {\n      this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, false);\n    } else if (texture.isCompressedTexture) {\n      this._copyCompressedBufferToTexture(texture.mipmaps, textureData.texture, textureDescriptorGPU);\n    } else if (texture.isCubeTexture) {\n      this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture.flipY);\n    } else if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      textureData.externalTexture = video;\n    } else {\n      this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);\n    }\n\n    //\n\n    textureData.version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n  async copyTextureToBuffer(texture, x, y, width, height) {\n    const device = this.backend.device;\n    const textureData = this.backend.get(texture);\n    const textureGPU = textureData.texture;\n    const format = textureData.textureDescriptorGPU.format;\n    const bytesPerTexel = this._getBytesPerTexel(format);\n    const readBuffer = device.createBuffer({\n      size: width * height * bytesPerTexel,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToBuffer({\n      texture: textureGPU,\n      origin: {\n        x,\n        y\n      }\n    }, {\n      buffer: readBuffer,\n      bytesPerRow: width * bytesPerTexel\n    }, {\n      width: width,\n      height: height\n    });\n    const typedArrayType = this._getTypedArrayType(format);\n    device.queue.submit([encoder.finish()]);\n    await readBuffer.mapAsync(GPUMapMode.READ);\n    const buffer = readBuffer.getMappedRange();\n    return new typedArrayType(buffer);\n  }\n  _isEnvironmentTexture(texture) {\n    const mapping = texture.mapping;\n    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n  }\n  _getDefaultTextureGPU() {\n    let defaultTexture = this.defaultTexture;\n    if (defaultTexture === null) {\n      const texture = new Texture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1\n      });\n      this.defaultTexture = defaultTexture = texture;\n    }\n    return this.backend.get(defaultTexture).texture;\n  }\n  _getDefaultCubeTextureGPU() {\n    let defaultCubeTexture = this.defaultTexture;\n    if (defaultCubeTexture === null) {\n      const texture = new CubeTexture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1,\n        depth: 6\n      });\n      this.defaultCubeTexture = defaultCubeTexture = texture;\n    }\n    return this.backend.get(defaultCubeTexture).texture;\n  }\n  _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) {\n    for (let i = 0; i < 6; i++) {\n      const image = images[i];\n      const flipIndex = flipY === true ? _flipMap[i] : i;\n      if (image.isDataTexture) {\n        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      } else {\n        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      }\n    }\n  }\n  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {\n    const device = this.backend.device;\n    device.queue.copyExternalImageToTexture({\n      source: image\n    }, {\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _getPassUtils() {\n    let passUtils = this._passUtils;\n    if (passUtils === null) {\n      this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);\n    }\n    return passUtils;\n  }\n  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {\n    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);\n  }\n  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {\n    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);\n  }\n  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n    // @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n    const device = this.backend.device;\n    const data = image.data;\n    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);\n    const bytesPerRow = image.width * bytesPerTexel;\n    device.queue.writeTexture({\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, data, {\n      offset: 0,\n      bytesPerRow\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: image.depth !== undefined ? image.depth : 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n    const device = this.backend.device;\n    const blockData = this._getBlockData(textureDescriptorGPU.format);\n    for (let i = 0; i < mipmaps.length; i++) {\n      const mipmap = mipmaps[i];\n      const width = mipmap.width;\n      const height = mipmap.height;\n      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;\n      device.queue.writeTexture({\n        texture: textureGPU,\n        mipLevel: i\n      }, mipmap.data, {\n        offset: 0,\n        bytesPerRow\n      }, {\n        width: Math.ceil(width / blockData.width) * blockData.width,\n        height: Math.ceil(height / blockData.width) * blockData.width,\n        depthOrArrayLayers: 1\n      });\n    }\n  }\n  _getBlockData(format) {\n    // this method is only relevant for compressed texture formats\n\n    if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // DXT1\n    if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT3\n    if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT5\n    if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // RGTC1\n    if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // RGTC2\n    if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (float)\n    if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (unorm)\n\n    if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Unorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Snorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Unorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Snorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 12\n    };\n  }\n  _convertAddressMode(value) {\n    let addressMode = GPUAddressMode.ClampToEdge;\n    if (value === RepeatWrapping) {\n      addressMode = GPUAddressMode.Repeat;\n    } else if (value === MirroredRepeatWrapping) {\n      addressMode = GPUAddressMode.MirrorRepeat;\n    }\n    return addressMode;\n  }\n  _convertFilterMode(value) {\n    let filterMode = GPUFilterMode.Linear;\n    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {\n      filterMode = GPUFilterMode.Nearest;\n    }\n    return filterMode;\n  }\n  _getBytesPerTexel(format) {\n    if (format === GPUTextureFormat.R8Unorm) return 1;\n    if (format === GPUTextureFormat.R16Float) return 2;\n    if (format === GPUTextureFormat.RG8Unorm) return 2;\n    if (format === GPUTextureFormat.RG16Float) return 4;\n    if (format === GPUTextureFormat.R32Float) return 4;\n    if (format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB) return 4;\n    if (format === GPUTextureFormat.RG32Float) return 8;\n    if (format === GPUTextureFormat.RGBA16Float) return 8;\n    if (format === GPUTextureFormat.RGBA32Float) return 16;\n  }\n  _getTypedArrayType(format) {\n    if (format === GPUTextureFormat.R8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.R8Sint) return Int8Array;\n    if (format === GPUTextureFormat.R8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.R8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RG8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.R16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.R16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RG16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RG16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;\n    if (format === GPUTextureFormat.R32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.R32Sint) return Int32Array;\n    if (format === GPUTextureFormat.R32Float) return Float32Array;\n    if (format === GPUTextureFormat.RG32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RG32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RG32Float) return Float32Array;\n    if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RGBA32Float) return Float32Array;\n  }\n  _getDimension(texture) {\n    let dimension;\n    if (texture.isData3DTexture) {\n      dimension = GPUTextureDimension.ThreeD;\n    } else {\n      dimension = GPUTextureDimension.TwoD;\n    }\n    return dimension;\n  }\n}\nexport function getFormat(texture, device = null) {\n  const format = texture.format;\n  const type = texture.type;\n  const colorSpace = texture.colorSpace;\n  let formatGPU;\n  if ( /*texture.isRenderTargetTexture === true ||*/texture.isFramebufferTexture === true) {\n    formatGPU = GPUTextureFormat.BGRA8Unorm;\n  } else if (texture.isCompressedTexture === true) {\n    switch (format) {\n      case RGBA_S3TC_DXT1_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT3_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n        break;\n      case RGB_ETC2_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n        break;\n      case RGBA_ETC2_EAC_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n        break;\n      case RGBA_ASTC_4x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n        break;\n      case RGBA_ASTC_5x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n        break;\n      case RGBA_ASTC_5x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n        break;\n      case RGBA_ASTC_6x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n        break;\n      case RGBA_ASTC_6x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n        break;\n      case RGBA_ASTC_8x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n        break;\n      case RGBA_ASTC_8x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n        break;\n      case RGBA_ASTC_8x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n        break;\n      case RGBA_ASTC_10x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n        break;\n      case RGBA_ASTC_10x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n        break;\n      case RGBA_ASTC_10x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n        break;\n      case RGBA_ASTC_10x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n        break;\n      case RGBA_ASTC_12x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n        break;\n      case RGBA_ASTC_12x12_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  } else {\n    switch (format) {\n      case RGBAFormat:\n        switch (type) {\n          case UnsignedByteType:\n            formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RGBA16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RGBA32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBAFormat.', type);\n        }\n        break;\n      case RedFormat:\n        switch (type) {\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.R8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.R16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.R32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RedFormat.', type);\n        }\n        break;\n      case RGFormat:\n        switch (type) {\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.RG8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RG16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RG32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGFormat.', type);\n        }\n        break;\n      case DepthFormat:\n        switch (type) {\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.Depth16Unorm;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.Depth24Plus;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.Depth32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthFormat.', type);\n        }\n        break;\n      case DepthStencilFormat:\n        switch (type) {\n          case UnsignedInt248Type:\n            formatGPU = GPUTextureFormat.Depth24PlusStencil8;\n            break;\n          case FloatType:\n            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {\n              console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.');\n            }\n            formatGPU = GPUTextureFormat.Depth32FloatStencil8;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type);\n        }\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  }\n  return formatGPU;\n}\nexport default WebGPUTextureUtils;","map":{"version":3,"names":["GPUTextureFormat","GPUAddressMode","GPUFilterMode","GPUTextureDimension","GPUFeatureName","CubeTexture","Texture","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","RepeatWrapping","MirroredRepeatWrapping","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","RGBAFormat","RedFormat","RGFormat","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","UnsignedByteType","FloatType","HalfFloatType","SRGBColorSpace","DepthFormat","DepthStencilFormat","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","UnsignedIntType","UnsignedShortType","UnsignedInt248Type","NeverCompare","AlwaysCompare","LessCompare","LessEqualCompare","EqualCompare","GreaterEqualCompare","GreaterCompare","NotEqualCompare","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","WebGPUTexturePassUtils","_compareToWebGPU","_flipMap","WebGPUTextureUtils","constructor","backend","_passUtils","defaultTexture","defaultCubeTexture","createSampler","texture","device","textureGPU","get","samplerDescriptorGPU","addressModeU","_convertAddressMode","wrapS","addressModeV","wrapT","addressModeW","wrapR","magFilter","_convertFilterMode","minFilter","mipmapFilter","maxAnisotropy","anisotropy","isDepthTexture","compareFunction","compare","sampler","createDefaultTexture","isCubeTexture","_getDefaultCubeTextureGPU","_getDefaultTextureGPU","createTexture","options","textureData","initialized","Error","needsMipmaps","undefined","levels","depth","width","height","dimension","_getDimension","format","internalFormat","getFormat","sampleCount","primarySampleCount","isRenderTargetTexture","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","COPY_SRC","isStorageTexture","STORAGE_BINDING","isCompressedTexture","RENDER_ATTACHMENT","textureDescriptorGPU","label","name","size","depthOrArrayLayers","mipLevelCount","isVideoTexture","video","source","data","videoFrame","VideoFrame","displayWidth","displayHeight","close","externalTexture","console","warn","msaaTextureDescriptorGPU","Object","assign","msaaTexture","destroyTexture","destroy","delete","destroySampler","generateMipmaps","i","_generateMipmaps","updateTexture","isDataTexture","isDataArrayTexture","isData3DTexture","_copyBufferToTexture","image","_copyCompressedBufferToTexture","mipmaps","_copyCubeMapToTexture","images","flipY","_copyImageToTexture","version","onUpdate","copyTextureToBuffer","x","y","bytesPerTexel","_getBytesPerTexel","readBuffer","createBuffer","GPUBufferUsage","MAP_READ","encoder","createCommandEncoder","origin","buffer","bytesPerRow","typedArrayType","_getTypedArrayType","queue","submit","finish","mapAsync","GPUMapMode","READ","getMappedRange","_isEnvironmentTexture","mapping","flipIndex","originDepth","copyExternalImageToTexture","mipLevel","z","_flipY","_getPassUtils","passUtils","baseArrayLayer","writeTexture","offset","blockData","_getBlockData","length","mipmap","Math","ceil","byteLength","BC1RGBAUnorm","BC1RGBAUnormSRGB","BC2RGBAUnorm","BC2RGBAUnormSRGB","BC3RGBAUnorm","BC3RGBAUnormSRGB","BC4RUnorm","BC4RSNorm","BC5RGUnorm","BC5RGSnorm","BC6HRGBUFloat","BC6HRGBFloat","BC7RGBAUnorm","BC7RGBAUnormSRGB","ETC2RGB8Unorm","ETC2RGB8UnormSRGB","ETC2RGB8A1Unorm","ETC2RGB8A1UnormSRGB","ETC2RGBA8Unorm","ETC2RGBA8UnormSRGB","EACR11Unorm","EACR11Snorm","EACRG11Unorm","EACRG11Snorm","ASTC4x4Unorm","ASTC4x4UnormSRGB","ASTC5x4Unorm","ASTC5x4UnormSRGB","ASTC5x5Unorm","ASTC5x5UnormSRGB","ASTC6x5Unorm","ASTC6x5UnormSRGB","ASTC6x6Unorm","ASTC6x6UnormSRGB","ASTC8x5Unorm","ASTC8x5UnormSRGB","ASTC8x6Unorm","ASTC8x6UnormSRGB","ASTC8x8Unorm","ASTC8x8UnormSRGB","ASTC10x5Unorm","ASTC10x5UnormSRGB","ASTC10x6Unorm","ASTC10x6UnormSRGB","ASTC10x8Unorm","ASTC10x8UnormSRGB","ASTC10x10Unorm","ASTC10x10UnormSRGB","ASTC12x10Unorm","ASTC12x10UnormSRGB","ASTC12x12Unorm","ASTC12x12UnormSRGB","value","addressMode","ClampToEdge","Repeat","MirrorRepeat","filterMode","Linear","Nearest","R8Unorm","R16Float","RG8Unorm","RG16Float","R32Float","RGBA8Unorm","RGBA8UnormSRGB","RG32Float","RGBA16Float","RGBA32Float","R8Uint","Uint8Array","R8Sint","Int8Array","R8Snorm","RG8Uint","RG8Sint","RG8Snorm","RGBA8Uint","RGBA8Sint","RGBA8Snorm","R16Uint","Uint16Array","R16Sint","Int16Array","RG16Uint","RG16Sint","RGBA16Uint","RGBA16Sint","R32Uint","Uint32Array","R32Sint","Int32Array","Float32Array","RG32Uint","RG32Sint","RGBA32Uint","RGBA32Sint","ThreeD","TwoD","type","colorSpace","formatGPU","isFramebufferTexture","BGRA8Unorm","error","Depth16Unorm","Depth24Plus","Depth32Float","Depth24PlusStencil8","features","has","Depth32FloatStencil8"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUTextureUtils.js"],"sourcesContent":["import {\n\tGPUTextureFormat, GPUAddressMode, GPUFilterMode, GPUTextureDimension, GPUFeatureName\n} from './WebGPUConstants.js';\n\nimport {\n\tCubeTexture, Texture,\n\tNearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter,\n\tRepeatWrapping, MirroredRepeatWrapping,\n\tRGB_ETC2_Format, RGBA_ETC2_EAC_Format,\n\tRGBAFormat, RedFormat, RGFormat, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, UnsignedByteType, FloatType, HalfFloatType, SRGBColorSpace, DepthFormat, DepthStencilFormat,\n\tRGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format,\n\tRGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, UnsignedIntType, UnsignedShortType, UnsignedInt248Type,\n\tNeverCompare, AlwaysCompare, LessCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare\n} from 'three';\n\nimport { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from 'three';\n\nimport WebGPUTexturePassUtils from './WebGPUTexturePassUtils.js';\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\nclass WebGPUTextureUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis._passUtils = null;\n\n\t\tthis.defaultTexture = null;\n\t\tthis.defaultCubeTexture = null;\n\n\t}\n\n\tcreateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst textureGPU = backend.get( texture );\n\n\t\tconst samplerDescriptorGPU = {\n\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmaxAnisotropy: texture.anisotropy\n\t\t};\n\n\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t}\n\n\t\ttextureGPU.sampler = device.createSampler( samplerDescriptorGPU );\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU();\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU();\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || getFormat( texture, this.device );\n\n\t\tconst sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;\n\t\tconst primarySampleCount = texture.isRenderTargetTexture ? 1 : sampleCount;\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySampleCount,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\t\t\tconst videoFrame = new VideoFrame( video );\n\n\t\t\ttextureDescriptorGPU.size.width = videoFrame.displayWidth;\n\t\t\ttextureDescriptorGPU.size.height = videoFrame.displayHeight;\n\n\t\t\tvideoFrame.close();\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tif ( format === undefined ) {\n\n\t\t\t\tconsole.warn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\t\treturn this.createDefaultTexture( texture );\n\n\t\t\t}\n\n\t\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\t}\n\n\t\tif ( texture.isRenderTargetTexture && sampleCount > 1 ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = sampleCount;\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\ttextureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\tdestroySampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tdelete textureData.sampler;\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU );\n\n\t\t}\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, false );\n\n\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\tasync copyTextureToBuffer( texture, x, y, width, height ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: width * height * bytesPerTexel,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: width * bytesPerTexel\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t_isEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t_getDefaultTextureGPU() {\n\n\t\tlet defaultTexture = this.defaultTexture;\n\n\t\tif ( defaultTexture === null ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1 } );\n\n\t\t\tthis.defaultTexture = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t_getDefaultCubeTextureGPU() {\n\n\t\tlet defaultCubeTexture = this.defaultTexture;\n\n\t\tif ( defaultCubeTexture === null ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t}, {\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );\n\n\t}\n\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: 0,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: ( image.depth !== undefined ) ? image.depth : 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\n\t\t\tdevice.queue.writeTexture(\n\t\t\t\t{\n\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\tmipLevel: i\n\t\t\t\t},\n\t\t\t\tmipmap.data,\n\t\t\t\t{\n\t\t\t\t\toffset: 0,\n\t\t\t\t\tbytesPerRow\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\theight: Math.ceil( height / blockData.width ) * blockData.width,\n\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t_getBlockData( format ) {\n\n\t\t// this method is only relevant for compressed texture formats\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t_getBytesPerTexel( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return 1;\n\t\tif ( format === GPUTextureFormat.R16Float ) return 2;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return 2;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return 4;\n\t\tif ( format === GPUTextureFormat.R32Float ) return 4;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB ) return 4;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return 8;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return 8;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return 16;\n\n\t}\n\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t}\n\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\nexport function getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\n\tlet formatGPU;\n\n\tif ( /*texture.isRenderTargetTexture === true ||*/ texture.isFramebufferTexture === true ) {\n\n\t\tformatGPU = GPUTextureFormat.BGRA8Unorm;\n\n\t} else if ( texture.isCompressedTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nexport default WebGPUTextureUtils;\n"],"mappings":";;;AAAA,SACCA,gBAAgB,EAAEC,cAAc,EAAEC,aAAa,EAAEC,mBAAmB,EAAEC,cAAc,QAC9E,sBAAsB;AAE7B,SACCC,WAAW,EAAEC,OAAO,EACpBC,aAAa,EAAEC,0BAA0B,EAAEC,yBAAyB,EACpEC,cAAc,EAAEC,sBAAsB,EACtCC,eAAe,EAAEC,oBAAoB,EACrCC,UAAU,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAEC,gBAAgB,EAAEC,SAAS,EAAEC,aAAa,EAAEC,cAAc,EAAEC,WAAW,EAAEC,kBAAkB,EACjMC,oBAAoB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,qBAAqB,EACrMC,qBAAqB,EAAEC,qBAAqB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,eAAe,EAAEC,iBAAiB,EAAEC,kBAAkB,EAC5KC,YAAY,EAAEC,aAAa,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,cAAc,EAAEC,eAAe,QACxH,OAAO;AAEd,SAASC,qBAAqB,EAAEC,qBAAqB,EAAEC,gCAAgC,EAAEC,gCAAgC,QAAQ,OAAO;AAExI,OAAOC,sBAAsB,MAAM,6BAA6B;AAEhE,MAAMC,gBAAgB,GAAG;EACxB,CAAEb,YAAY,GAAI,OAAO;EACzB,CAAEE,WAAW,GAAI,MAAM;EACvB,CAAEE,YAAY,GAAI,OAAO;EACzB,CAAED,gBAAgB,GAAI,YAAY;EAClC,CAAEG,cAAc,GAAI,SAAS;EAC7B,CAAED,mBAAmB,GAAI,eAAe;EACxC,CAAEJ,aAAa,GAAI,QAAQ;EAC3B,CAAEM,eAAe,GAAI;AACtB,CAAC;AAED,MAAMO,QAAQ,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;AAErC,MAAMC,kBAAkB,CAAC;EAExBC,WAAWA,CAAEC,OAAO,EAAG;IAEtB,IAAI,CAACA,OAAO,GAAGA,OAAO;IAEtB,IAAI,CAACC,UAAU,GAAG,IAAI;IAEtB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,kBAAkB,GAAG,IAAI;EAE/B;EAEAC,aAAaA,CAAEC,OAAO,EAAG;IAExB,MAAML,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMM,MAAM,GAAGN,OAAO,CAACM,MAAM;IAE7B,MAAMC,UAAU,GAAGP,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC;IAEzC,MAAMI,oBAAoB,GAAG;MAC5BC,YAAY,EAAE,IAAI,CAACC,mBAAmB,CAAEN,OAAO,CAACO,KAAM,CAAC;MACvDC,YAAY,EAAE,IAAI,CAACF,mBAAmB,CAAEN,OAAO,CAACS,KAAM,CAAC;MACvDC,YAAY,EAAE,IAAI,CAACJ,mBAAmB,CAAEN,OAAO,CAACW,KAAM,CAAC;MACvDC,SAAS,EAAE,IAAI,CAACC,kBAAkB,CAAEb,OAAO,CAACY,SAAU,CAAC;MACvDE,SAAS,EAAE,IAAI,CAACD,kBAAkB,CAAEb,OAAO,CAACc,SAAU,CAAC;MACvDC,YAAY,EAAE,IAAI,CAACF,kBAAkB,CAAEb,OAAO,CAACc,SAAU,CAAC;MAC1DE,aAAa,EAAEhB,OAAO,CAACiB;IACxB,CAAC;IAED,IAAKjB,OAAO,CAACkB,cAAc,IAAIlB,OAAO,CAACmB,eAAe,KAAK,IAAI,EAAG;MAEjEf,oBAAoB,CAACgB,OAAO,GAAG7B,gBAAgB,CAAES,OAAO,CAACmB,eAAe,CAAE;IAE3E;IAEAjB,UAAU,CAACmB,OAAO,GAAGpB,MAAM,CAACF,aAAa,CAAEK,oBAAqB,CAAC;EAElE;EAEAkB,oBAAoBA,CAAEtB,OAAO,EAAG;IAE/B,IAAIE,UAAU;IAEd,IAAKF,OAAO,CAACuB,aAAa,EAAG;MAE5BrB,UAAU,GAAG,IAAI,CAACsB,yBAAyB,CAAC,CAAC;IAE9C,CAAC,MAAM;MAENtB,UAAU,GAAG,IAAI,CAACuB,qBAAqB,CAAC,CAAC;IAE1C;IAEA,IAAI,CAAC9B,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC,CAACA,OAAO,GAAGE,UAAU;EAEjD;EAEAwB,aAAaA,CAAE1B,OAAO,EAAE2B,OAAO,GAAG,CAAC,CAAC,EAAG;IAEtC,MAAMhC,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMiC,WAAW,GAAGjC,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC;IAE1C,IAAK4B,WAAW,CAACC,WAAW,EAAG;MAE9B,MAAM,IAAIC,KAAK,CAAE,kDAAmD,CAAC;IAEtE;IAEA,IAAKH,OAAO,CAACI,YAAY,KAAKC,SAAS,EAAGL,OAAO,CAACI,YAAY,GAAG,KAAK;IACtE,IAAKJ,OAAO,CAACM,MAAM,KAAKD,SAAS,EAAGL,OAAO,CAACM,MAAM,GAAG,CAAC;IACtD,IAAKN,OAAO,CAACO,KAAK,KAAKF,SAAS,EAAGL,OAAO,CAACO,KAAK,GAAG,CAAC;IAEpD,MAAM;MAAEC,KAAK;MAAEC,MAAM;MAAEF,KAAK;MAAED;IAAO,CAAC,GAAGN,OAAO;IAEhD,MAAMU,SAAS,GAAG,IAAI,CAACC,aAAa,CAAEtC,OAAQ,CAAC;IAC/C,MAAMuC,MAAM,GAAGvC,OAAO,CAACwC,cAAc,IAAIC,SAAS,CAAEzC,OAAO,EAAE,IAAI,CAACC,MAAO,CAAC;IAE1E,MAAMyC,WAAW,GAAGf,OAAO,CAACe,WAAW,KAAKV,SAAS,GAAGL,OAAO,CAACe,WAAW,GAAG,CAAC;IAC/E,MAAMC,kBAAkB,GAAG3C,OAAO,CAAC4C,qBAAqB,GAAG,CAAC,GAAGF,WAAW;IAE1E,IAAIG,KAAK,GAAGC,eAAe,CAACC,eAAe,GAAGD,eAAe,CAACE,QAAQ,GAAGF,eAAe,CAACG,QAAQ;IAEjG,IAAKjD,OAAO,CAACkD,gBAAgB,KAAK,IAAI,EAAG;MAExCL,KAAK,IAAIC,eAAe,CAACK,eAAe;IAEzC;IAEA,IAAKnD,OAAO,CAACoD,mBAAmB,KAAK,IAAI,EAAG;MAE3CP,KAAK,IAAIC,eAAe,CAACO,iBAAiB;IAE3C;IAEA,MAAMC,oBAAoB,GAAG;MAC5BC,KAAK,EAAEvD,OAAO,CAACwD,IAAI;MACnBC,IAAI,EAAE;QACLtB,KAAK,EAAEA,KAAK;QACZC,MAAM,EAAEA,MAAM;QACdsB,kBAAkB,EAAExB;MACrB,CAAC;MACDyB,aAAa,EAAE1B,MAAM;MACrBS,WAAW,EAAEC,kBAAkB;MAC/BN,SAAS,EAAEA,SAAS;MACpBE,MAAM,EAAEA,MAAM;MACdM,KAAK,EAAEA;IACR,CAAC;;IAED;;IAEA,IAAK7C,OAAO,CAAC4D,cAAc,EAAG;MAE7B,MAAMC,KAAK,GAAG7D,OAAO,CAAC8D,MAAM,CAACC,IAAI;MACjC,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAAEJ,KAAM,CAAC;MAE1CP,oBAAoB,CAACG,IAAI,CAACtB,KAAK,GAAG6B,UAAU,CAACE,YAAY;MACzDZ,oBAAoB,CAACG,IAAI,CAACrB,MAAM,GAAG4B,UAAU,CAACG,aAAa;MAE3DH,UAAU,CAACI,KAAK,CAAC,CAAC;MAElBxC,WAAW,CAACyC,eAAe,GAAGR,KAAK;IAEpC,CAAC,MAAM;MAEN,IAAKtB,MAAM,KAAKP,SAAS,EAAG;QAE3BsC,OAAO,CAACC,IAAI,CAAE,+CAAgD,CAAC;QAE/D,OAAO,IAAI,CAACjD,oBAAoB,CAAEtB,OAAQ,CAAC;MAE5C;MAEA4B,WAAW,CAAC5B,OAAO,GAAGL,OAAO,CAACM,MAAM,CAACyB,aAAa,CAAE4B,oBAAqB,CAAC;IAE3E;IAEA,IAAKtD,OAAO,CAAC4C,qBAAqB,IAAIF,WAAW,GAAG,CAAC,EAAG;MAEvD,MAAM8B,wBAAwB,GAAGC,MAAM,CAACC,MAAM,CAAE,CAAC,CAAC,EAAEpB,oBAAqB,CAAC;MAE1EkB,wBAAwB,CAACjB,KAAK,GAAGiB,wBAAwB,CAACjB,KAAK,GAAG,OAAO;MACzEiB,wBAAwB,CAAC9B,WAAW,GAAGA,WAAW;MAElDd,WAAW,CAAC+C,WAAW,GAAGhF,OAAO,CAACM,MAAM,CAACyB,aAAa,CAAE8C,wBAAyB,CAAC;IAEnF;IAEA5C,WAAW,CAACC,WAAW,GAAG,IAAI;IAE9BD,WAAW,CAAC0B,oBAAoB,GAAGA,oBAAoB;EAExD;EAEAsB,cAAcA,CAAE5E,OAAO,EAAG;IAEzB,MAAML,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMiC,WAAW,GAAGjC,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC;IAE1C4B,WAAW,CAAC5B,OAAO,CAAC6E,OAAO,CAAC,CAAC;IAE7B,IAAKjD,WAAW,CAAC+C,WAAW,KAAK3C,SAAS,EAAGJ,WAAW,CAAC+C,WAAW,CAACE,OAAO,CAAC,CAAC;IAE9ElF,OAAO,CAACmF,MAAM,CAAE9E,OAAQ,CAAC;EAE1B;EAEA+E,cAAcA,CAAE/E,OAAO,EAAG;IAEzB,MAAML,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMiC,WAAW,GAAGjC,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC;IAE1C,OAAO4B,WAAW,CAACP,OAAO;EAE3B;EAEA2D,eAAeA,CAAEhF,OAAO,EAAG;IAE1B,MAAM4B,WAAW,GAAG,IAAI,CAACjC,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC;IAE/C,IAAKA,OAAO,CAACuB,aAAa,EAAG;MAE5B,KAAM,IAAI0D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;QAE9B,IAAI,CAACC,gBAAgB,CAAEtD,WAAW,CAAC5B,OAAO,EAAE4B,WAAW,CAAC0B,oBAAoB,EAAE2B,CAAE,CAAC;MAElF;IAED,CAAC,MAAM;MAEN,IAAI,CAACC,gBAAgB,CAAEtD,WAAW,CAAC5B,OAAO,EAAE4B,WAAW,CAAC0B,oBAAqB,CAAC;IAE/E;EAED;EAEA6B,aAAaA,CAAEnF,OAAO,EAAE2B,OAAO,EAAG;IAEjC,MAAMC,WAAW,GAAG,IAAI,CAACjC,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC;IAE/C,MAAM;MAAEsD;IAAqB,CAAC,GAAG1B,WAAW;IAE5C,IAAK5B,OAAO,CAAC4C,qBAAqB,IAAMU,oBAAoB,KAAKtB,SAAS,CAAC,gCAAkC,EAC5G;;IAED;;IAEA,IAAKhC,OAAO,CAACoF,aAAa,IAAIpF,OAAO,CAACqF,kBAAkB,IAAIrF,OAAO,CAACsF,eAAe,EAAG;MAErF,IAAI,CAACC,oBAAoB,CAAE5D,OAAO,CAAC6D,KAAK,EAAE5D,WAAW,CAAC5B,OAAO,EAAEsD,oBAAoB,EAAE,CAAC,EAAE,KAAM,CAAC;IAEhG,CAAC,MAAM,IAAKtD,OAAO,CAACoD,mBAAmB,EAAG;MAEzC,IAAI,CAACqC,8BAA8B,CAAEzF,OAAO,CAAC0F,OAAO,EAAE9D,WAAW,CAAC5B,OAAO,EAAEsD,oBAAqB,CAAC;IAElG,CAAC,MAAM,IAAKtD,OAAO,CAACuB,aAAa,EAAG;MAEnC,IAAI,CAACoE,qBAAqB,CAAEhE,OAAO,CAACiE,MAAM,EAAEhE,WAAW,CAAC5B,OAAO,EAAEsD,oBAAoB,EAAEtD,OAAO,CAAC6F,KAAM,CAAC;IAEvG,CAAC,MAAM,IAAK7F,OAAO,CAAC4D,cAAc,EAAG;MAEpC,MAAMC,KAAK,GAAG7D,OAAO,CAAC8D,MAAM,CAACC,IAAI;MAEjCnC,WAAW,CAACyC,eAAe,GAAGR,KAAK;IAEpC,CAAC,MAAM;MAEN,IAAI,CAACiC,mBAAmB,CAAEnE,OAAO,CAAC6D,KAAK,EAAE5D,WAAW,CAAC5B,OAAO,EAAEsD,oBAAoB,EAAE,CAAC,EAAEtD,OAAO,CAAC6F,KAAM,CAAC;IAEvG;;IAEA;;IAEAjE,WAAW,CAACmE,OAAO,GAAG/F,OAAO,CAAC+F,OAAO;IAErC,IAAK/F,OAAO,CAACgG,QAAQ,EAAGhG,OAAO,CAACgG,QAAQ,CAAEhG,OAAQ,CAAC;EAEpD;EAEA,MAAMiG,mBAAmBA,CAAEjG,OAAO,EAAEkG,CAAC,EAAEC,CAAC,EAAEhE,KAAK,EAAEC,MAAM,EAAG;IAEzD,MAAMnC,MAAM,GAAG,IAAI,CAACN,OAAO,CAACM,MAAM;IAElC,MAAM2B,WAAW,GAAG,IAAI,CAACjC,OAAO,CAACQ,GAAG,CAAEH,OAAQ,CAAC;IAC/C,MAAME,UAAU,GAAG0B,WAAW,CAAC5B,OAAO;IACtC,MAAMuC,MAAM,GAAGX,WAAW,CAAC0B,oBAAoB,CAACf,MAAM;IACtD,MAAM6D,aAAa,GAAG,IAAI,CAACC,iBAAiB,CAAE9D,MAAO,CAAC;IAEtD,MAAM+D,UAAU,GAAGrG,MAAM,CAACsG,YAAY,CACrC;MACC9C,IAAI,EAAEtB,KAAK,GAAGC,MAAM,GAAGgE,aAAa;MACpCvD,KAAK,EAAE2D,cAAc,CAACxD,QAAQ,GAAGwD,cAAc,CAACC;IACjD,CACD,CAAC;IAED,MAAMC,OAAO,GAAGzG,MAAM,CAAC0G,oBAAoB,CAAC,CAAC;IAE7CD,OAAO,CAACT,mBAAmB,CAC1B;MACCjG,OAAO,EAAEE,UAAU;MACnB0G,MAAM,EAAE;QAAEV,CAAC;QAAEC;MAAE;IAChB,CAAC,EACD;MACCU,MAAM,EAAEP,UAAU;MAClBQ,WAAW,EAAE3E,KAAK,GAAGiE;IACtB,CAAC,EACD;MACCjE,KAAK,EAAEA,KAAK;MACZC,MAAM,EAAEA;IACT,CAED,CAAC;IAED,MAAM2E,cAAc,GAAG,IAAI,CAACC,kBAAkB,CAAEzE,MAAO,CAAC;IAExDtC,MAAM,CAACgH,KAAK,CAACC,MAAM,CAAE,CAAER,OAAO,CAACS,MAAM,CAAC,CAAC,CAAG,CAAC;IAE3C,MAAMb,UAAU,CAACc,QAAQ,CAAEC,UAAU,CAACC,IAAK,CAAC;IAE5C,MAAMT,MAAM,GAAGP,UAAU,CAACiB,cAAc,CAAC,CAAC;IAE1C,OAAO,IAAIR,cAAc,CAAEF,MAAO,CAAC;EAEpC;EAEAW,qBAAqBA,CAAExH,OAAO,EAAG;IAEhC,MAAMyH,OAAO,GAAGzH,OAAO,CAACyH,OAAO;IAE/B,OAASA,OAAO,KAAKrI,gCAAgC,IAAIqI,OAAO,KAAKpI,gCAAgC,IAAQoI,OAAO,KAAKvI,qBAAqB,IAAIuI,OAAO,KAAKtI,qBAAuB;EAEtL;EAEAsC,qBAAqBA,CAAA,EAAG;IAEvB,IAAI5B,cAAc,GAAG,IAAI,CAACA,cAAc;IAExC,IAAKA,cAAc,KAAK,IAAI,EAAG;MAE9B,MAAMG,OAAO,GAAG,IAAI3D,OAAO,CAAC,CAAC;MAC7B2D,OAAO,CAACc,SAAS,GAAGxE,aAAa;MACjC0D,OAAO,CAACY,SAAS,GAAGtE,aAAa;MAEjC,IAAI,CAACoF,aAAa,CAAE1B,OAAO,EAAE;QAAEmC,KAAK,EAAE,CAAC;QAAEC,MAAM,EAAE;MAAE,CAAE,CAAC;MAEtD,IAAI,CAACvC,cAAc,GAAGA,cAAc,GAAGG,OAAO;IAE/C;IAEA,OAAO,IAAI,CAACL,OAAO,CAACQ,GAAG,CAAEN,cAAe,CAAC,CAACG,OAAO;EAElD;EAEAwB,yBAAyBA,CAAA,EAAG;IAE3B,IAAI1B,kBAAkB,GAAG,IAAI,CAACD,cAAc;IAE5C,IAAKC,kBAAkB,KAAK,IAAI,EAAG;MAElC,MAAME,OAAO,GAAG,IAAI5D,WAAW,CAAC,CAAC;MACjC4D,OAAO,CAACc,SAAS,GAAGxE,aAAa;MACjC0D,OAAO,CAACY,SAAS,GAAGtE,aAAa;MAEjC,IAAI,CAACoF,aAAa,CAAE1B,OAAO,EAAE;QAAEmC,KAAK,EAAE,CAAC;QAAEC,MAAM,EAAE,CAAC;QAAEF,KAAK,EAAE;MAAE,CAAE,CAAC;MAEhE,IAAI,CAACpC,kBAAkB,GAAGA,kBAAkB,GAAGE,OAAO;IAEvD;IAEA,OAAO,IAAI,CAACL,OAAO,CAACQ,GAAG,CAAEL,kBAAmB,CAAC,CAACE,OAAO;EAEtD;EAEA2F,qBAAqBA,CAAEC,MAAM,EAAE1F,UAAU,EAAEoD,oBAAoB,EAAEuC,KAAK,EAAG;IAExE,KAAM,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;MAE9B,MAAMO,KAAK,GAAGI,MAAM,CAAEX,CAAC,CAAE;MAEzB,MAAMyC,SAAS,GAAG7B,KAAK,KAAK,IAAI,GAAGrG,QAAQ,CAAEyF,CAAC,CAAE,GAAGA,CAAC;MAEpD,IAAKO,KAAK,CAACJ,aAAa,EAAG;QAE1B,IAAI,CAACG,oBAAoB,CAAEC,KAAK,CAACA,KAAK,EAAEtF,UAAU,EAAEoD,oBAAoB,EAAEoE,SAAS,EAAE7B,KAAM,CAAC;MAE7F,CAAC,MAAM;QAEN,IAAI,CAACC,mBAAmB,CAAEN,KAAK,EAAEtF,UAAU,EAAEoD,oBAAoB,EAAEoE,SAAS,EAAE7B,KAAM,CAAC;MAEtF;IAED;EAED;EAEAC,mBAAmBA,CAAEN,KAAK,EAAEtF,UAAU,EAAEoD,oBAAoB,EAAEqE,WAAW,EAAE9B,KAAK,EAAG;IAElF,MAAM5F,MAAM,GAAG,IAAI,CAACN,OAAO,CAACM,MAAM;IAElCA,MAAM,CAACgH,KAAK,CAACW,0BAA0B,CACtC;MACC9D,MAAM,EAAE0B;IACT,CAAC,EAAE;MACFxF,OAAO,EAAEE,UAAU;MACnB2H,QAAQ,EAAE,CAAC;MACXjB,MAAM,EAAE;QAAEV,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE,CAAC;QAAE2B,CAAC,EAAEH;MAAY;IACtC,CAAC,EAAE;MACFxF,KAAK,EAAEqD,KAAK,CAACrD,KAAK;MAClBC,MAAM,EAAEoD,KAAK,CAACpD,MAAM;MACpBsB,kBAAkB,EAAE;IACrB,CACD,CAAC;IAED,IAAKmC,KAAK,KAAK,IAAI,EAAG;MAErB,IAAI,CAACkC,MAAM,CAAE7H,UAAU,EAAEoD,oBAAoB,EAAEqE,WAAY,CAAC;IAE7D;EAED;EAEAK,aAAaA,CAAA,EAAG;IAEf,IAAIC,SAAS,GAAG,IAAI,CAACrI,UAAU;IAE/B,IAAKqI,SAAS,KAAK,IAAI,EAAG;MAEzB,IAAI,CAACrI,UAAU,GAAGqI,SAAS,GAAG,IAAI3I,sBAAsB,CAAE,IAAI,CAACK,OAAO,CAACM,MAAO,CAAC;IAEhF;IAEA,OAAOgI,SAAS;EAEjB;EAEA/C,gBAAgBA,CAAEhF,UAAU,EAAEoD,oBAAoB,EAAE4E,cAAc,GAAG,CAAC,EAAG;IAExE,IAAI,CAACF,aAAa,CAAC,CAAC,CAAChD,eAAe,CAAE9E,UAAU,EAAEoD,oBAAoB,EAAE4E,cAAe,CAAC;EAEzF;EAEAH,MAAMA,CAAE7H,UAAU,EAAEoD,oBAAoB,EAAEqE,WAAW,GAAG,CAAC,EAAG;IAE3D,IAAI,CAACK,aAAa,CAAC,CAAC,CAACnC,KAAK,CAAE3F,UAAU,EAAEoD,oBAAoB,EAAEqE,WAAY,CAAC;EAE5E;EAEApC,oBAAoBA,CAAEC,KAAK,EAAEtF,UAAU,EAAEoD,oBAAoB,EAAEqE,WAAW,EAAE9B,KAAK,EAAG;IAEnF;IACA;;IAEA,MAAM5F,MAAM,GAAG,IAAI,CAACN,OAAO,CAACM,MAAM;IAElC,MAAM8D,IAAI,GAAGyB,KAAK,CAACzB,IAAI;IAEvB,MAAMqC,aAAa,GAAG,IAAI,CAACC,iBAAiB,CAAE/C,oBAAoB,CAACf,MAAO,CAAC;IAC3E,MAAMuE,WAAW,GAAGtB,KAAK,CAACrD,KAAK,GAAGiE,aAAa;IAE/CnG,MAAM,CAACgH,KAAK,CAACkB,YAAY,CACxB;MACCnI,OAAO,EAAEE,UAAU;MACnB2H,QAAQ,EAAE,CAAC;MACXjB,MAAM,EAAE;QAAEV,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE,CAAC;QAAE2B,CAAC,EAAEH;MAAY;IACtC,CAAC,EACD5D,IAAI,EACJ;MACCqE,MAAM,EAAE,CAAC;MACTtB;IACD,CAAC,EACD;MACC3E,KAAK,EAAEqD,KAAK,CAACrD,KAAK;MAClBC,MAAM,EAAEoD,KAAK,CAACpD,MAAM;MACpBsB,kBAAkB,EAAI8B,KAAK,CAACtD,KAAK,KAAKF,SAAS,GAAKwD,KAAK,CAACtD,KAAK,GAAG;IACnE,CAAE,CAAC;IAEJ,IAAK2D,KAAK,KAAK,IAAI,EAAG;MAErB,IAAI,CAACkC,MAAM,CAAE7H,UAAU,EAAEoD,oBAAoB,EAAEqE,WAAY,CAAC;IAE7D;EAED;EAEAlC,8BAA8BA,CAAEC,OAAO,EAAExF,UAAU,EAAEoD,oBAAoB,EAAG;IAE3E;;IAEA,MAAMrD,MAAM,GAAG,IAAI,CAACN,OAAO,CAACM,MAAM;IAElC,MAAMoI,SAAS,GAAG,IAAI,CAACC,aAAa,CAAEhF,oBAAoB,CAACf,MAAO,CAAC;IAEnE,KAAM,IAAI0C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,OAAO,CAAC6C,MAAM,EAAEtD,CAAC,EAAG,EAAG;MAE3C,MAAMuD,MAAM,GAAG9C,OAAO,CAAET,CAAC,CAAE;MAE3B,MAAM9C,KAAK,GAAGqG,MAAM,CAACrG,KAAK;MAC1B,MAAMC,MAAM,GAAGoG,MAAM,CAACpG,MAAM;MAE5B,MAAM0E,WAAW,GAAG2B,IAAI,CAACC,IAAI,CAAEvG,KAAK,GAAGkG,SAAS,CAAClG,KAAM,CAAC,GAAGkG,SAAS,CAACM,UAAU;MAE/E1I,MAAM,CAACgH,KAAK,CAACkB,YAAY,CACxB;QACCnI,OAAO,EAAEE,UAAU;QACnB2H,QAAQ,EAAE5C;MACX,CAAC,EACDuD,MAAM,CAACzE,IAAI,EACX;QACCqE,MAAM,EAAE,CAAC;QACTtB;MACD,CAAC,EACD;QACC3E,KAAK,EAAEsG,IAAI,CAACC,IAAI,CAAEvG,KAAK,GAAGkG,SAAS,CAAClG,KAAM,CAAC,GAAGkG,SAAS,CAAClG,KAAK;QAC7DC,MAAM,EAAEqG,IAAI,CAACC,IAAI,CAAEtG,MAAM,GAAGiG,SAAS,CAAClG,KAAM,CAAC,GAAGkG,SAAS,CAAClG,KAAK;QAC/DuB,kBAAkB,EAAE;MACrB,CACD,CAAC;IAEF;EAED;EAEA4E,aAAaA,CAAE/F,MAAM,EAAG;IAEvB;;IAEA,IAAKA,MAAM,KAAKxG,gBAAgB,CAAC6M,YAAY,IAAIrG,MAAM,KAAKxG,gBAAgB,CAAC8M,gBAAgB,EAAG,OAAO;MAAEF,UAAU,EAAE,CAAC;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC,CAAC,CAAC;IAC/I,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC+M,YAAY,IAAIvG,MAAM,KAAKxG,gBAAgB,CAACgN,gBAAgB,EAAG,OAAO;MAAEJ,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC,CAAC,CAAC;IAChJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAACiN,YAAY,IAAIzG,MAAM,KAAKxG,gBAAgB,CAACkN,gBAAgB,EAAG,OAAO;MAAEN,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC,CAAC,CAAC;IAChJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAACmN,SAAS,IAAI3G,MAAM,KAAKxG,gBAAgB,CAACoN,SAAS,EAAG,OAAO;MAAER,UAAU,EAAE,CAAC;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC,CAAC,CAAC;IACrI,IAAKG,MAAM,KAAKxG,gBAAgB,CAACqN,UAAU,IAAI7G,MAAM,KAAKxG,gBAAgB,CAACsN,UAAU,EAAG,OAAO;MAAEV,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC,CAAC,CAAC;IACxI,IAAKG,MAAM,KAAKxG,gBAAgB,CAACuN,aAAa,IAAI/G,MAAM,KAAKxG,gBAAgB,CAACwN,YAAY,EAAG,OAAO;MAAEZ,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC,CAAC,CAAC;IAC7I,IAAKG,MAAM,KAAKxG,gBAAgB,CAACyN,YAAY,IAAIjH,MAAM,KAAKxG,gBAAgB,CAAC0N,gBAAgB,EAAG,OAAO;MAAEd,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC,CAAC,CAAC;;IAEhJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC2N,aAAa,IAAInH,MAAM,KAAKxG,gBAAgB,CAAC4N,iBAAiB,EAAG,OAAO;MAAEhB,UAAU,EAAE,CAAC;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC/I,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC6N,eAAe,IAAIrH,MAAM,KAAKxG,gBAAgB,CAAC8N,mBAAmB,EAAG,OAAO;MAAElB,UAAU,EAAE,CAAC;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IACnJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC+N,cAAc,IAAIvH,MAAM,KAAKxG,gBAAgB,CAACgO,kBAAkB,EAAG,OAAO;MAAEpB,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAClJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAACiO,WAAW,EAAG,OAAO;MAAErB,UAAU,EAAE,CAAC;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC5F,IAAKG,MAAM,KAAKxG,gBAAgB,CAACkO,WAAW,EAAG,OAAO;MAAEtB,UAAU,EAAE,CAAC;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC5F,IAAKG,MAAM,KAAKxG,gBAAgB,CAACmO,YAAY,EAAG,OAAO;MAAEvB,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9F,IAAKG,MAAM,KAAKxG,gBAAgB,CAACoO,YAAY,EAAG,OAAO;MAAExB,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAE9F,IAAKG,MAAM,KAAKxG,gBAAgB,CAACqO,YAAY,IAAI7H,MAAM,KAAKxG,gBAAgB,CAACsO,gBAAgB,EAAG,OAAO;MAAE1B,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAACuO,YAAY,IAAI/H,MAAM,KAAKxG,gBAAgB,CAACwO,gBAAgB,EAAG,OAAO;MAAE5B,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAACyO,YAAY,IAAIjI,MAAM,KAAKxG,gBAAgB,CAAC0O,gBAAgB,EAAG,OAAO;MAAE9B,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC2O,YAAY,IAAInI,MAAM,KAAKxG,gBAAgB,CAAC4O,gBAAgB,EAAG,OAAO;MAAEhC,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC6O,YAAY,IAAIrI,MAAM,KAAKxG,gBAAgB,CAAC8O,gBAAgB,EAAG,OAAO;MAAElC,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC+O,YAAY,IAAIvI,MAAM,KAAKxG,gBAAgB,CAACgP,gBAAgB,EAAG,OAAO;MAAEpC,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAACiP,YAAY,IAAIzI,MAAM,KAAKxG,gBAAgB,CAACkP,gBAAgB,EAAG,OAAO;MAAEtC,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAACmP,YAAY,IAAI3I,MAAM,KAAKxG,gBAAgB,CAACoP,gBAAgB,EAAG,OAAO;MAAExC,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9I,IAAKG,MAAM,KAAKxG,gBAAgB,CAACqP,aAAa,IAAI7I,MAAM,KAAKxG,gBAAgB,CAACsP,iBAAiB,EAAG,OAAO;MAAE1C,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAE,CAAC;IACjJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAACuP,aAAa,IAAI/I,MAAM,KAAKxG,gBAAgB,CAACwP,iBAAiB,EAAG,OAAO;MAAE5C,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAE,CAAC;IACjJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAACyP,aAAa,IAAIjJ,MAAM,KAAKxG,gBAAgB,CAAC0P,iBAAiB,EAAG,OAAO;MAAE9C,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAE,CAAC;IACjJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC2P,cAAc,IAAInJ,MAAM,KAAKxG,gBAAgB,CAAC4P,kBAAkB,EAAG,OAAO;MAAEhD,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAG,CAAC;IACpJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC6P,cAAc,IAAIrJ,MAAM,KAAKxG,gBAAgB,CAAC8P,kBAAkB,EAAG,OAAO;MAAElD,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAG,CAAC;IACpJ,IAAKG,MAAM,KAAKxG,gBAAgB,CAAC+P,cAAc,IAAIvJ,MAAM,KAAKxG,gBAAgB,CAACgQ,kBAAkB,EAAG,OAAO;MAAEpD,UAAU,EAAE,EAAE;MAAExG,KAAK,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAG,CAAC;EAErJ;EAEA9B,mBAAmBA,CAAE0L,KAAK,EAAG;IAE5B,IAAIC,WAAW,GAAGjQ,cAAc,CAACkQ,WAAW;IAE5C,IAAKF,KAAK,KAAKvP,cAAc,EAAG;MAE/BwP,WAAW,GAAGjQ,cAAc,CAACmQ,MAAM;IAEpC,CAAC,MAAM,IAAKH,KAAK,KAAKtP,sBAAsB,EAAG;MAE9CuP,WAAW,GAAGjQ,cAAc,CAACoQ,YAAY;IAE1C;IAEA,OAAOH,WAAW;EAEnB;EAEApL,kBAAkBA,CAAEmL,KAAK,EAAG;IAE3B,IAAIK,UAAU,GAAGpQ,aAAa,CAACqQ,MAAM;IAErC,IAAKN,KAAK,KAAK1P,aAAa,IAAI0P,KAAK,KAAKzP,0BAA0B,IAAIyP,KAAK,KAAKxP,yBAAyB,EAAG;MAE7G6P,UAAU,GAAGpQ,aAAa,CAACsQ,OAAO;IAEnC;IAEA,OAAOF,UAAU;EAElB;EAEAhG,iBAAiBA,CAAE9D,MAAM,EAAG;IAE3B,IAAKA,MAAM,KAAKxG,gBAAgB,CAACyQ,OAAO,EAAG,OAAO,CAAC;IACnD,IAAKjK,MAAM,KAAKxG,gBAAgB,CAAC0Q,QAAQ,EAAG,OAAO,CAAC;IACpD,IAAKlK,MAAM,KAAKxG,gBAAgB,CAAC2Q,QAAQ,EAAG,OAAO,CAAC;IACpD,IAAKnK,MAAM,KAAKxG,gBAAgB,CAAC4Q,SAAS,EAAG,OAAO,CAAC;IACrD,IAAKpK,MAAM,KAAKxG,gBAAgB,CAAC6Q,QAAQ,EAAG,OAAO,CAAC;IACpD,IAAKrK,MAAM,KAAKxG,gBAAgB,CAAC8Q,UAAU,IAAItK,MAAM,KAAKxG,gBAAgB,CAAC+Q,cAAc,EAAG,OAAO,CAAC;IACpG,IAAKvK,MAAM,KAAKxG,gBAAgB,CAACgR,SAAS,EAAG,OAAO,CAAC;IACrD,IAAKxK,MAAM,KAAKxG,gBAAgB,CAACiR,WAAW,EAAG,OAAO,CAAC;IACvD,IAAKzK,MAAM,KAAKxG,gBAAgB,CAACkR,WAAW,EAAG,OAAO,EAAE;EAEzD;EAEAjG,kBAAkBA,CAAEzE,MAAM,EAAG;IAE5B,IAAKA,MAAM,KAAKxG,gBAAgB,CAACmR,MAAM,EAAG,OAAOC,UAAU;IAC3D,IAAK5K,MAAM,KAAKxG,gBAAgB,CAACqR,MAAM,EAAG,OAAOC,SAAS;IAC1D,IAAK9K,MAAM,KAAKxG,gBAAgB,CAACyQ,OAAO,EAAG,OAAOW,UAAU;IAC5D,IAAK5K,MAAM,KAAKxG,gBAAgB,CAACuR,OAAO,EAAG,OAAOD,SAAS;IAC3D,IAAK9K,MAAM,KAAKxG,gBAAgB,CAACwR,OAAO,EAAG,OAAOJ,UAAU;IAC5D,IAAK5K,MAAM,KAAKxG,gBAAgB,CAACyR,OAAO,EAAG,OAAOH,SAAS;IAC3D,IAAK9K,MAAM,KAAKxG,gBAAgB,CAAC2Q,QAAQ,EAAG,OAAOS,UAAU;IAC7D,IAAK5K,MAAM,KAAKxG,gBAAgB,CAAC0R,QAAQ,EAAG,OAAOJ,SAAS;IAC5D,IAAK9K,MAAM,KAAKxG,gBAAgB,CAAC2R,SAAS,EAAG,OAAOP,UAAU;IAC9D,IAAK5K,MAAM,KAAKxG,gBAAgB,CAAC4R,SAAS,EAAG,OAAON,SAAS;IAC7D,IAAK9K,MAAM,KAAKxG,gBAAgB,CAAC8Q,UAAU,EAAG,OAAOM,UAAU;IAC/D,IAAK5K,MAAM,KAAKxG,gBAAgB,CAAC6R,UAAU,EAAG,OAAOP,SAAS;IAG9D,IAAK9K,MAAM,KAAKxG,gBAAgB,CAAC8R,OAAO,EAAG,OAAOC,WAAW;IAC7D,IAAKvL,MAAM,KAAKxG,gBAAgB,CAACgS,OAAO,EAAG,OAAOC,UAAU;IAC5D,IAAKzL,MAAM,KAAKxG,gBAAgB,CAACkS,QAAQ,EAAG,OAAOH,WAAW;IAC9D,IAAKvL,MAAM,KAAKxG,gBAAgB,CAACmS,QAAQ,EAAG,OAAOF,UAAU;IAC7D,IAAKzL,MAAM,KAAKxG,gBAAgB,CAACoS,UAAU,EAAG,OAAOL,WAAW;IAChE,IAAKvL,MAAM,KAAKxG,gBAAgB,CAACqS,UAAU,EAAG,OAAOJ,UAAU;IAG/D,IAAKzL,MAAM,KAAKxG,gBAAgB,CAACsS,OAAO,EAAG,OAAOC,WAAW;IAC7D,IAAK/L,MAAM,KAAKxG,gBAAgB,CAACwS,OAAO,EAAG,OAAOC,UAAU;IAC5D,IAAKjM,MAAM,KAAKxG,gBAAgB,CAAC6Q,QAAQ,EAAG,OAAO6B,YAAY;IAC/D,IAAKlM,MAAM,KAAKxG,gBAAgB,CAAC2S,QAAQ,EAAG,OAAOJ,WAAW;IAC9D,IAAK/L,MAAM,KAAKxG,gBAAgB,CAAC4S,QAAQ,EAAG,OAAOH,UAAU;IAC7D,IAAKjM,MAAM,KAAKxG,gBAAgB,CAACgR,SAAS,EAAG,OAAO0B,YAAY;IAChE,IAAKlM,MAAM,KAAKxG,gBAAgB,CAAC6S,UAAU,EAAG,OAAON,WAAW;IAChE,IAAK/L,MAAM,KAAKxG,gBAAgB,CAAC8S,UAAU,EAAG,OAAOL,UAAU;IAC/D,IAAKjM,MAAM,KAAKxG,gBAAgB,CAACkR,WAAW,EAAG,OAAOwB,YAAY;EAEnE;EAEAnM,aAAaA,CAAEtC,OAAO,EAAG;IAExB,IAAIqC,SAAS;IAEb,IAAKrC,OAAO,CAACsF,eAAe,EAAG;MAE9BjD,SAAS,GAAGnG,mBAAmB,CAAC4S,MAAM;IAEvC,CAAC,MAAM;MAENzM,SAAS,GAAGnG,mBAAmB,CAAC6S,IAAI;IAErC;IAEA,OAAO1M,SAAS;EAEjB;AAED;AAEA,OAAO,SAASI,SAASA,CAAEzC,OAAO,EAAEC,MAAM,GAAG,IAAI,EAAG;EAEnD,MAAMsC,MAAM,GAAGvC,OAAO,CAACuC,MAAM;EAC7B,MAAMyM,IAAI,GAAGhP,OAAO,CAACgP,IAAI;EACzB,MAAMC,UAAU,GAAGjP,OAAO,CAACiP,UAAU;EAErC,IAAIC,SAAS;EAEb,KAAK,6CAA8ClP,OAAO,CAACmP,oBAAoB,KAAK,IAAI,EAAG;IAE1FD,SAAS,GAAGnT,gBAAgB,CAACqT,UAAU;EAExC,CAAC,MAAM,IAAKpP,OAAO,CAACoD,mBAAmB,KAAK,IAAI,EAAG;IAElD,QAASb,MAAM;MAEd,KAAKvF,qBAAqB;QACzBkS,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC8M,gBAAgB,GAAG9M,gBAAgB,CAAC6M,YAAY;QACjH;MAED,KAAK3L,qBAAqB;QACzBiS,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACgN,gBAAgB,GAAGhN,gBAAgB,CAAC+M,YAAY;QACjH;MAED,KAAK5L,qBAAqB;QACzBgS,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACkN,gBAAgB,GAAGlN,gBAAgB,CAACiN,YAAY;QACjH;MAED,KAAKrM,eAAe;QACnBuS,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC4N,iBAAiB,GAAG5N,gBAAgB,CAAC2N,aAAa;QACnH;MAED,KAAK9M,oBAAoB;QACxBsS,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACgO,kBAAkB,GAAGhO,gBAAgB,CAAC+N,cAAc;QACrH;MAED,KAAKrM,oBAAoB;QACxByR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACsO,gBAAgB,GAAGtO,gBAAgB,CAACqO,YAAY;QACjH;MAED,KAAK1M,oBAAoB;QACxBwR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACwO,gBAAgB,GAAGxO,gBAAgB,CAACuO,YAAY;QACjH;MAED,KAAK3M,oBAAoB;QACxBuR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC0O,gBAAgB,GAAG1O,gBAAgB,CAACyO,YAAY;QACjH;MAED,KAAK5M,oBAAoB;QACxBsR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC4O,gBAAgB,GAAG5O,gBAAgB,CAAC2O,YAAY;QACjH;MAED,KAAK7M,oBAAoB;QACxBqR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC8O,gBAAgB,GAAG9O,gBAAgB,CAAC6O,YAAY;QACjH;MAED,KAAK9M,oBAAoB;QACxBoR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACgP,gBAAgB,GAAGhP,gBAAgB,CAAC+O,YAAY;QACjH;MAED,KAAK/M,oBAAoB;QACxBmR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACkP,gBAAgB,GAAGlP,gBAAgB,CAACiP,YAAY;QACjH;MAED,KAAKhN,oBAAoB;QACxBkR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACoP,gBAAgB,GAAGpP,gBAAgB,CAACmP,YAAY;QACjH;MAED,KAAKjN,qBAAqB;QACzBiR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACsP,iBAAiB,GAAGtP,gBAAgB,CAACqP,aAAa;QACnH;MAED,KAAKlN,qBAAqB;QACzBgR,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACwP,iBAAiB,GAAGxP,gBAAgB,CAACuP,aAAa;QACnH;MAED,KAAKnN,qBAAqB;QACzB+Q,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC0P,iBAAiB,GAAG1P,gBAAgB,CAACyP,aAAa;QACnH;MAED,KAAKpN,sBAAsB;QAC1B8Q,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC4P,kBAAkB,GAAG5P,gBAAgB,CAAC2P,cAAc;QACrH;MAED,KAAKrN,sBAAsB;QAC1B6Q,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC8P,kBAAkB,GAAG9P,gBAAgB,CAAC6P,cAAc;QACrH;MAED,KAAKtN,sBAAsB;QAC1B4Q,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAACgQ,kBAAkB,GAAGhQ,gBAAgB,CAAC+P,cAAc;QACrH;MAED;QACCxH,OAAO,CAAC+K,KAAK,CAAE,6CAA6C,EAAE9M,MAAO,CAAC;IAExE;EAED,CAAC,MAAM;IAEN,QAASA,MAAM;MAEd,KAAK1F,UAAU;QAEd,QAASmS,IAAI;UAEZ,KAAK7R,gBAAgB;YACpB+R,SAAS,GAAKD,UAAU,KAAK3R,cAAc,GAAKvB,gBAAgB,CAAC+Q,cAAc,GAAG/Q,gBAAgB,CAAC8Q,UAAU;YAC7G;UAED,KAAKxP,aAAa;YACjB6R,SAAS,GAAGnT,gBAAgB,CAACiR,WAAW;YACxC;UAED,KAAK5P,SAAS;YACb8R,SAAS,GAAGnT,gBAAgB,CAACkR,WAAW;YACxC;UAED;YACC3I,OAAO,CAAC+K,KAAK,CAAE,2DAA2D,EAAEL,IAAK,CAAC;QAEpF;QAEA;MAED,KAAKlS,SAAS;QAEb,QAASkS,IAAI;UAEZ,KAAK7R,gBAAgB;YACpB+R,SAAS,GAAGnT,gBAAgB,CAACyQ,OAAO;YACpC;UAED,KAAKnP,aAAa;YACjB6R,SAAS,GAAGnT,gBAAgB,CAAC0Q,QAAQ;YACrC;UAED,KAAKrP,SAAS;YACb8R,SAAS,GAAGnT,gBAAgB,CAAC6Q,QAAQ;YACrC;UAED;YACCtI,OAAO,CAAC+K,KAAK,CAAE,0DAA0D,EAAEL,IAAK,CAAC;QAEnF;QAEA;MAED,KAAKjS,QAAQ;QAEZ,QAASiS,IAAI;UAEZ,KAAK7R,gBAAgB;YACpB+R,SAAS,GAAGnT,gBAAgB,CAAC2Q,QAAQ;YACrC;UAED,KAAKrP,aAAa;YACjB6R,SAAS,GAAGnT,gBAAgB,CAAC4Q,SAAS;YACtC;UAED,KAAKvP,SAAS;YACb8R,SAAS,GAAGnT,gBAAgB,CAACgR,SAAS;YACtC;UAED;YACCzI,OAAO,CAAC+K,KAAK,CAAE,yDAAyD,EAAEL,IAAK,CAAC;QAElF;QAEA;MAED,KAAKzR,WAAW;QAEf,QAASyR,IAAI;UAEZ,KAAKxQ,iBAAiB;YACrB0Q,SAAS,GAAGnT,gBAAgB,CAACuT,YAAY;YACzC;UAED,KAAK/Q,eAAe;YACnB2Q,SAAS,GAAGnT,gBAAgB,CAACwT,WAAW;YACxC;UAED,KAAKnS,SAAS;YACb8R,SAAS,GAAGnT,gBAAgB,CAACyT,YAAY;YACzC;UAED;YACClL,OAAO,CAAC+K,KAAK,CAAE,4DAA4D,EAAEL,IAAK,CAAC;QAErF;QAEA;MAED,KAAKxR,kBAAkB;QAEtB,QAASwR,IAAI;UAEZ,KAAKvQ,kBAAkB;YACtByQ,SAAS,GAAGnT,gBAAgB,CAAC0T,mBAAmB;YAChD;UAED,KAAKrS,SAAS;YAEb,IAAK6C,MAAM,IAAIA,MAAM,CAACyP,QAAQ,CAACC,GAAG,CAAExT,cAAc,CAACyT,oBAAqB,CAAC,KAAK,KAAK,EAAG;cAErFtL,OAAO,CAAC+K,KAAK,CAAE,mIAAoI,CAAC;YAErJ;YAEAH,SAAS,GAAGnT,gBAAgB,CAAC6T,oBAAoB;YAEjD;UAED;YACCtL,OAAO,CAAC+K,KAAK,CAAE,mEAAmE,EAAEL,IAAK,CAAC;QAE5F;QAEA;MAED;QACC1K,OAAO,CAAC+K,KAAK,CAAE,6CAA6C,EAAE9M,MAAO,CAAC;IAExE;EAED;EAEA,OAAO2M,SAAS;AAEjB;AAEA,eAAezP,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}