{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Node from '../core/Node.js';\nimport AnalyticLightNode from './AnalyticLightNode.js';\nimport { nodeObject, nodeProxy } from '../shadernode/ShaderNode.js';\nconst LightNodes = new WeakMap();\nconst sortLights = lights => {\n  return lights.sort((a, b) => a.id - b.id);\n};\nclass LightsNode extends Node {\n  constructor(lightNodes = []) {\n    super('vec3');\n    this.lightNodes = lightNodes;\n    this._hash = null;\n  }\n  get hasLight() {\n    return this.lightNodes.length > 0;\n  }\n  setup(builder) {\n    const lightNodes = this.lightNodes;\n    for (const lightNode of lightNodes) {\n      lightNode.build(builder);\n    }\n  }\n  getHash(builder) {\n    if (this._hash === null) {\n      let hash = '';\n      const lightNodes = this.lightNodes;\n      for (const lightNode of lightNodes) {\n        hash += lightNode.getHash(builder) + ' ';\n      }\n      this._hash = hash;\n    }\n    return this._hash;\n  }\n  getLightNodeByHash(hash) {\n    const lightNodes = this.lightNodes;\n    for (const lightNode of lightNodes) {\n      if (lightNode.light.uuid === hash) {\n        return lightNode;\n      }\n    }\n    return null;\n  }\n  fromLights(lights = []) {\n    const lightNodes = [];\n    lights = sortLights(lights);\n    for (const light of lights) {\n      let lightNode = this.getLightNodeByHash(light.uuid);\n      if (lightNode === null) {\n        const lightClass = light.constructor;\n        const lightNodeClass = LightNodes.has(lightClass) ? LightNodes.get(lightClass) : AnalyticLightNode;\n        lightNode = nodeObject(new lightNodeClass(light));\n      }\n      lightNodes.push(lightNode);\n    }\n    this.lightNodes = lightNodes;\n    this._hash = null;\n    return this;\n  }\n}\nexport default LightsNode;\nexport const lights = lights => nodeObject(new LightsNode().fromLights(lights));\nexport const lightsWithoutWrap = nodeProxy(LightsNode);\nexport function addLightNode(lightClass, lightNodeClass) {\n  if (LightNodes.has(lightClass)) throw new Error(`Redefinition of light node ${lightNodeClass.type}`);\n  if (typeof lightClass !== 'function') throw new Error(`Light ${lightClass.name} is not a class`);\n  if (typeof lightNodeClass !== 'function' || !lightNodeClass.type) throw new Error(`Light node ${lightNodeClass.type} is not a class`);\n  LightNodes.set(lightClass, lightNodeClass);\n}","map":{"version":3,"names":["Node","AnalyticLightNode","nodeObject","nodeProxy","LightNodes","WeakMap","sortLights","lights","sort","a","b","id","LightsNode","constructor","lightNodes","_hash","hasLight","length","setup","builder","lightNode","build","getHash","hash","getLightNodeByHash","light","uuid","fromLights","lightClass","lightNodeClass","has","get","push","lightsWithoutWrap","addLightNode","Error","type","name","set"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/lighting/LightsNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport AnalyticLightNode from './AnalyticLightNode.js';\nimport { nodeObject, nodeProxy } from '../shadernode/ShaderNode.js';\n\nconst LightNodes = new WeakMap();\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nclass LightsNode extends Node {\n\n\tconstructor( lightNodes = [] ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.lightNodes = lightNodes;\n\n\t\tthis._hash = null;\n\n\t}\n\n\tget hasLight() {\n\n\t\treturn this.lightNodes.length > 0;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst lightNodes = this.lightNodes;\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this._hash === null ) {\n\n\t\t\tlet hash = '';\n\n\t\t\tconst lightNodes = this.lightNodes;\n\n\t\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\t\thash += lightNode.getHash( builder ) + ' ';\n\n\t\t\t}\n\n\t\t\tthis._hash = hash;\n\n\t\t}\n\n\t\treturn this._hash;\n\n\t}\n\n\tgetLightNodeByHash( hash ) {\n\n\t\tconst lightNodes = this.lightNodes;\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tif ( lightNode.light.uuid === hash ) {\n\n\t\t\t\treturn lightNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfromLights( lights = [] ) {\n\n\t\tconst lightNodes = [];\n\n\t\tlights = sortLights( lights );\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tlet lightNode = this.getLightNodeByHash( light.uuid );\n\n\t\t\tif ( lightNode === null ) {\n\n\t\t\t\tconst lightClass = light.constructor;\n\t\t\t\tconst lightNodeClass = LightNodes.has( lightClass ) ? LightNodes.get( lightClass ) : AnalyticLightNode;\n\n\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\n\t\t\t}\n\n\t\t\tlightNodes.push( lightNode );\n\n\t\t}\n\n\t\tthis.lightNodes = lightNodes;\n\t\tthis._hash = null;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport default LightsNode;\n\nexport const lights = ( lights ) => nodeObject( new LightsNode().fromLights( lights ) );\nexport const lightsWithoutWrap = nodeProxy( LightsNode );\n\nexport function addLightNode( lightClass, lightNodeClass ) {\n\n\tif ( LightNodes.has( lightClass ) ) throw new Error( `Redefinition of light node ${ lightNodeClass.type }` );\n\tif ( typeof lightClass !== 'function' ) throw new Error( `Light ${ lightClass.name } is not a class` );\n\tif ( typeof lightNodeClass !== 'function' || ! lightNodeClass.type ) throw new Error( `Light node ${ lightNodeClass.type } is not a class` );\n\n\tLightNodes.set( lightClass, lightNodeClass );\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}