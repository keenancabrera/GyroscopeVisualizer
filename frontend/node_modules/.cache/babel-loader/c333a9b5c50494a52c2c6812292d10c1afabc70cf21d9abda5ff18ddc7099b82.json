{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { GPUTextureAspect, GPUTextureViewDimension, GPUBufferBindingType, GPUTextureSampleType } from './WebGPUConstants.js';\nimport { FloatType } from 'three';\nclass WebGPUBindingUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createBindingsLayout(bindings) {\n    const backend = this.backend;\n    const device = backend.device;\n    const entries = [];\n    let index = 0;\n    for (const binding of bindings) {\n      const bindingGPU = {\n        binding: index++,\n        visibility: binding.visibility\n      };\n      if (binding.isUniformBuffer || binding.isStorageBuffer) {\n        const buffer = {}; // GPUBufferBindingLayout\n\n        if (binding.isStorageBuffer) {\n          buffer.type = GPUBufferBindingType.Storage;\n        }\n        bindingGPU.buffer = buffer;\n      } else if (binding.isSampler) {\n        const sampler = {}; // GPUSamplerBindingLayout\n\n        if (binding.texture.isDepthTexture) {\n          if (binding.texture.compareFunction !== null) {\n            sampler.type = 'comparison';\n          }\n        }\n        bindingGPU.sampler = sampler;\n      } else if (binding.isSampledTexture && binding.texture.isVideoTexture) {\n        bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n      } else if (binding.isSampledTexture && binding.store) {\n        const format = this.backend.get(binding.texture).texture.format;\n        bindingGPU.storageTexture = {\n          format\n        }; // GPUStorageTextureBindingLayout\n      } else if (binding.isSampledTexture) {\n        const texture = {}; // GPUTextureBindingLayout\n\n        if (binding.texture.isDepthTexture) {\n          texture.sampleType = GPUTextureSampleType.Depth;\n        } else if (binding.texture.isDataTexture && binding.texture.type === FloatType) {\n          // @TODO: Add support for this soon: backend.hasFeature( 'float32-filterable' )\n\n          texture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n        }\n        if (binding.isSampledCubeTexture) {\n          texture.viewDimension = GPUTextureViewDimension.Cube;\n        }\n        bindingGPU.texture = texture;\n      } else {\n        console.error('WebGPUBindingUtils: Unsupported binding \"${ binding }\".');\n      }\n      entries.push(bindingGPU);\n    }\n    return device.createBindGroupLayout({\n      entries\n    });\n  }\n  createBindings(bindings) {\n    const backend = this.backend;\n    const bindingsData = backend.get(bindings);\n\n    // setup (static) binding layout and (dynamic) binding group\n\n    const bindLayoutGPU = this.createBindingsLayout(bindings);\n    const bindGroupGPU = this.createBindGroup(bindings, bindLayoutGPU);\n    bindingsData.layout = bindLayoutGPU;\n    bindingsData.group = bindGroupGPU;\n    bindingsData.bindings = bindings;\n  }\n  updateBinding(binding) {\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = binding.buffer;\n    const bufferGPU = backend.get(binding).buffer;\n    device.queue.writeBuffer(bufferGPU, 0, buffer, 0);\n  }\n  createBindGroup(bindings, layoutGPU) {\n    const backend = this.backend;\n    const device = backend.device;\n    let bindingPoint = 0;\n    const entriesGPU = [];\n    for (const binding of bindings) {\n      if (binding.isUniformBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const byteLength = binding.byteLength;\n          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n          const bufferGPU = device.createBuffer({\n            label: 'bindingBuffer',\n            size: byteLength,\n            usage: usage\n          });\n          bindingData.buffer = bufferGPU;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isStorageBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const attribute = binding.attribute;\n          //const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n          //backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n          bindingData.buffer = backend.get(attribute).buffer;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isSampler) {\n        const textureGPU = backend.get(binding.texture);\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: textureGPU.sampler\n        });\n      } else if (binding.isSampledTexture) {\n        const textureData = backend.get(binding.texture);\n        let dimensionViewGPU;\n        if (binding.isSampledCubeTexture) {\n          dimensionViewGPU = GPUTextureViewDimension.Cube;\n        } else {\n          dimensionViewGPU = GPUTextureViewDimension.TwoD;\n        }\n        let resourceGPU;\n        if (textureData.externalTexture !== undefined) {\n          resourceGPU = device.importExternalTexture({\n            source: textureData.externalTexture\n          });\n        } else {\n          const aspectGPU = GPUTextureAspect.All;\n          resourceGPU = textureData.texture.createView({\n            aspect: aspectGPU,\n            dimension: dimensionViewGPU\n          });\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: resourceGPU\n        });\n      }\n      bindingPoint++;\n    }\n    return device.createBindGroup({\n      layout: layoutGPU,\n      entries: entriesGPU\n    });\n  }\n}\nexport default WebGPUBindingUtils;","map":{"version":3,"names":["GPUTextureAspect","GPUTextureViewDimension","GPUBufferBindingType","GPUTextureSampleType","FloatType","WebGPUBindingUtils","constructor","backend","createBindingsLayout","bindings","device","entries","index","binding","bindingGPU","visibility","isUniformBuffer","isStorageBuffer","buffer","type","Storage","isSampler","sampler","texture","isDepthTexture","compareFunction","isSampledTexture","isVideoTexture","externalTexture","store","format","get","storageTexture","sampleType","Depth","isDataTexture","UnfilterableFloat","isSampledCubeTexture","viewDimension","Cube","console","error","push","createBindGroupLayout","createBindings","bindingsData","bindLayoutGPU","bindGroupGPU","createBindGroup","layout","group","updateBinding","bufferGPU","queue","writeBuffer","layoutGPU","bindingPoint","entriesGPU","bindingData","undefined","byteLength","usage","GPUBufferUsage","UNIFORM","COPY_DST","createBuffer","label","size","resource","attribute","textureGPU","textureData","dimensionViewGPU","TwoD","resourceGPU","importExternalTexture","source","aspectGPU","All","createView","aspect","dimension"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUBindingUtils.js"],"sourcesContent":["import {\n\tGPUTextureAspect, GPUTextureViewDimension, GPUBufferBindingType, GPUTextureSampleType\n} from './WebGPUConstants.js';\nimport { FloatType } from 'three';\n\nclass WebGPUBindingUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateBindingsLayout( bindings ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst entries = [];\n\n\t\tlet index = 0;\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tconst bindingGPU = {\n\t\t\t\tbinding: index ++,\n\t\t\t\tvisibility: binding.visibility\n\t\t\t};\n\n\t\t\tif ( binding.isUniformBuffer || binding.isStorageBuffer ) {\n\n\t\t\t\tconst buffer = {}; // GPUBufferBindingLayout\n\n\t\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\t\tbuffer.type = GPUBufferBindingType.Storage;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.buffer = buffer;\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst sampler = {}; // GPUSamplerBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( binding.texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tsampler.type = 'comparison';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.sampler = sampler;\n\n\t\t\t} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {\n\n\t\t\t\tbindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n\n\t\t\t} else if ( binding.isSampledTexture && binding.store ) {\n\n\t\t\t\tconst format = this.backend.get( binding.texture ).texture.format;\n\n\t\t\t\tbindingGPU.storageTexture = { format }; // GPUStorageTextureBindingLayout\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texture = {}; // GPUTextureBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Depth;\n\n\t\t\t\t} else if ( binding.texture.isDataTexture && binding.texture.type === FloatType ) {\n\n\t\t\t\t\t// @TODO: Add support for this soon: backend.hasFeature( 'float32-filterable' )\n\n\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.Cube;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.texture = texture;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'WebGPUBindingUtils: Unsupported binding \"${ binding }\".' );\n\n\t\t\t}\n\n\t\t\tentries.push( bindingGPU );\n\n\t\t}\n\n\t\treturn device.createBindGroupLayout( { entries } );\n\n\t}\n\n\tcreateBindings( bindings ) {\n\n\t\tconst backend = this.backend;\n\t\tconst bindingsData = backend.get( bindings );\n\n\t\t// setup (static) binding layout and (dynamic) binding group\n\n\t\tconst bindLayoutGPU = this.createBindingsLayout( bindings );\n\t\tconst bindGroupGPU = this.createBindGroup( bindings, bindLayoutGPU );\n\n\t\tbindingsData.layout = bindLayoutGPU;\n\t\tbindingsData.group = bindGroupGPU;\n\t\tbindingsData.bindings = bindings;\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = binding.buffer;\n\t\tconst bufferGPU = backend.get( binding ).buffer;\n\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\n\n\t}\n\n\tcreateBindGroup( bindings, layoutGPU ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tlet bindingPoint = 0;\n\t\tconst entriesGPU = [];\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst byteLength = binding.byteLength;\n\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\n\t\t\t\t\t\tlabel: 'bindingBuffer',\n\t\t\t\t\t\tsize: byteLength,\n\t\t\t\t\t\tusage: usage\n\t\t\t\t\t} );\n\n\t\t\t\t\tbindingData.buffer = bufferGPU;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst textureData = backend.get( binding.texture );\n\n\t\t\t\tlet dimensionViewGPU;\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\n\n\t\t\t\t}\n\n\t\t\t\tlet resourceGPU;\n\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\n\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\n\n\t\t\t\t\tresourceGPU = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU } );\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\n\n\t\t\t}\n\n\t\t\tbindingPoint ++;\n\n\t\t}\n\n\t\treturn device.createBindGroup( {\n\t\t\tlayout: layoutGPU,\n\t\t\tentries: entriesGPU\n\t\t} );\n\n\t}\n\n}\n\nexport default WebGPUBindingUtils;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}