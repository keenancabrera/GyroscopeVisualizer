{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nconst _withScopeId = n => (_pushScopeId(\"data-v-68d5cb0f\"), n = n(), _popScopeId(), n);\nconst _hoisted_1 = {\n  ref: \"sceneContainer\",\n  class: \"scene-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, null, 512 /* NEED_PATCH */);\n}","map":{"version":3,"names":["ref","class","_createElementBlock","_hoisted_1"],"sources":["/Users/cabrera/Documents/PortfolioWebiste/frontend/src/components/gyroscopeSimulator.vue"],"sourcesContent":["<template>\n  <div ref=\"sceneContainer\" class=\"scene-container\"></div>\n</template>\n\n<script>\nimport * as THREE from '../../node_modules/three';\nimport { gyroscopeAnimation } from '@/gyroscopeRenderer/gyroscopeAnimation';\n\nexport default {\n  name: 'gyroscopeSimulator',\n  props: {\n    solution: Object\n  },\n  watch: {\n    $props: {\n      handler() {\n        this.animate();\n      },\n      deep: true\n    },\n  },\n  data() {\n    return {\n      L: 5,\n      a: 1,\n      h: 0.25,\n      theta: Math.PI/4,\n      phi: Math.PI/4,\n      psi: Math.PI/4,\n      x: null,\n      y: null,\n      z: null,\n      linePoints: [],\n      verticies: new Float32Array([0,0,0,0,0,0]),\n      gyroscopeAnimation: null\n    }\n  },\n  methods: {\n    cylinderPosition(theta, phi){\n      this.x = this.L * Math.cos(theta) * Math.sin(phi)\n      this.y = this.L * Math.sin(theta) * Math.sin(phi)\n      this.z = this.L * Math.cos(phi)\n    },\n    updateStateVariables(i){ // i is index or solution\n      this.theta = this.solution.theta[i]\n      this.phi = this.solution.phi[i]\n      this.psi = this.solution.psi[i]\n\n      this.x = this.L * Math.cos(this.theta) * Math.sin(this.phi)\n      this.y = this.L * Math.sin(this.theta) * Math.sin(this.phi)\n      this.z = this.L * Math.cos(this.phi)\n    },\n    animate(){\n      // Initialize the Three.js scene\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(\n      75,\n      this.$el.clientWidth / this.$el.clientHeight,\n      0.1,\n      1000\n    );\n    camera.up.set(0,0,1) // Set up to be z axis\n\n    const renderer = new THREE.WebGLRenderer();\n    renderer.setSize(this.$el.clientWidth, this.$el.clientHeight);\n    this.$refs.sceneContainer.appendChild(renderer.domElement);\n\n    // Axes Helper\n    // X RED | Y GREEN | Z BLUE |\n    const axesHelper = new THREE.AxesHelper(this.L*2)\n\n    // Cylinder to the scene\n    const geometryCylinder = new THREE.CylinderGeometry(this.a, this.a, this.h, 32 ); \n    // const materialCylinder = new THREE.MeshBasicMaterial({ color: \"red\", wireframe: true });\n    // const materialCylinder2 = new THREE.MeshBasicMaterial({ color: \"blue\", wireframe: true });\n\n    const cylinder = new THREE.Mesh(geometryCylinder, [new THREE.MeshPhongMaterial({ color: 'blue', shininess: 200 }),new THREE.MeshPhongMaterial({ color: 'red', shininess: 200 })]);\n    cylinder.rotation.set(Math.PI/2,0,0)\n    cylinder.position.set(0,0,this.L)\n\n    // Rod to the scene\n    const materialLine = new THREE.LineBasicMaterial( { color: 'white' } );\n    const geometryLine = new THREE.BufferGeometry()\n\n    const line = new THREE.Line( geometryLine, materialLine );\n\n    // Light\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 1)\n    directionalLight.position.z = this.L*1\n\n\n    scene.add(cylinder, axesHelper, line, directionalLight);\n\n\n    // const material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); \n    // const cylinder = new THREE.Mesh( geometry, material ); \n    // scene.add(cylinder);\n\n    camera.position.x = this.L * 1.2\n    camera.position.y = this.L * 1.2\n    camera.position.z = this.L * 1.2\n    camera.lookAt(0,0,0)\n    // Render loop\n\n    let i = 0\n    let oldSoln = new THREE.Vector3(0,0,this.L)\n    const animate = () => {\n      requestAnimationFrame(animate);\n      \n\n      this.updateStateVariables(i)\n      // this.updateStateVariables(i/5 % 150)\n      cylinder.position.set(this.x, this.y, this.z)\n      // cylinder.rotation.set(Math.PI / 2, this.phi, this.theta)\n\n\n      this.verticies[3] = this.x * 1.5\n      this.verticies[4] = this.y * 1.5\n      this.verticies[5] = this.z * 1.5\n      geometryLine.setAttribute('position', new THREE.BufferAttribute(this.verticies, 3))      \n\n\n      let currentSoln = new THREE.Vector3(this.x, this.y, this.z)\n      let angle = oldSoln.angleTo(currentSoln)\n      let difference = currentSoln.clone().add(oldSoln.multiplyScalar(-1))\n      let rotationVector = new THREE.Vector3().crossVectors(difference, oldSoln)\n\n      cylinder.rotateOnWorldAxis(rotationVector.normalize(), angle)\n\n      i = (i + 1)\n      renderer.render(scene, camera);\n      oldSoln.set(this.x, this.y, this.z)\n    };\n\n    animate();\n    }\n  },\n  mounted() {\n    this.gyroscopeAnimation = new gyroscopeAnimation(this.$refs.sceneContainer)\n  },\n};\n</script>\n\n<style scoped>\n.scene-container {\n  width: 100%;\n  height: 95vh;\n}\n</style>\n"],"mappings":";;;EACOA,GAAG,EAAC,gBAAgB;EAACC,KAAK,EAAC;;;uBAAhCC,mBAAA,CAAwD,OAAxDC,UAAwD"},"metadata":{},"sourceType":"module","externalDependencies":[]}