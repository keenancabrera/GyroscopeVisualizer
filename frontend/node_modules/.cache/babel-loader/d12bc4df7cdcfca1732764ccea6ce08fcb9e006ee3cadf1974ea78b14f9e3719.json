{"ast":null,"code":"import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { context } from '../core/ContextNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nclass TextureNode extends UniformNode {\n  constructor(value, uvNode = null, levelNode = null, compareNode = null) {\n    super(value);\n    this.isTextureNode = true;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this.compareNode = compareNode;\n    this.updateMatrix = false;\n    this.updateType = NodeUpdateType.NONE;\n    this.setUpdateMatrix(uvNode === null);\n  }\n  getUniformHash( /*builder*/\n  ) {\n    return this.value.uuid;\n  }\n  getNodeType( /*builder*/\n  ) {\n    if (this.value.isDepthTexture === true) return 'float';\n    return 'vec4';\n  }\n  getInputType( /*builder*/\n  ) {\n    return 'texture';\n  }\n  getDefaultUV() {\n    return uv(this.value.channel);\n  }\n  updateReference( /*frame*/\n  ) {\n    return this.value;\n  }\n  getTransformedUV(uvNode) {\n    const texture = this.value;\n    return uniform(texture.matrix).mul(vec3(uvNode, 1)).xy;\n  }\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n    return this;\n  }\n  setup(builder) {\n    const properties = builder.getNodeProperties(this);\n\n    //\n\n    let uvNode = this.uvNode;\n    if (uvNode === null && builder.context.getUVNode) {\n      uvNode = builder.context.getUVNode(this);\n    }\n    if (!uvNode) uvNode = this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = this.getTransformedUV(uvNode);\n    }\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getSamplerLevelNode) {\n      levelNode = builder.context.getSamplerLevelNode(this);\n    }\n\n    //\n\n    properties.uvNode = uvNode;\n    properties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode(this, levelNode) : null;\n  }\n  generate(builder, output) {\n    const {\n      uvNode,\n      levelNode\n    } = builder.getNodeProperties(this);\n    const compareNode = this.compareNode;\n    const texture = this.value;\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n    const textureProperty = super.generate(builder, 'property');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeType = this.getNodeType(builder);\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const uvSnippet = uvNode.build(builder, 'vec2');\n        const nodeVar = builder.getVarFromNode(this, nodeType);\n        propertyName = builder.getPropertyName(nodeVar);\n        let snippet = null;\n        if (levelNode && levelNode.isNode === true) {\n          const levelSnippet = levelNode.build(builder, 'float');\n          snippet = builder.getTextureLevel(texture, textureProperty, uvSnippet, levelSnippet);\n        } else if (compareNode !== null) {\n          const compareSnippet = compareNode.build(builder, 'float');\n          snippet = builder.getTextureCompare(texture, textureProperty, uvSnippet, compareSnippet);\n        } else {\n          snippet = builder.getTexture(texture, textureProperty, uvSnippet);\n        }\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`);\n        if (builder.context.tempWrite !== false) {\n          nodeData.snippet = snippet;\n          nodeData.propertyName = propertyName;\n        }\n      }\n      let snippet = propertyName;\n      if (builder.needsColorSpaceToLinear(this.value)) {\n        snippet = colorSpaceToLinear(expression(snippet, nodeType), this.value.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, nodeType, output);\n    }\n  }\n  uv(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = uvNode;\n    return nodeObject(textureNode);\n  }\n  level(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = levelNode;\n    return context(textureNode, {\n      getMIPLevelAlgorithmNode: (textureNode, levelNode) => levelNode\n    });\n  }\n  size(levelNode) {\n    return textureSize(this, levelNode);\n  }\n  compare(compareNode) {\n    const textureNode = this.clone();\n    textureNode.compareNode = nodeObject(compareNode);\n    return nodeObject(textureNode);\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  }\n  update() {\n    const texture = this.value;\n    if (texture.matrixAutoUpdate === true) {\n      texture.updateMatrix();\n    }\n  }\n  clone() {\n    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);\n  }\n}\nexport default TextureNode;\nexport const texture = nodeProxy(TextureNode);\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = aTexture => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\naddNodeElement('texture', texture);\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass('TextureNode', TextureNode);","map":{"version":3,"names":["UniformNode","uniform","uv","textureSize","colorSpaceToLinear","context","expression","addNodeClass","addNodeElement","nodeProxy","vec3","nodeObject","NodeUpdateType","TextureNode","constructor","value","uvNode","levelNode","compareNode","isTextureNode","updateMatrix","updateType","NONE","setUpdateMatrix","getUniformHash","uuid","getNodeType","isDepthTexture","getInputType","getDefaultUV","channel","updateReference","getTransformedUV","texture","matrix","mul","xy","FRAME","setup","builder","properties","getNodeProperties","getUVNode","getSamplerLevelNode","getMIPLevelAlgorithmNode","generate","output","isTexture","Error","textureProperty","isReference","nodeType","nodeData","getDataFromNode","propertyName","undefined","uvSnippet","build","nodeVar","getVarFromNode","getPropertyName","snippet","isNode","levelSnippet","getTextureLevel","compareSnippet","getTextureCompare","getTexture","addLineFlowCode","tempWrite","needsColorSpaceToLinear","colorSpace","format","textureNode","clone","level","size","compare","serialize","data","toJSON","meta","deserialize","textures","update","matrixAutoUpdate","sampler","aTexture","convert"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/accessors/TextureNode.js"],"sourcesContent":["import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { context } from '../core/ContextNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass TextureNode extends UniformNode {\n\n\tconstructor( value, uvNode = null, levelNode = null, compareNode = null ) {\n\n\t\tsuper( value );\n\n\t\tthis.isTextureNode = true;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\t\tthis.compareNode = compareNode;\n\n\t\tthis.updateMatrix = false;\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\treturn 'vec4';\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\tupdateReference( /*frame*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\tgetTransformedUV( uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\treturn uniform( texture.matrix ).mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUVNode ) {\n\n\t\t\tuvNode = builder.context.getUVNode( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getSamplerLevelNode ) {\n\n\t\t\tlevelNode = builder.context.getSamplerLevelNode( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode( this, levelNode ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { uvNode, levelNode } = builder.getNodeProperties( this );\n\n\t\tconst compareNode = this.compareNode;\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst uvSnippet = uvNode.build( builder, 'vec2' );\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, nodeType );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tlet snippet = null;\n\n\t\t\t\tif ( levelNode && levelNode.isNode === true ) {\n\n\t\t\t\t\tconst levelSnippet = levelNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getTextureLevel( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t\t\t} else if ( compareNode !== null ) {\n\n\t\t\t\t\tconst compareSnippet = compareNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getTextureCompare( texture, textureProperty, uvSnippet, compareSnippet );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = builder.getTexture( texture, textureProperty, uvSnippet );\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tif ( builder.context.tempWrite !== false ) {\n\n\t\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\n\t\t\tif ( builder.needsColorSpaceToLinear( this.value ) ) {\n\n\t\t\t\tsnippet = colorSpaceToLinear( expression( snippet, nodeType ), this.value.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\tuv( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = uvNode;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = levelNode;\n\n\t\treturn context( textureNode, {\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => levelNode\n\t\t} );\n\n\t}\n\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.value, this.uvNode, this.levelNode, this.compareNode );\n\n\t}\n\n}\n\nexport default TextureNode;\n\nexport const texture = nodeProxy( TextureNode );\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\naddNodeElement( 'texture', texture );\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass( 'TextureNode', TextureNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}