{"ast":null,"code":"import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { temp } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor } from '../accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { abs, mix, mod, dot, clamp, smoothstep } from '../math/MathNode.js';\nimport { tslFn, ShaderNode, float, vec2, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth } from '../accessors/LineMaterialNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { dashSize, gapSize } from '../core/PropertyNode.js';\nimport { LineDashedMaterial } from 'three';\nconst defaultValues = new LineDashedMaterial();\nclass Line2NodeMaterial extends NodeMaterial {\n  constructor(params = {}) {\n    super();\n    this.normals = false;\n    this.lights = false;\n    this.setDefaultValues(defaultValues);\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.useDash = params.dashed;\n    this.useWorldUnits = false;\n    this.dashOffset = 0;\n    this.lineWidth = 1;\n    this.lineColorNode = null;\n    this.offsetNode = null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    this.gapSizeNode = null;\n    this.setupShaders();\n    this.setValues(params);\n  }\n  setupShaders() {\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    const useDash = this.dashed;\n    const useWorldUnits = this.worldUnits;\n    const trimSegment = tslFn(({\n      start,\n      end\n    }) => {\n      const a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column\n      const b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column\n      const nearEstimate = b.mul(-0.5).div(a);\n      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));\n      return vec4(mix(start.xyz, end.xyz, alpha), end.w);\n    });\n    this.vertexNode = new ShaderNode(stack => {\n      stack.assign(varying(vec2(), 'vUv'), uv());\n      const instanceStart = attribute('instanceStart');\n      const instanceEnd = attribute('instanceEnd');\n\n      // camera space\n\n      const start = property('vec4', 'start');\n      const end = property('vec4', 'end');\n      stack.assign(start, modelViewMatrix.mul(vec4(instanceStart, 1.0))); // force assignment into correct place in flow\n      stack.assign(end, modelViewMatrix.mul(vec4(instanceEnd, 1.0)));\n      if (useWorldUnits) {\n        stack.assign(varying(vec3(), 'worldStart'), start.xyz);\n        stack.assign(varying(vec3(), 'worldEnd'), end.xyz);\n      }\n      const aspect = viewport.z.div(viewport.w);\n\n      // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n      // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n      // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n      // perhaps there is a more elegant solution -- WestLangley\n\n      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column\n\n      stack.if(perspective, stack => {\n        stack.if(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), stack => {\n          stack.assign(end, trimSegment({\n            start: start,\n            end: end\n          }));\n        }).elseif(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), stack => {\n          stack.assign(start, trimSegment({\n            start: end,\n            end: start\n          }));\n        });\n      });\n\n      // clip space\n      const clipStart = cameraProjectionMatrix.mul(start);\n      const clipEnd = cameraProjectionMatrix.mul(end);\n\n      // ndc space\n      const ndcStart = clipStart.xyz.div(clipStart.w);\n      const ndcEnd = clipEnd.xyz.div(clipEnd.w);\n\n      // direction\n      const dir = ndcEnd.xy.sub(ndcStart.xy);\n\n      // account for clip-space aspect ratio\n      stack.assign(dir.x, dir.x.mul(aspect));\n      stack.assign(dir, dir.normalize());\n      const clip = temp(vec4());\n      if (useWorldUnits) {\n        // get the offset direction as perpendicular to the view vector\n        const worldDir = end.xyz.sub(start.xyz).normalize();\n        const offset = positionGeometry.y.lessThan(0.5).cond(start.xyz.cross(worldDir).normalize(), end.xyz.cross(worldDir).normalize());\n\n        // sign flip\n        stack.assign(offset, positionGeometry.x.lessThan(0.0).cond(offset.negate(), offset));\n        const forwardOffset = worldDir.dot(vec3(0.0, 0.0, 1.0));\n\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        if (!useDash) {\n          // extend the line bounds to encompass endcaps\n          stack.assign(start, start.sub(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));\n          stack.assign(end, end.add(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));\n\n          // shift the position of the quad so it hugs the forward edge of the line\n          stack.assign(offset, offset.sub(vec3(dir.mul(forwardOffset), 0)));\n          stack.assign(offset.z, offset.z.add(0.5));\n        }\n\n        // endcaps\n\n        stack.if(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), stack => {\n          stack.assign(offset, offset.add(vec3(dir.mul(2.0).mul(forwardOffset), 0)));\n        });\n\n        // adjust for linewidth\n        stack.assign(offset, offset.mul(materialLineWidth).mul(0.5));\n\n        // set the world position\n\n        const worldPos = varying(vec4(), 'worldPos');\n        stack.assign(worldPos, positionGeometry.y.lessThan(0.5).cond(start, end));\n        stack.assign(worldPos, worldPos.add(vec4(offset, 0)));\n\n        // project the worldpos\n        stack.assign(clip, cameraProjectionMatrix.mul(worldPos));\n\n        // shift the depth of the projected points so the line\n        // segments overlap neatly\n        const clipPose = temp(vec3());\n        stack.assign(clipPose, positionGeometry.y.lessThan(0.5).cond(ndcStart, ndcEnd));\n        stack.assign(clip.z, clipPose.z.mul(clip.w));\n      } else {\n        const offset = property('vec2', 'offset');\n        stack.assign(offset, vec2(dir.y, dir.x.negate()));\n\n        // undo aspect ratio adjustment\n        stack.assign(dir.x, dir.x.div(aspect));\n        stack.assign(offset.x, offset.x.div(aspect));\n\n        // sign flip\n        stack.assign(offset, positionGeometry.x.lessThan(0.0).cond(offset.negate(), offset));\n\n        // endcaps\n        stack.if(positionGeometry.y.lessThan(0.0), stack => {\n          stack.assign(offset, offset.sub(dir));\n        }).elseif(positionGeometry.y.greaterThan(1.0), stack => {\n          stack.assign(offset, offset.add(dir));\n        });\n\n        // adjust for linewidth\n        stack.assign(offset, offset.mul(materialLineWidth));\n\n        // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n        stack.assign(offset, offset.div(viewport.w));\n\n        // select end\n        stack.assign(clip, positionGeometry.y.lessThan(0.5).cond(clipStart, clipEnd));\n\n        // back to clip space\n        stack.assign(offset, offset.mul(clip.w));\n        stack.assign(clip, clip.add(vec4(offset, 0, 0)));\n      }\n      return clip;\n    });\n    const closestLineToLine = tslFn(({\n      p1,\n      p2,\n      p3,\n      p4\n    }) => {\n      const p13 = p1.sub(p3);\n      const p43 = p4.sub(p3);\n      const p21 = p2.sub(p1);\n      const d1343 = dot(p13, p43);\n      const d4321 = dot(p43, p21);\n      const d1321 = dot(p13, p21);\n      const d4343 = dot(p43, p43);\n      const d2121 = dot(p21, p21);\n      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));\n      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));\n      const mua = clamp(numer.div(denom), 0, 1);\n      const mub = clamp(d1343.add(d4321.mul(mua)).div(d4343), 0, 1);\n      return vec2(mua, mub);\n    });\n    this.colorNode = new ShaderNode(stack => {\n      const vUv = varying(vec2(), 'vUv');\n      if (useDash) {\n        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;\n        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n        stack.assign(dashSize, dashSizeNode);\n        stack.assign(gapSize, gapSizeNode);\n        const instanceDistanceStart = attribute('instanceDistanceStart');\n        const instanceDistanceEnd = attribute('instanceDistanceEnd');\n        const lineDistance = positionGeometry.y.lessThan(0.5).cond(dashScaleNode.mul(instanceDistanceStart), materialLineScale.mul(instanceDistanceEnd));\n        const vLineDistance = varying(lineDistance.add(materialLineDashOffset));\n        const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;\n        stack.add(vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard()); // discard endcaps\n        stack.add(mod(vLineDistanceOffset, dashSize.add(gapSize)).greaterThan(dashSize).discard()); // todo - FIX\n      }\n\n      // force assignment into correct place in flow\n      const alpha = property('float', 'alpha');\n      stack.assign(alpha, 1);\n      if (useWorldUnits) {\n        let worldStart = varying(vec3(), 'worldStart');\n        let worldEnd = varying(vec3(), 'worldEnd');\n\n        // Find the closest points on the view ray and the line segment\n        const rayEnd = varying(vec4(), 'worldPos').xyz.normalize().mul(1e5);\n        const lineDir = worldEnd.sub(worldStart);\n        const params = closestLineToLine({\n          p1: worldStart,\n          p2: worldEnd,\n          p3: vec3(0.0, 0.0, 0.0),\n          p4: rayEnd\n        });\n        const p1 = worldStart.add(lineDir.mul(params.x));\n        const p2 = rayEnd.mul(params.y);\n        const delta = p1.sub(p2);\n        const len = delta.length();\n        const norm = len.div(materialLineWidth);\n        if (!useDash) {\n          if (useAlphaToCoverage) {\n            const dnorm = norm.fwidth();\n            stack.assign(alpha, smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());\n          } else {\n            stack.add(norm.greaterThan(0.5).discard());\n          }\n        }\n      } else {\n        // round endcaps\n\n        if (useAlphaToCoverage) {\n          const a = vUv.x;\n          const b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n          const len2 = a.mul(a).add(b.mul(b));\n\n          // force assignment out of following 'if' statement - to avoid uniform control flow errors\n          const dlen = property('float', 'dlen');\n          stack.assign(dlen, len2.fwidth());\n          stack.if(abs(vUv.y).greaterThan(1.0), stack => {\n            stack.assign(alpha, smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n          });\n        } else {\n          stack.if(abs(vUv.y).greaterThan(1.0), stack => {\n            const a = vUv.x;\n            const b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n            const len2 = a.mul(a).add(b.mul(b));\n            stack.add(len2.greaterThan(1.0).discard());\n          });\n        }\n      }\n      let lineColorNode;\n      if (this.lineColorNode) {\n        lineColorNode = this.lineColorNode;\n      } else {\n        if (useColor) {\n          const instanceColorStart = attribute('instanceColorStart');\n          const instanceColorEnd = attribute('instanceColorEnd');\n          lineColorNode = varying(positionGeometry.y.lessThan(0.5).cond(instanceColorStart, instanceColorEnd));\n        } else {\n          lineColorNode = materialColor;\n        }\n      }\n      return vec4(lineColorNode, alpha);\n    });\n    this.needsUpdate = true;\n  }\n  get worldUnits() {\n    return this.useWorldUnits;\n  }\n  set worldUnits(value) {\n    if (this.useWorldUnits !== value) {\n      this.useWorldUnits = value;\n      this.setupShaders();\n    }\n  }\n  get dashed() {\n    return this.useDash;\n  }\n  set dashed(value) {\n    if (this.useDash !== value) {\n      this.useDash = value;\n      this.setupShaders();\n    }\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.setupShaders();\n    }\n  }\n}\nexport default Line2NodeMaterial;\naddNodeMaterial('Line2NodeMaterial', Line2NodeMaterial);","map":{"version":3,"names":["NodeMaterial","addNodeMaterial","temp","varying","property","attribute","cameraProjectionMatrix","materialColor","modelViewMatrix","positionGeometry","abs","mix","mod","dot","clamp","smoothstep","tslFn","ShaderNode","float","vec2","vec3","vec4","uv","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineDashOffset","materialLineWidth","viewport","dashSize","gapSize","LineDashedMaterial","defaultValues","Line2NodeMaterial","constructor","params","normals","lights","setDefaultValues","useAlphaToCoverage","useColor","vertexColors","useDash","dashed","useWorldUnits","dashOffset","lineWidth","lineColorNode","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","setupShaders","setValues","alphaToCoverage","worldUnits","trimSegment","start","end","a","element","b","nearEstimate","mul","div","alpha","sub","z","xyz","w","vertexNode","stack","assign","instanceStart","instanceEnd","aspect","perspective","equal","if","lessThan","and","greaterThan","elseif","greaterThanEqual","clipStart","clipEnd","ndcStart","ndcEnd","dir","xy","x","normalize","clip","worldDir","offset","y","cond","cross","negate","forwardOffset","add","or","worldPos","clipPose","closestLineToLine","p1","p2","p3","p4","p13","p43","p21","d1343","d4321","d1321","d4343","d2121","denom","numer","mua","mub","colorNode","vUv","offsetNodeNode","dashGapNode","instanceDistanceStart","instanceDistanceEnd","lineDistance","vLineDistance","vLineDistanceOffset","discard","worldStart","worldEnd","rayEnd","lineDir","delta","len","length","norm","dnorm","fwidth","oneMinus","len2","dlen","instanceColorStart","instanceColorEnd","needsUpdate","value"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/materials/Line2NodeMaterial.js"],"sourcesContent":["import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { temp } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor } from '../accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { abs, mix, mod, dot, clamp, smoothstep } from '../math/MathNode.js';\nimport { tslFn, ShaderNode, float, vec2, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth } from '../accessors/LineMaterialNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { dashSize, gapSize } from '../core/PropertyNode.js';\n\nimport { LineDashedMaterial } from 'three';\n\nconst defaultValues = new LineDashedMaterial();\n\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.normals = false;\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.useAlphaToCoverage = true;\n\t\tthis.useColor = params.vertexColors;\n\t\tthis.useDash = params.dashed;\n\t\tthis.useWorldUnits = false;\n\n\t\tthis.dashOffset = 0;\n\t\tthis.lineWidth = 1;\n\n\t\tthis.lineColorNode = null;\n\n\t\tthis.offsetNode = null;\n\t\tthis.dashScaleNode = null;\n\t\tthis.dashSizeNode = null;\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setupShaders();\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetupShaders() {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this.dashed;\n\t\tconst useWorldUnits = this.worldUnits;\n\n\t\tconst trimSegment = tslFn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( -0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} );\n\n\t\tthis.vertexNode = new ShaderNode( ( stack ) => {\n\n\t\t\tstack.assign( varying( vec2(), 'vUv' ), uv() );\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = property( 'vec4', 'start' );\n\t\t\tconst end = property( 'vec4', 'end' );\n\n\t\t\tstack.assign( start, modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ); // force assignment into correct place in flow\n\t\t\tstack.assign( end, modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) );\n\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tstack.assign( varying( vec3(), 'worldStart' ), start.xyz );\n\t\t\t\tstack.assign( varying( vec3(), 'worldEnd' ), end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( -1.0 ); // 4th entry in the 3rd column\n\n\t\t\tstack.if( perspective, ( stack ) => {\n\n\t\t\t\tstack.if( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( end, trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).elseif( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( start, trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy );\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tstack.assign( dir.x, dir.x.mul( aspect ) );\n\t\t\tstack.assign( dir, dir.normalize() );\n\n\t\t\tconst clip = temp( vec4() );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\n\t\t\t\tconst offset = positionGeometry.y.lessThan( 0.5 ).cond(\n\t\t\t\t\tstart.xyz.cross( worldDir ).normalize(),\n\t\t\t\t\tend.xyz.cross( worldDir ).normalize()\n\n\t\t\t\t);\n\n\t\t\t\t// sign flip\n\t\t\t\tstack.assign( offset, positionGeometry.x.lessThan( 0.0 ).cond( offset.negate(), offset ) );\n\n\t\t\t\tconst forwardOffset = worldDir.dot( vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// extend the line bounds to encompass endcaps\n\t\t\t\t\tstack.assign( start, start.sub( vec4( worldDir.mul( materialLineWidth ).mul( 0.5 ), 0 ) ) );\n\t\t\t\t\tstack.assign( end, end.add( vec4( worldDir.mul( materialLineWidth ).mul( 0.5 ), 0 ) ) );\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\tstack.assign( offset, offset.sub( vec3( dir.mul( forwardOffset ), 0 ) ) );\n\t\t\t\t\tstack.assign( offset.z, offset.z.add( 0.5 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// endcaps\n\n\t\t\t\tstack.if( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( offset, offset.add( vec3( dir.mul( 2.0 ).mul( forwardOffset ), 0 ) ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\tstack.assign( offset, offset.mul( materialLineWidth ).mul( 0.5 ) );\n\n\t\t\t\t// set the world position\n\n\t\t\t\tconst worldPos = varying( vec4(), 'worldPos' );\n\n\t\t\t\tstack.assign( worldPos, positionGeometry.y.lessThan( 0.5 ).cond( start, end ) );\n\t\t\t\tstack.assign( worldPos, worldPos.add( vec4( offset, 0 ) ) );\n\n\t\t\t\t// project the worldpos\n\t\t\t\tstack.assign( clip, cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = temp( vec3() );\n\n\t\t\t\tstack.assign( clipPose, positionGeometry.y.lessThan( 0.5 ).cond( ndcStart, ndcEnd ) );\n\t\t\t\tstack.assign( clip.z, clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = property( 'vec2', 'offset' );\n\n\t\t\t\tstack.assign( offset, vec2( dir.y, dir.x.negate() ) );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tstack.assign( dir.x, dir.x.div( aspect ) );\n\t\t\t\tstack.assign( offset.x, offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\tstack.assign( offset, positionGeometry.x.lessThan( 0.0 ).cond( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tstack.if( positionGeometry.y.lessThan( 0.0 ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( offset, offset.sub( dir ) );\n\n\t\t\t\t} ).elseif( positionGeometry.y.greaterThan( 1.0 ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( offset, offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\tstack.assign( offset, offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\tstack.assign( offset, offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tstack.assign( clip, positionGeometry.y.lessThan( 0.5 ).cond( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\tstack.assign( offset, offset.mul( clip.w ) );\n\n\t\t\t\tstack.assign( clip, clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} );\n\n\t\tconst closestLineToLine = tslFn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = dot( p13, p43 );\n\t\t\tconst d4321 = dot( p43, p21 );\n\t\t\tconst d1321 = dot( p13, p21 );\n\t\t\tconst d4343 = dot( p43, p43 );\n\t\t\tconst d2121 = dot( p21, p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = clamp( numer.div( denom ), 0, 1 );\n\t\t\tconst mub = clamp( d1343.add( d4321.mul( mua ) ).div( d4343 ), 0, 1 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = new ShaderNode( ( stack ) => {\n\n\t\t\tconst vUv = varying( vec2(), 'vUv' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;\n\n\t\t\t\tstack.assign( dashSize, dashSizeNode );\n\t\t\t\tstack.assign( gapSize, gapSizeNode );\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tconst lineDistance = positionGeometry.y.lessThan( 0.5 ).cond( dashScaleNode.mul( instanceDistanceStart ), materialLineScale.mul( instanceDistanceEnd ) );\n\n\t\t\t\tconst vLineDistance = varying( lineDistance.add( materialLineDashOffset ) );\n\t\t\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\t\t\tstack.add( vUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard() ); // discard endcaps\n\t\t\t\tstack.add( mod( vLineDistanceOffset, dashSize.add( gapSize ) ).greaterThan( dashSize ).discard() ); // todo - FIX\n\n\t\t\t}\n\n\t\t\t // force assignment into correct place in flow\n\t\t\tconst alpha = property( 'float', 'alpha' );\n\t\t\tstack.assign( alpha, 1 );\n\n\t\t\tif ( useWorldUnits ) {\n\n\n\t\t\t\tlet worldStart = varying( vec3(), 'worldStart' );\n\t\t\t\tlet worldEnd = varying( vec3(), 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varying( vec4(), 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\tstack.assign( alpha, smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstack.add( norm.greaterThan( 0.5 ).discard() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).cond( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t// force assignment out of following 'if' statement - to avoid uniform control flow errors\n\t\t\t\t\tconst dlen = property( 'float', 'dlen' );\n\t\t\t\t\tstack.assign( dlen, len2.fwidth() );\n\n\t\t\t\t\tstack.if( abs( vUv.y ).greaterThan( 1.0 ), ( stack ) => {\n\n\t\t\t\t\t\tstack.assign( alpha, smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.if( abs( vUv.y ).greaterThan( 1.0 ), ( stack ) => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).cond( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tstack.add( len2.greaterThan( 1.0 ).discard() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tlineColorNode = varying( positionGeometry.y.lessThan( 0.5 ).cond( instanceColorStart, instanceColorEnd ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\n\tget worldUnits() {\n\n\t\treturn this.useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this.useWorldUnits !== value ) {\n\n\t\t\tthis.useWorldUnits = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n\n\tget dashed() {\n\n\t\treturn this.useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this.useDash !== value ) {\n\n\t\t\tthis.useDash = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n}\n\nexport default Line2NodeMaterial;\n\naddNodeMaterial( 'Line2NodeMaterial', Line2NodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}