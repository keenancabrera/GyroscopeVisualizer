{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Animation from './Animation.js';\nimport RenderObjects from './RenderObjects.js';\nimport Attributes from './Attributes.js';\nimport Geometries from './Geometries.js';\nimport Info from './Info.js';\nimport Pipelines from './Pipelines.js';\nimport Bindings from './Bindings.js';\nimport RenderLists from './RenderLists.js';\nimport RenderContexts from './RenderContexts.js';\nimport Textures from './Textures.js';\nimport Background from './Background.js';\nimport Nodes from './nodes/Nodes.js';\nimport { Scene, Frustum, Matrix4, Vector2, Vector3, Vector4, Color, DoubleSide, BackSide, FrontSide, SRGBColorSpace, NoToneMapping } from 'three';\nconst _scene = new Scene();\nconst _drawingBufferSize = new Vector2();\nconst _screen = new Vector4();\nconst _frustum = new Frustum();\nconst _projScreenMatrix = new Matrix4();\nconst _vector3 = new Vector3();\nclass Renderer {\n  constructor(backend) {\n    this.isRenderer = true;\n\n    // public\n\n    this.domElement = backend.getDomElement();\n    this.backend = backend;\n    this.autoClear = true;\n    this.autoClearColor = true;\n    this.autoClearDepth = true;\n    this.autoClearStencil = true;\n    this.outputColorSpace = SRGBColorSpace;\n    this.toneMapping = NoToneMapping;\n    this.toneMappingExposure = 1.0;\n    this.sortObjects = true;\n    this.depth = true;\n    this.stencil = true;\n    this.info = new Info();\n\n    // internals\n\n    this._pixelRatio = 1;\n    this._width = this.domElement.width;\n    this._height = this.domElement.height;\n    this._viewport = new Vector4(0, 0, this._width, this._height);\n    this._scissor = new Vector4(0, 0, this._width, this._height);\n    this._scissorTest = false;\n    this._properties = null;\n    this._attributes = null;\n    this._geometries = null;\n    this._nodes = null;\n    this._bindings = null;\n    this._objects = null;\n    this._pipelines = null;\n    this._renderLists = null;\n    this._renderContexts = null;\n    this._textures = null;\n    this._background = null;\n    this._animation = new Animation();\n    this._currentRenderContext = null;\n    this._lastRenderContext = null;\n    this._opaqueSort = null;\n    this._transparentSort = null;\n    this._clearAlpha = 1;\n    this._clearColor = new Color(0x000000);\n    this._clearDepth = 1;\n    this._clearStencil = 0;\n    this._renderTarget = null;\n    this._activeCubeFace = 0;\n    this._activeMipmapLevel = 0;\n    this._initialized = false;\n    this._initPromise = null;\n\n    // backwards compatibility\n\n    this.shadowMap = {\n      enabled: false,\n      type: null\n    };\n    this.xr = {\n      enabled: false\n    };\n  }\n  async init() {\n    if (this._initialized) {\n      throw new Error('Renderer: Backend has already been initialized.');\n    }\n    if (this._initPromise !== null) {\n      return this._initPromise;\n    }\n    this._initPromise = new Promise(async (resolve, reject) => {\n      const backend = this.backend;\n      try {\n        await backend.init(this);\n      } catch (error) {\n        reject(error);\n        return;\n      }\n      this._nodes = new Nodes(this, backend);\n      this._attributes = new Attributes(backend);\n      this._background = new Background(this, this._nodes);\n      this._geometries = new Geometries(this._attributes, this.info);\n      this._textures = new Textures(backend, this.info);\n      this._pipelines = new Pipelines(backend, this._nodes);\n      this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);\n      this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);\n      this._renderLists = new RenderLists();\n      this._renderContexts = new RenderContexts();\n\n      //\n\n      this._animation.setNodes(this._nodes);\n      this._animation.start();\n      this._initialized = true;\n      resolve();\n    });\n    return this._initPromise;\n  }\n  get coordinateSystem() {\n    return this.backend.coordinateSystem;\n  }\n  async compile( /*scene, camera*/\n  ) {\n    console.warn('THREE.Renderer: .compile() is not implemented yet.');\n  }\n  async render(scene, camera) {\n    if (this._initialized === false) await this.init();\n\n    // preserve render tree\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    const previousRenderState = this._currentRenderContext;\n\n    //\n\n    const sceneRef = scene.isScene === true ? scene : _scene;\n    const renderTarget = this._renderTarget;\n    const renderContext = this._renderContexts.get(scene, camera, renderTarget);\n    const activeCubeFace = this._activeCubeFace;\n    const activeMipmapLevel = this._activeMipmapLevel;\n    this._currentRenderContext = renderContext;\n    nodeFrame.renderId++;\n\n    //\n\n    const coordinateSystem = this.coordinateSystem;\n    if (camera.coordinateSystem !== coordinateSystem) {\n      camera.coordinateSystem = coordinateSystem;\n      camera.updateProjectionMatrix();\n    }\n\n    //\n\n    if (this._animation.isAnimating === false) nodeFrame.update();\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n    if (this.info.autoReset === true) this.info.reset();\n    this.info.render.frame++;\n\n    //\n\n    let viewport = this._viewport;\n    let scissor = this._scissor;\n    let pixelRatio = this._pixelRatio;\n    if (renderTarget !== null) {\n      viewport = renderTarget.viewport;\n      scissor = renderTarget.scissor;\n      pixelRatio = 1;\n    }\n    this.getDrawingBufferSize(_drawingBufferSize);\n    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);\n    const minDepth = viewport.minDepth === undefined ? 0 : viewport.minDepth;\n    const maxDepth = viewport.maxDepth === undefined ? 1 : viewport.maxDepth;\n    renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor();\n    renderContext.viewportValue.width >>= activeMipmapLevel;\n    renderContext.viewportValue.height >>= activeMipmapLevel;\n    renderContext.viewportValue.minDepth = minDepth;\n    renderContext.viewportValue.maxDepth = maxDepth;\n    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;\n    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();\n    renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;\n    renderContext.scissorValue.width >>= activeMipmapLevel;\n    renderContext.scissorValue.height >>= activeMipmapLevel;\n    renderContext.depth = this.depth;\n    renderContext.stencil = this.stencil;\n\n    //\n\n    sceneRef.onBeforeRender(this, scene, camera, renderTarget);\n\n    //\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);\n    const renderList = this._renderLists.get(scene, camera);\n    renderList.begin();\n    this._projectObject(scene, camera, 0, renderList);\n    renderList.finish();\n    if (this.sortObjects === true) {\n      renderList.sort(this._opaqueSort, this._transparentSort);\n    }\n\n    //\n\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n      renderContext.width = renderTargetData.width;\n      renderContext.height = renderTargetData.height;\n    } else {\n      renderContext.textures = null;\n      renderContext.depthTexture = null;\n      renderContext.width = this.domElement.width;\n      renderContext.height = this.domElement.height;\n    }\n    renderContext.width >>= activeMipmapLevel;\n    renderContext.height >>= activeMipmapLevel;\n    renderContext.activeCubeFace = activeCubeFace;\n    renderContext.activeMipmapLevel = activeMipmapLevel;\n    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n    //\n\n    this._nodes.updateScene(sceneRef);\n\n    //\n\n    this._background.update(sceneRef, renderList, renderContext);\n\n    //\n\n    this.backend.beginRender(renderContext);\n\n    // process render lists\n\n    const opaqueObjects = renderList.opaque;\n    const transparentObjects = renderList.transparent;\n    const lightsNode = renderList.lightsNode;\n    if (opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n    if (transparentObjects.length > 0) this._renderObjects(transparentObjects, camera, sceneRef, lightsNode);\n\n    // finish render pass\n\n    this.backend.finishRender(renderContext);\n\n    // restore render tree\n\n    nodeFrame.renderId = previousRenderId;\n    this._currentRenderContext = previousRenderState;\n    this._lastRenderContext = renderContext;\n\n    //\n\n    sceneRef.onAfterRender(this, scene, camera, renderTarget);\n  }\n  getActiveCubeFace() {\n    return this._activeCubeFace;\n  }\n  getActiveMipmapLevel() {\n    return this._activeMipmapLevel;\n  }\n  setAnimationLoop(callback) {\n    if (this._initialized === false) this.init();\n    const animation = this._animation;\n    animation.setAnimationLoop(callback);\n    callback === null ? animation.stop() : animation.start();\n  }\n  getArrayBuffer(attribute) {\n    // @deprecated, r155\n\n    console.warn('THREE.Renderer: getArrayBuffer() is deprecated. Use getArrayBufferAsync() instead.');\n    return this.getArrayBufferAsync(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.backend.getArrayBufferAsync(attribute);\n  }\n  getContext() {\n    return this._context;\n  }\n  getPixelRatio() {\n    return this._pixelRatio;\n  }\n  getDrawingBufferSize(target) {\n    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();\n  }\n  getSize(target) {\n    return target.set(this._width, this._height);\n  }\n  setPixelRatio(value = 1) {\n    this._pixelRatio = value;\n    this.setSize(this._width, this._height, false);\n  }\n  setDrawingBufferSize(width, height, pixelRatio) {\n    this._width = width;\n    this._height = height;\n    this._pixelRatio = pixelRatio;\n    this.domElement.width = Math.floor(width * pixelRatio);\n    this.domElement.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n  setSize(width, height, updateStyle = true) {\n    this._width = width;\n    this._height = height;\n    this.domElement.width = Math.floor(width * this._pixelRatio);\n    this.domElement.height = Math.floor(height * this._pixelRatio);\n    if (updateStyle === true) {\n      this.domElement.style.width = width + 'px';\n      this.domElement.style.height = height + 'px';\n    }\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n  setOpaqueSort(method) {\n    this._opaqueSort = method;\n  }\n  setTransparentSort(method) {\n    this._transparentSort = method;\n  }\n  getScissor(target) {\n    const scissor = this._scissor;\n    target.x = scissor.x;\n    target.y = scissor.y;\n    target.width = scissor.width;\n    target.height = scissor.height;\n    return target;\n  }\n  setScissor(x, y, width, height) {\n    const scissor = this._scissor;\n    if (x.isVector4) {\n      scissor.copy(x);\n    } else {\n      scissor.set(x, y, width, height);\n    }\n  }\n  getScissorTest() {\n    return this._scissorTest;\n  }\n  setScissorTest(boolean) {\n    this._scissorTest = boolean;\n  }\n  getViewport(target) {\n    return target.copy(this._viewport);\n  }\n  setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {\n    const viewport = this._viewport;\n    if (x.isVector4) {\n      viewport.copy(x);\n    } else {\n      viewport.set(x, y, width, height);\n    }\n    viewport.minDepth = minDepth;\n    viewport.maxDepth = maxDepth;\n  }\n  getClearColor(target) {\n    return target.copy(this._clearColor);\n  }\n  setClearColor(color, alpha = 1) {\n    this._clearColor.set(color);\n    this._clearAlpha = alpha;\n  }\n  getClearAlpha() {\n    return this._clearAlpha;\n  }\n  setClearAlpha(alpha) {\n    this._clearAlpha = alpha;\n  }\n  getClearDepth() {\n    return this._clearDepth;\n  }\n  setClearDepth(depth) {\n    this._clearDepth = depth;\n  }\n  getClearStencil() {\n    return this._clearStencil;\n  }\n  setClearStencil(stencil) {\n    this._clearStencil = stencil;\n  }\n  isOccluded(object) {\n    const renderContext = this._currentRenderContext || this._lastRenderContext;\n    return renderContext && this.backend.isOccluded(renderContext, object);\n  }\n  clear(color = true, depth = true, stencil = true) {\n    const renderContext = this._currentRenderContext || this._lastRenderContext;\n    if (renderContext) this.backend.clear(renderContext, color, depth, stencil);\n  }\n  clearColor() {\n    this.clear(true, false, false);\n  }\n  clearDepth() {\n    this.clear(false, true, false);\n  }\n  clearStencil() {\n    this.clear(false, false, true);\n  }\n  dispose() {\n    this.info.dispose();\n    this._objects.dispose();\n    this._properties.dispose();\n    this._pipelines.dispose();\n    this._nodes.dispose();\n    this._bindings.dispose();\n    this._renderLists.dispose();\n    this._renderContexts.dispose();\n    this._textures.dispose();\n    this.setRenderTarget(null);\n    this.setAnimationLoop(null);\n  }\n  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n    this._renderTarget = renderTarget;\n    this._activeCubeFace = activeCubeFace;\n    this._activeMipmapLevel = activeMipmapLevel;\n  }\n  getRenderTarget() {\n    return this._renderTarget;\n  }\n  async compute(computeNodes) {\n    if (this._initialized === false) await this.init();\n    const backend = this.backend;\n    const pipelines = this._pipelines;\n    const bindings = this._bindings;\n    const nodes = this._nodes;\n    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];\n    backend.beginCompute(computeNodes);\n    for (const computeNode of computeList) {\n      // onInit\n\n      if (pipelines.has(computeNode) === false) {\n        const dispose = () => {\n          computeNode.removeEventListener('dispose', dispose);\n          pipelines.delete(computeNode);\n          bindings.delete(computeNode);\n          nodes.delete(computeNode);\n        };\n        computeNode.addEventListener('dispose', dispose);\n\n        //\n\n        computeNode.onInit({\n          renderer: this\n        });\n      }\n      nodes.updateForCompute(computeNode);\n      bindings.updateForCompute(computeNode);\n      const computeBindings = bindings.getForCompute(computeNode);\n      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);\n      backend.compute(computeNodes, computeNode, computeBindings, computePipeline);\n    }\n    backend.finishCompute(computeNodes);\n  }\n  hasFeature(name) {\n    return this.backend.hasFeature(name);\n  }\n  copyFramebufferToTexture(framebufferTexture) {\n    const renderContext = this._currentRenderContext || this._lastRenderContext;\n    this._textures.updateTexture(framebufferTexture);\n    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext);\n  }\n  readRenderTargetPixelsAsync(renderTarget, x, y, width, height) {\n    return this.backend.copyTextureToBuffer(renderTarget.texture, x, y, width, height);\n  }\n  _projectObject(object, camera, groupOrder, renderList) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        renderList.pushLight(object);\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (this.sortObjects === true) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          const geometry = object.geometry;\n          const material = object.material;\n          if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      } else if (object.isLineLoop) {\n        console.error('THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.');\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          const geometry = object.geometry;\n          const material = object.material;\n          if (this.sortObjects === true) {\n            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n            _vector3.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n              if (groupMaterial && groupMaterial.visible) {\n                renderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n              }\n            }\n          } else if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this._projectObject(children[i], camera, groupOrder, renderList);\n    }\n  }\n  _renderObjects(renderList, camera, scene, lightsNode) {\n    // process renderable objects\n\n    for (let i = 0, il = renderList.length; i < il; i++) {\n      const renderItem = renderList[i];\n\n      // @TODO: Add support for multiple materials per object. This will require to extract\n      // the material from the renderItem object and pass it with its group data to _renderObject().\n\n      const {\n        object,\n        geometry,\n        material,\n        group\n      } = renderItem;\n      if (camera.isArrayCamera) {\n        const cameras = camera.cameras;\n        for (let j = 0, jl = cameras.length; j < jl; j++) {\n          const camera2 = cameras[j];\n          if (object.layers.test(camera2.layers)) {\n            const vp = camera2.viewport;\n            const minDepth = vp.minDepth === undefined ? 0 : vp.minDepth;\n            const maxDepth = vp.maxDepth === undefined ? 1 : vp.maxDepth;\n            const viewportValue = this._currentRenderContext.viewportValue;\n            viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();\n            viewportValue.minDepth = minDepth;\n            viewportValue.maxDepth = maxDepth;\n            this.backend.updateViewport(this._currentRenderContext);\n            this._renderObject(object, scene, camera2, geometry, material, group, lightsNode);\n          }\n        }\n      } else {\n        this._renderObject(object, scene, camera, geometry, material, group, lightsNode);\n      }\n    }\n  }\n  _renderObject(object, scene, camera, geometry, material, group, lightsNode) {\n    material = scene.overrideMaterial !== null ? scene.overrideMaterial : material;\n\n    //\n\n    object.onBeforeRender(this, scene, camera, geometry, material, group);\n    material.onBeforeRender(this, scene, camera, geometry, material, group);\n\n    //\n\n    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {\n      material.side = BackSide;\n      this._renderObjectDirect(object, material, scene, camera, lightsNode, 'backSide'); // create backSide pass id\n\n      material.side = FrontSide;\n      this._renderObjectDirect(object, material, scene, camera, lightsNode); // use default pass id\n\n      material.side = DoubleSide;\n    } else {\n      this._renderObjectDirect(object, material, scene, camera, lightsNode);\n    }\n\n    //\n\n    object.onAfterRender(this, scene, camera, geometry, material, group);\n  }\n  _renderObjectDirect(object, material, scene, camera, lightsNode, passId) {\n    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, passId);\n\n    //\n\n    this._nodes.updateBefore(renderObject);\n\n    //\n\n    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\n    //\n\n    this._nodes.updateForRender(renderObject);\n    this._geometries.updateForRender(renderObject);\n    this._bindings.updateForRender(renderObject);\n    this._pipelines.updateForRender(renderObject);\n\n    //\n\n    this.backend.draw(renderObject, this.info);\n  }\n}\nexport default Renderer;","map":{"version":3,"names":["Animation","RenderObjects","Attributes","Geometries","Info","Pipelines","Bindings","RenderLists","RenderContexts","Textures","Background","Nodes","Scene","Frustum","Matrix4","Vector2","Vector3","Vector4","Color","DoubleSide","BackSide","FrontSide","SRGBColorSpace","NoToneMapping","_scene","_drawingBufferSize","_screen","_frustum","_projScreenMatrix","_vector3","Renderer","constructor","backend","isRenderer","domElement","getDomElement","autoClear","autoClearColor","autoClearDepth","autoClearStencil","outputColorSpace","toneMapping","toneMappingExposure","sortObjects","depth","stencil","info","_pixelRatio","_width","width","_height","height","_viewport","_scissor","_scissorTest","_properties","_attributes","_geometries","_nodes","_bindings","_objects","_pipelines","_renderLists","_renderContexts","_textures","_background","_animation","_currentRenderContext","_lastRenderContext","_opaqueSort","_transparentSort","_clearAlpha","_clearColor","_clearDepth","_clearStencil","_renderTarget","_activeCubeFace","_activeMipmapLevel","_initialized","_initPromise","shadowMap","enabled","type","xr","init","Error","Promise","resolve","reject","error","setNodes","start","coordinateSystem","compile","console","warn","render","scene","camera","nodeFrame","previousRenderId","renderId","previousRenderState","sceneRef","isScene","renderTarget","renderContext","get","activeCubeFace","activeMipmapLevel","updateProjectionMatrix","isAnimating","update","matrixWorldAutoUpdate","updateMatrixWorld","parent","autoReset","reset","frame","viewport","scissor","pixelRatio","getDrawingBufferSize","set","minDepth","undefined","maxDepth","viewportValue","copy","multiplyScalar","floor","equals","scissorValue","onBeforeRender","multiplyMatrices","projectionMatrix","matrixWorldInverse","setFromProjectionMatrix","renderList","begin","_projectObject","finish","sort","updateRenderTarget","renderTargetData","textures","depthTexture","occlusionQueryCount","updateScene","beginRender","opaqueObjects","opaque","transparentObjects","transparent","lightsNode","length","_renderObjects","finishRender","onAfterRender","getActiveCubeFace","getActiveMipmapLevel","setAnimationLoop","callback","animation","stop","getArrayBuffer","attribute","getArrayBufferAsync","getContext","_context","getPixelRatio","target","getSize","setPixelRatio","value","setSize","setDrawingBufferSize","Math","setViewport","updateSize","updateStyle","style","setOpaqueSort","method","setTransparentSort","getScissor","x","y","setScissor","isVector4","getScissorTest","setScissorTest","boolean","getViewport","getClearColor","setClearColor","color","alpha","getClearAlpha","setClearAlpha","getClearDepth","setClearDepth","getClearStencil","setClearStencil","isOccluded","object","clear","clearColor","clearDepth","clearStencil","dispose","setRenderTarget","getRenderTarget","compute","computeNodes","pipelines","bindings","nodes","computeList","Array","isArray","beginCompute","computeNode","has","removeEventListener","delete","addEventListener","onInit","renderer","updateForCompute","computeBindings","getForCompute","computePipeline","finishCompute","hasFeature","name","copyFramebufferToTexture","framebufferTexture","updateTexture","readRenderTargetPixelsAsync","copyTextureToBuffer","texture","groupOrder","visible","layers","test","isGroup","renderOrder","isLOD","autoUpdate","isLight","pushLight","isSprite","frustumCulled","intersectsSprite","setFromMatrixPosition","matrixWorld","applyMatrix4","geometry","material","push","z","isLineLoop","isMesh","isLine","isPoints","intersectsObject","boundingSphere","computeBoundingSphere","center","groups","i","l","group","groupMaterial","materialIndex","children","il","renderItem","isArrayCamera","cameras","j","jl","camera2","vp","updateViewport","_renderObject","overrideMaterial","side","forceSinglePass","_renderObjectDirect","passId","renderObject","updateBefore","modelViewMatrix","normalMatrix","getNormalMatrix","updateForRender","draw"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/common/Renderer.js"],"sourcesContent":["import Animation from './Animation.js';\nimport RenderObjects from './RenderObjects.js';\nimport Attributes from './Attributes.js';\nimport Geometries from './Geometries.js';\nimport Info from './Info.js';\nimport Pipelines from './Pipelines.js';\nimport Bindings from './Bindings.js';\nimport RenderLists from './RenderLists.js';\nimport RenderContexts from './RenderContexts.js';\nimport Textures from './Textures.js';\nimport Background from './Background.js';\nimport Nodes from './nodes/Nodes.js';\nimport { Scene, Frustum, Matrix4, Vector2, Vector3, Vector4, Color, DoubleSide, BackSide, FrontSide, SRGBColorSpace, NoToneMapping } from 'three';\n\nconst _scene = new Scene();\nconst _drawingBufferSize = new Vector2();\nconst _screen = new Vector4();\nconst _frustum = new Frustum();\nconst _projScreenMatrix = new Matrix4();\nconst _vector3 = new Vector3();\n\nclass Renderer {\n\n\tconstructor( backend ) {\n\n\t\tthis.isRenderer = true;\n\n\t\t// public\n\n\t\tthis.domElement = backend.getDomElement();\n\n\t\tthis.backend = backend;\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\tthis.sortObjects = true;\n\n\t\tthis.depth = true;\n\t\tthis.stencil = true;\n\n\t\tthis.info = new Info();\n\n\t\t// internals\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = this.domElement.width;\n\t\tthis._height = this.domElement.height;\n\n\t\tthis._viewport = new Vector4( 0, 0, this._width, this._height );\n\t\tthis._scissor = new Vector4( 0, 0, this._width, this._height );\n\t\tthis._scissorTest = false;\n\n\t\tthis._properties = null;\n\t\tthis._attributes = null;\n\t\tthis._geometries = null;\n\t\tthis._nodes = null;\n\t\tthis._bindings = null;\n\t\tthis._objects = null;\n\t\tthis._pipelines = null;\n\t\tthis._renderLists = null;\n\t\tthis._renderContexts = null;\n\t\tthis._textures = null;\n\t\tthis._background = null;\n\n\t\tthis._animation = new Animation();\n\n\t\tthis._currentRenderContext = null;\n\t\tthis._lastRenderContext = null;\n\n\t\tthis._opaqueSort = null;\n\t\tthis._transparentSort = null;\n\n\t\tthis._clearAlpha = 1;\n\t\tthis._clearColor = new Color( 0x000000 );\n\t\tthis._clearDepth = 1;\n\t\tthis._clearStencil = 0;\n\n\t\tthis._renderTarget = null;\n\t\tthis._activeCubeFace = 0;\n\t\tthis._activeMipmapLevel = 0;\n\n\t\tthis._initialized = false;\n\t\tthis._initPromise = null;\n\n\t\t// backwards compatibility\n\n\t\tthis.shadowMap = {\n\t\t\tenabled: false,\n\t\t\ttype: null\n\t\t};\n\n\t\tthis.xr = {\n\t\t\tenabled: false\n\t\t};\n\n\t}\n\n\tasync init() {\n\n\t\tif ( this._initialized ) {\n\n\t\t\tthrow new Error( 'Renderer: Backend has already been initialized.' );\n\n\t\t}\n\n\t\tif ( this._initPromise !== null ) {\n\n\t\t\treturn this._initPromise;\n\n\t\t}\n\n\t\tthis._initPromise = new Promise( async ( resolve, reject ) => {\n\n\t\t\tconst backend = this.backend;\n\n\t\t\ttry {\n\n\t\t\t\tawait backend.init( this );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\treject( error );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis._nodes = new Nodes( this, backend );\n\t\t\tthis._attributes = new Attributes( backend );\n\t\t\tthis._background = new Background( this, this._nodes );\n\t\t\tthis._geometries = new Geometries( this._attributes, this.info );\n\t\t\tthis._textures = new Textures( backend, this.info );\n\t\t\tthis._pipelines = new Pipelines( backend, this._nodes );\n\t\t\tthis._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );\n\t\t\tthis._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );\n\t\t\tthis._renderLists = new RenderLists();\n\t\t\tthis._renderContexts = new RenderContexts();\n\n\t\t\t//\n\n\t\t\tthis._animation.setNodes( this._nodes );\n\t\t\tthis._animation.start();\n\n\t\t\tthis._initialized = true;\n\n\t\t\tresolve();\n\n\t\t} );\n\n\t\treturn this._initPromise;\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn this.backend.coordinateSystem;\n\n\t}\n\n\tasync compile( /*scene, camera*/ ) {\n\n\t\tconsole.warn( 'THREE.Renderer: .compile() is not implemented yet.' );\n\n\t}\n\n\tasync render( scene, camera ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderState = this._currentRenderContext;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tconst renderTarget = this._renderTarget;\n\t\tconst renderContext = this._renderContexts.get( scene, camera, renderTarget );\n\t\tconst activeCubeFace = this._activeCubeFace;\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\tthis._currentRenderContext = renderContext;\n\n\t\tnodeFrame.renderId ++;\n\n\t\t//\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tif ( camera.coordinateSystem !== coordinateSystem ) {\n\n\t\t\tcamera.coordinateSystem = coordinateSystem;\n\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this._animation.isAnimating === false ) nodeFrame.update();\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\tthis.info.render.frame ++;\n\n\t\t//\n\n\t\tlet viewport = this._viewport;\n\t\tlet scissor = this._scissor;\n\t\tlet pixelRatio = this._pixelRatio;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tviewport = renderTarget.viewport;\n\t\t\tscissor = renderTarget.scissor;\n\t\t\tpixelRatio = 1;\n\n\t\t}\n\n\t\tthis.getDrawingBufferSize( _drawingBufferSize );\n\n\t\t_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );\n\n\t\tconst minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;\n\t\tconst maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;\n\n\t\trenderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.viewportValue.width >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.height >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.minDepth = minDepth;\n\t\trenderContext.viewportValue.maxDepth = maxDepth;\n\t\trenderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;\n\n\t\trenderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;\n\t\trenderContext.scissorValue.width >>= activeMipmapLevel;\n\t\trenderContext.scissorValue.height >>= activeMipmapLevel;\n\n\t\trenderContext.depth = this.depth;\n\t\trenderContext.stencil = this.stencil;\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList );\n\n\t\trenderList.finish();\n\n\t\tif ( this.sortObjects === true ) {\n\n\t\t\trenderList.sort( this._opaqueSort, this._transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\t\t\trenderContext.width = this.domElement.width;\n\t\t\trenderContext.height = this.domElement.height;\n\n\t\t}\n\n\t\trenderContext.width >>= activeMipmapLevel;\n\t\trenderContext.height >>= activeMipmapLevel;\n\t\trenderContext.activeCubeFace = activeCubeFace;\n\t\trenderContext.activeMipmapLevel = activeMipmapLevel;\n\t\trenderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n\t\t//\n\n\t\tthis._nodes.updateScene( sceneRef );\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t//\n\n\t\tthis.backend.beginRender( renderContext );\n\n\t\t// process render lists\n\n\t\tconst opaqueObjects = renderList.opaque;\n\t\tconst transparentObjects = renderList.transparent;\n\t\tconst lightsNode = renderList.lightsNode;\n\n\t\tif ( opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( transparentObjects.length > 0 ) this._renderObjects( transparentObjects, camera, sceneRef, lightsNode );\n\n\t\t// finish render pass\n\n\t\tthis.backend.finishRender( renderContext );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\t\tthis._currentRenderContext = previousRenderState;\n\n\t\tthis._lastRenderContext = renderContext;\n\n\t\t//\n\n\t\tsceneRef.onAfterRender( this, scene, camera, renderTarget );\n\n\t}\n\n\tgetActiveCubeFace() {\n\n\t\treturn this._activeCubeFace;\n\n\t}\n\n\tgetActiveMipmapLevel() {\n\n\t\treturn this._activeMipmapLevel;\n\n\t}\n\n\tsetAnimationLoop( callback ) {\n\n\t\tif ( this._initialized === false ) this.init();\n\n\t\tconst animation = this._animation;\n\n\t\tanimation.setAnimationLoop( callback );\n\n\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t}\n\n\tgetArrayBuffer( attribute ) { // @deprecated, r155\n\n\t\tconsole.warn( 'THREE.Renderer: getArrayBuffer() is deprecated. Use getArrayBufferAsync() instead.' );\n\n\t\treturn this.getArrayBufferAsync( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.backend.getArrayBufferAsync( attribute );\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this._context;\n\n\t}\n\n\tgetPixelRatio() {\n\n\t\treturn this._pixelRatio;\n\n\t}\n\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn target.set( this._width, this._height );\n\n\t}\n\n\tsetPixelRatio( value = 1 ) {\n\n\t\tthis._pixelRatio = value;\n\n\t\tthis.setSize( this._width, this._height, false );\n\n\t}\n\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.domElement.width = Math.floor( width * pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.domElement.width = Math.floor( width * this._pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * this._pixelRatio );\n\n\t\tif ( updateStyle === true ) {\n\n\t\t\tthis.domElement.style.width = width + 'px';\n\t\t\tthis.domElement.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\tsetOpaqueSort( method ) {\n\n\t\tthis._opaqueSort = method;\n\n\t}\n\n\tsetTransparentSort( method ) {\n\n\t\tthis._transparentSort = method;\n\n\t}\n\n\tgetScissor( target ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\ttarget.x = scissor.x;\n\t\ttarget.y = scissor.y;\n\t\ttarget.width = scissor.width;\n\t\ttarget.height = scissor.height;\n\n\t\treturn target;\n\n\t}\n\n\tsetScissor( x, y, width, height ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tscissor.copy( x );\n\n\t\t} else {\n\n\t\t\tscissor.set( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\tgetScissorTest() {\n\n\t\treturn this._scissorTest;\n\n\t}\n\n\tsetScissorTest( boolean ) {\n\n\t\tthis._scissorTest = boolean;\n\n\t}\n\n\tgetViewport( target ) {\n\n\t\treturn target.copy( this._viewport );\n\n\t}\n\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tconst viewport = this._viewport;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tviewport.copy( x );\n\n\t\t} else {\n\n\t\t\tviewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tviewport.minDepth = minDepth;\n\t\tviewport.maxDepth = maxDepth;\n\n\t}\n\n\tgetClearColor( target ) {\n\n\t\treturn target.copy( this._clearColor );\n\n\t}\n\n\tsetClearColor( color, alpha = 1 ) {\n\n\t\tthis._clearColor.set( color );\n\t\tthis._clearAlpha = alpha;\n\n\t}\n\n\tgetClearAlpha() {\n\n\t\treturn this._clearAlpha;\n\n\t}\n\n\tsetClearAlpha( alpha ) {\n\n\t\tthis._clearAlpha = alpha;\n\n\t}\n\n\tgetClearDepth() {\n\n\t\treturn this._clearDepth;\n\n\t}\n\n\tsetClearDepth( depth ) {\n\n\t\tthis._clearDepth = depth;\n\n\t}\n\n\tgetClearStencil() {\n\n\t\treturn this._clearStencil;\n\n\t}\n\n\tsetClearStencil( stencil ) {\n\n\t\tthis._clearStencil = stencil;\n\n\t}\n\n\tisOccluded( object ) {\n\n\t\tconst renderContext = this._currentRenderContext || this._lastRenderContext;\n\n\t\treturn renderContext && this.backend.isOccluded( renderContext, object );\n\n\t}\n\n\tclear( color = true, depth = true, stencil = true ) {\n\n\t\tconst renderContext = this._currentRenderContext || this._lastRenderContext;\n\n\t\tif ( renderContext ) this.backend.clear( renderContext, color, depth, stencil );\n\n\t}\n\n\tclearColor() {\n\n\t\tthis.clear( true, false, false );\n\n\t}\n\n\tclearDepth() {\n\n\t\tthis.clear( false, true, false );\n\n\t}\n\n\tclearStencil() {\n\n\t\tthis.clear( false, false, true );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.info.dispose();\n\n\t\tthis._objects.dispose();\n\t\tthis._properties.dispose();\n\t\tthis._pipelines.dispose();\n\t\tthis._nodes.dispose();\n\t\tthis._bindings.dispose();\n\t\tthis._renderLists.dispose();\n\t\tthis._renderContexts.dispose();\n\t\tthis._textures.dispose();\n\n\t\tthis.setRenderTarget( null );\n\t\tthis.setAnimationLoop( null );\n\n\t}\n\n\tsetRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\tthis._renderTarget = renderTarget;\n\t\tthis._activeCubeFace = activeCubeFace;\n\t\tthis._activeMipmapLevel = activeMipmapLevel;\n\n\t}\n\n\tgetRenderTarget() {\n\n\t\treturn this._renderTarget;\n\n\t}\n\n\tasync compute( computeNodes ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tconst backend = this.backend;\n\t\tconst pipelines = this._pipelines;\n\t\tconst bindings = this._bindings;\n\t\tconst nodes = this._nodes;\n\t\tconst computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];\n\n\t\tbackend.beginCompute( computeNodes );\n\n\t\tfor ( const computeNode of computeList ) {\n\n\t\t\t// onInit\n\n\t\t\tif ( pipelines.has( computeNode ) === false ) {\n\n\t\t\t\tconst dispose = () => {\n\n\t\t\t\t\tcomputeNode.removeEventListener( 'dispose', dispose );\n\n\t\t\t\t\tpipelines.delete( computeNode );\n\t\t\t\t\tbindings.delete( computeNode );\n\t\t\t\t\tnodes.delete( computeNode );\n\n\t\t\t\t};\n\n\t\t\t\tcomputeNode.addEventListener( 'dispose', dispose );\n\n\t\t\t\t//\n\n\t\t\t\tcomputeNode.onInit( { renderer: this } );\n\n\t\t\t}\n\n\t\t\tnodes.updateForCompute( computeNode );\n\t\t\tbindings.updateForCompute( computeNode );\n\n\t\t\tconst computeBindings = bindings.getForCompute( computeNode );\n\t\t\tconst computePipeline = pipelines.getForCompute( computeNode, computeBindings );\n\n\t\t\tbackend.compute( computeNodes, computeNode, computeBindings, computePipeline );\n\n\t\t}\n\n\t\tbackend.finishCompute( computeNodes );\n\n\t}\n\n\thasFeature( name ) {\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\tcopyFramebufferToTexture( framebufferTexture ) {\n\n\t\tconst renderContext = this._currentRenderContext || this._lastRenderContext;\n\n\t\tthis._textures.updateTexture( framebufferTexture );\n\n\t\tthis.backend.copyFramebufferToTexture( framebufferTexture, renderContext );\n\n\t}\n\n\treadRenderTargetPixelsAsync( renderTarget, x, y, width, height ) {\n\n\t\treturn this.backend.copyTextureToBuffer( renderTarget.texture, x, y, width, height );\n\n\t}\n\n\t_projectObject( object, camera, groupOrder, renderList ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\trenderList.pushLight( object );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = object.geometry;\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\tconsole.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tconst geometry = object.geometry;\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\t\t\t_vector3\n\t\t\t\t\t\t\t.copy( geometry.boundingSphere.center )\n\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\trenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis._projectObject( children[ i ], camera, groupOrder, renderList );\n\n\t\t}\n\n\t}\n\n\t_renderObjects( renderList, camera, scene, lightsNode ) {\n\n\t\t// process renderable objects\n\n\t\tfor ( let i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t// @TODO: Add support for multiple materials per object. This will require to extract\n\t\t\t// the material from the renderItem object and pass it with its group data to _renderObject().\n\n\t\t\tconst { object, geometry, material, group } = renderItem;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tfor ( let j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tconst vp = camera2.viewport;\n\t\t\t\t\t\tconst minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;\n\t\t\t\t\t\tconst maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;\n\n\t\t\t\t\t\tconst viewportValue = this._currentRenderContext.viewportValue;\n\t\t\t\t\t\tviewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();\n\t\t\t\t\t\tviewportValue.minDepth = minDepth;\n\t\t\t\t\t\tviewportValue.maxDepth = maxDepth;\n\n\t\t\t\t\t\tthis.backend.updateViewport( this._currentRenderContext );\n\n\t\t\t\t\t\tthis._renderObject( object, scene, camera2, geometry, material, group, lightsNode );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._renderObject( object, scene, camera, geometry, material, group, lightsNode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_renderObject( object, scene, camera, geometry, material, group, lightsNode ) {\n\n\t\tmaterial = scene.overrideMaterial !== null ? scene.overrideMaterial : material;\n\n\t\t//\n\n\t\tobject.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\tmaterial.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\t//\n\n\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tthis._renderObjectDirect( object, material, scene, camera, lightsNode, 'backSide' ); // create backSide pass id\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tthis._renderObjectDirect( object, material, scene, camera, lightsNode ); // use default pass id\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\tthis._renderObjectDirect( object, material, scene, camera, lightsNode );\n\n\t\t}\n\n\t\t//\n\n\t\tobject.onAfterRender( this, scene, camera, geometry, material, group );\n\n\t}\n\n\t_renderObjectDirect( object, material, scene, camera, lightsNode, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, passId );\n\n\t\t//\n\n\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t//\n\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t//\n\n\t\tthis._nodes.updateForRender( renderObject );\n\t\tthis._geometries.updateForRender( renderObject );\n\t\tthis._bindings.updateForRender( renderObject );\n\t\tthis._pipelines.updateForRender( renderObject );\n\n\t\t//\n\n\t\tthis.backend.draw( renderObject, this.info );\n\n\t}\n\n}\n\nexport default Renderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}