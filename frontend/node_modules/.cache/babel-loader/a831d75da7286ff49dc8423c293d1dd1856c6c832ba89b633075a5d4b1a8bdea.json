{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\nimport { GPUFeatureName, GPUTextureFormat, GPULoadOp, GPUStoreOp, GPUIndexFormat, GPUTextureViewDimension } from './utils/WebGPUConstants.js';\nimport WGSLNodeBuilder from './nodes/WGSLNodeBuilder.js';\nimport Backend from '../common/Backend.js';\nimport { DepthTexture, DepthFormat, DepthStencilFormat, UnsignedInt248Type, UnsignedIntType, WebGPUCoordinateSystem } from 'three';\nimport WebGPUUtils from './utils/WebGPUUtils.js';\nimport WebGPUAttributeUtils from './utils/WebGPUAttributeUtils.js';\nimport WebGPUBindingUtils from './utils/WebGPUBindingUtils.js';\nimport WebGPUPipelineUtils from './utils/WebGPUPipelineUtils.js';\nimport WebGPUTextureUtils from './utils/WebGPUTextureUtils.js';\n\n// statics\n\nlet _staticAdapter = null;\nif (navigator.gpu !== undefined) {\n  _staticAdapter = await navigator.gpu.requestAdapter();\n}\n\n//\n\nclass WebGPUBackend extends Backend {\n  constructor(parameters = {}) {\n    super(parameters);\n\n    // some parameters require default values other than \"undefined\"\n\n    this.parameters.antialias = parameters.antialias === true;\n    if (this.parameters.antialias === true) {\n      this.parameters.sampleCount = parameters.sampleCount === undefined ? 4 : parameters.sampleCount;\n    } else {\n      this.parameters.sampleCount = 1;\n    }\n    this.parameters.requiredLimits = parameters.requiredLimits === undefined ? {} : parameters.requiredLimits;\n    this.adapter = null;\n    this.device = null;\n    this.context = null;\n    this.colorBuffer = null;\n    this.defaultDepthTexture = new DepthTexture();\n    this.defaultDepthTexture.name = 'depthBuffer';\n    this.utils = new WebGPUUtils(this);\n    this.attributeUtils = new WebGPUAttributeUtils(this);\n    this.bindingUtils = new WebGPUBindingUtils(this);\n    this.pipelineUtils = new WebGPUPipelineUtils(this);\n    this.textureUtils = new WebGPUTextureUtils(this);\n    this.occludedResolveCache = new Map();\n  }\n  async init(renderer) {\n    await super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n    const adapterOptions = {\n      powerPreference: parameters.powerPreference\n    };\n    const adapter = await navigator.gpu.requestAdapter(adapterOptions);\n    if (adapter === null) {\n      throw new Error('WebGPUBackend: Unable to create WebGPU adapter.');\n    }\n\n    // feature support\n\n    const features = Object.values(GPUFeatureName);\n    const supportedFeatures = [];\n    for (const name of features) {\n      if (adapter.features.has(name)) {\n        supportedFeatures.push(name);\n      }\n    }\n    const deviceDescriptor = {\n      requiredFeatures: supportedFeatures,\n      requiredLimits: parameters.requiredLimits\n    };\n    const device = await adapter.requestDevice(deviceDescriptor);\n    const context = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgpu');\n    this.adapter = adapter;\n    this.device = device;\n    this.context = context;\n    this.updateSize();\n  }\n  get coordinateSystem() {\n    return WebGPUCoordinateSystem;\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.attributeUtils.getArrayBufferAsync(attribute);\n  }\n  beginRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const device = this.device;\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    let occlusionQuerySet;\n    if (occlusionQueryCount > 0) {\n      if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();\n      if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n      // Get a reference to the array of objects with queries. The renderContextData property\n      // can be changed by another render pass before the buffer.mapAsyc() completes.\n      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n      //\n\n      occlusionQuerySet = device.createQuerySet({\n        type: 'occlusion',\n        count: occlusionQueryCount\n      });\n      renderContextData.occlusionQuerySet = occlusionQuerySet;\n      renderContextData.occlusionQueryIndex = 0;\n      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n      renderContextData.lastOcclusionObject = null;\n    }\n    const descriptor = {\n      colorAttachments: [{\n        view: null\n      }],\n      depthStencilAttachment: {\n        view: null\n      },\n      occlusionQuerySet\n    };\n    const colorAttachment = descriptor.colorAttachments[0];\n    const depthStencilAttachment = descriptor.depthStencilAttachment;\n    const antialias = this.parameters.antialias;\n    if (renderContext.textures !== null) {\n      const textures = renderContext.textures;\n      descriptor.colorAttachments = [];\n      const colorAttachments = descriptor.colorAttachments;\n      for (let i = 0; i < textures.length; i++) {\n        const textureData = this.get(textures[i]);\n        const textureView = textureData.texture.createView({\n          baseMipLevel: renderContext.activeMipmapLevel,\n          mipLevelCount: 1,\n          baseArrayLayer: renderContext.activeCubeFace,\n          dimension: GPUTextureViewDimension.TwoD\n        });\n        let view, resolveTarget;\n        if (textureData.msaaTexture !== undefined) {\n          view = textureData.msaaTexture.createView();\n          resolveTarget = textureView;\n        } else {\n          view = textureView;\n          resolveTarget = undefined;\n        }\n        colorAttachments.push({\n          view,\n          resolveTarget,\n          loadOp: GPULoadOp.Load,\n          storeOp: GPUStoreOp.Store\n        });\n      }\n      const depthTextureData = this.get(renderContext.depthTexture);\n      depthStencilAttachment.view = depthTextureData.texture.createView();\n      if (renderContext.stencil && renderContext.depthTexture.format === DepthFormat) {\n        renderContext.stencil = false;\n      }\n    } else {\n      if (antialias === true) {\n        colorAttachment.view = this.colorBuffer.createView();\n        colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n      } else {\n        colorAttachment.view = this.context.getCurrentTexture().createView();\n        colorAttachment.resolveTarget = undefined;\n      }\n      depthStencilAttachment.view = this._getDepthBufferGPU(renderContext).createView();\n    }\n    if (renderContext.textures !== null) {\n      const colorAttachments = descriptor.colorAttachments;\n      for (let i = 0; i < colorAttachments.length; i++) {\n        const colorAttachment = colorAttachments[i];\n        if (renderContext.clearColor) {\n          colorAttachment.clearValue = renderContext.clearColorValue;\n          colorAttachment.loadOp = GPULoadOp.Clear;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        } else {\n          colorAttachment.loadOp = GPULoadOp.Load;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        }\n      }\n    } else {\n      if (renderContext.clearColor) {\n        colorAttachment.clearValue = renderContext.clearColorValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      } else {\n        colorAttachment.loadOp = GPULoadOp.Load;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    if (renderContext.depth) {\n      if (renderContext.clearDepth) {\n        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n    if (renderContext.stencil) {\n      if (renderContext.clearStencil) {\n        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({\n      label: 'renderContext_' + renderContext.id\n    });\n    const currentPass = encoder.beginRenderPass(descriptor);\n\n    //\n\n    renderContextData.descriptor = descriptor;\n    renderContextData.encoder = encoder;\n    renderContextData.currentPass = currentPass;\n    renderContextData.currentSets = {\n      attributes: {}\n    };\n\n    //\n\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      currentPass.setScissorRect(x, renderContext.height - height - y, width, height);\n    }\n  }\n  finishRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n      renderContextData.currentPass.endOcclusionQuery();\n    }\n    renderContextData.currentPass.end();\n    if (occlusionQueryCount > 0) {\n      const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n      //\n\n      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);\n      if (queryResolveBuffer === undefined) {\n        queryResolveBuffer = this.device.createBuffer({\n          size: bufferSize,\n          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n        });\n        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);\n      }\n\n      //\n\n      const readBuffer = this.device.createBuffer({\n        size: bufferSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n      });\n\n      // two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);\n      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);\n      renderContextData.occlusionQueryBuffer = readBuffer;\n\n      //\n\n      this.resolveOccludedAsync(renderContext);\n    }\n    this.device.queue.submit([renderContextData.encoder.finish()]);\n\n    //\n\n    if (renderContext.textures !== null) {\n      const textures = renderContext.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        if (texture.generateMipmaps === true) {\n          this.textureUtils.generateMipmaps(texture);\n        }\n      }\n    }\n  }\n  isOccluded(renderContext, object) {\n    const renderContextData = this.get(renderContext);\n    return renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n  async resolveOccludedAsync(renderContext) {\n    const renderContextData = this.get(renderContext);\n\n    // handle occlusion query results\n\n    const {\n      currentOcclusionQueryBuffer,\n      currentOcclusionQueryObjects\n    } = renderContextData;\n    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {\n      const occluded = new WeakSet();\n      renderContextData.currentOcclusionQueryObjects = null;\n      renderContextData.currentOcclusionQueryBuffer = null;\n      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);\n      const buffer = currentOcclusionQueryBuffer.getMappedRange();\n      const results = new BigUint64Array(buffer);\n      for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {\n        if (results[i] !== 0n) {\n          occluded.add(currentOcclusionQueryObjects[i]);\n        }\n      }\n      currentOcclusionQueryBuffer.destroy();\n      renderContextData.occluded = occluded;\n    }\n  }\n  updateViewport(renderContext) {\n    const {\n      currentPass\n    } = this.get(renderContext);\n    let {\n      x,\n      y,\n      width,\n      height,\n      minDepth,\n      maxDepth\n    } = renderContext.viewportValue;\n    currentPass.setViewport(x, renderContext.height - height - y, width, height, minDepth, maxDepth);\n  }\n  clear(renderContext, color, depth, stencil) {\n    const device = this.device;\n    const renderContextData = this.get(renderContext);\n    const {\n      descriptor\n    } = renderContextData;\n    depth = depth && renderContext.depth;\n    stencil = stencil && renderContext.stencil;\n    const colorAttachment = descriptor.colorAttachments[0];\n    const depthStencilAttachment = descriptor.depthStencilAttachment;\n    const antialias = this.parameters.antialias;\n\n    // @TODO: Include render target in clear operation.\n    if (antialias === true) {\n      colorAttachment.view = this.colorBuffer.createView();\n      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n    } else {\n      colorAttachment.view = this.context.getCurrentTexture().createView();\n      colorAttachment.resolveTarget = undefined;\n    }\n    descriptor.depthStencilAttachment.view = this._getDepthBufferGPU(renderContext).createView();\n    if (color) {\n      colorAttachment.loadOp = GPULoadOp.Clear;\n      colorAttachment.clearValue = renderContext.clearColorValue;\n    } else {\n      colorAttachment.loadOp = GPULoadOp.Load;\n    }\n    if (depth) {\n      depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n      depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n    } else {\n      depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n    }\n    if (stencil) {\n      depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n      depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n    } else {\n      depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n    }\n    renderContextData.encoder = device.createCommandEncoder({});\n    renderContextData.currentPass = renderContextData.encoder.beginRenderPass(descriptor);\n    renderContextData.currentPass.end();\n    device.queue.submit([renderContextData.encoder.finish()]);\n  }\n\n  // compute\n\n  beginCompute(computeGroup) {\n    const groupGPU = this.get(computeGroup);\n    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({});\n    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass();\n  }\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      passEncoderGPU\n    } = this.get(computeGroup);\n\n    // pipeline\n\n    const pipelineGPU = this.get(pipeline).pipeline;\n    passEncoderGPU.setPipeline(pipelineGPU);\n\n    // bind group\n\n    const bindGroupGPU = this.get(bindings).group;\n    passEncoderGPU.setBindGroup(0, bindGroupGPU);\n    passEncoderGPU.dispatchWorkgroups(computeNode.dispatchCount);\n  }\n  finishCompute(computeGroup) {\n    const groupData = this.get(computeGroup);\n    groupData.passEncoderGPU.end();\n    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);\n  }\n\n  // render object\n\n  draw(renderObject, info) {\n    const {\n      object,\n      geometry,\n      context,\n      pipeline\n    } = renderObject;\n    const bindingsData = this.get(renderObject.getBindings());\n    const contextData = this.get(context);\n    const pipelineGPU = this.get(pipeline).pipeline;\n    const currentSets = contextData.currentSets;\n\n    // pipeline\n\n    const passEncoderGPU = contextData.currentPass;\n    if (currentSets.pipeline !== pipelineGPU) {\n      passEncoderGPU.setPipeline(pipelineGPU);\n      currentSets.pipeline = pipelineGPU;\n    }\n\n    // bind group\n\n    const bindGroupGPU = bindingsData.group;\n    passEncoderGPU.setBindGroup(0, bindGroupGPU);\n\n    // attributes\n\n    const index = renderObject.getIndex();\n    const hasIndex = index !== null;\n\n    // index\n\n    if (hasIndex === true) {\n      if (currentSets.index !== index) {\n        const buffer = this.get(index).buffer;\n        const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n        passEncoderGPU.setIndexBuffer(buffer, indexFormat);\n        currentSets.index = index;\n      }\n    }\n\n    // vertex buffers\n\n    const vertexBuffers = renderObject.getVertexBuffers();\n    for (let i = 0, l = vertexBuffers.length; i < l; i++) {\n      const vertexBuffer = vertexBuffers[i];\n      if (currentSets.attributes[i] !== vertexBuffer) {\n        const buffer = this.get(vertexBuffer).buffer;\n        passEncoderGPU.setVertexBuffer(i, buffer);\n        currentSets.attributes[i] = vertexBuffer;\n      }\n    }\n\n    // occlusion queries - handle multiple consecutive draw calls for an object\n\n    if (contextData.occlusionQuerySet !== undefined) {\n      const lastObject = contextData.lastOcclusionObject;\n      if (lastObject !== object) {\n        if (lastObject !== null && lastObject.occlusionTest === true) {\n          passEncoderGPU.endOcclusionQuery();\n          contextData.occlusionQueryIndex++;\n        }\n        if (object.occlusionTest === true) {\n          passEncoderGPU.beginOcclusionQuery(contextData.occlusionQueryIndex);\n          contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;\n        }\n        contextData.lastOcclusionObject = object;\n      }\n    }\n\n    // draw\n\n    const drawRange = geometry.drawRange;\n    const firstVertex = drawRange.start;\n    const instanceCount = this.getInstanceCount(renderObject);\n    if (instanceCount === 0) return;\n    if (hasIndex === true) {\n      const indexCount = drawRange.count !== Infinity ? drawRange.count : index.count;\n      passEncoderGPU.drawIndexed(indexCount, instanceCount, firstVertex, 0, 0);\n      info.update(object, indexCount, instanceCount);\n    } else {\n      const positionAttribute = geometry.attributes.position;\n      const vertexCount = drawRange.count !== Infinity ? drawRange.count : positionAttribute.count;\n      passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);\n      info.update(object, vertexCount, instanceCount);\n    }\n  }\n\n  // cache key\n\n  needsUpdate(renderObject) {\n    const renderObjectGPU = this.get(renderObject);\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const sampleCount = utils.getSampleCount(renderObject.context);\n    const colorSpace = utils.getCurrentColorSpace(renderObject.context);\n    const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const primitiveTopology = utils.getPrimitiveTopology(object, material);\n    let needsUpdate = false;\n    if (renderObjectGPU.sampleCount !== sampleCount || renderObjectGPU.colorSpace !== colorSpace || renderObjectGPU.colorFormat !== colorFormat || renderObjectGPU.depthStencilFormat !== depthStencilFormat || renderObjectGPU.primitiveTopology !== primitiveTopology) {\n      renderObjectGPU.sampleCount = sampleCount;\n      renderObjectGPU.colorSpace = colorSpace;\n      renderObjectGPU.colorFormat = colorFormat;\n      renderObjectGPU.depthStencilFormat = depthStencilFormat;\n      renderObjectGPU.primitiveTopology = primitiveTopology;\n      needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n  getCacheKey(renderObject) {\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const renderContext = renderObject.context;\n    return [utils.getSampleCount(renderContext), utils.getCurrentColorSpace(renderContext), utils.getCurrentColorFormat(renderContext), utils.getCurrentDepthStencilFormat(renderContext), utils.getPrimitiveTopology(object, material)].join();\n  }\n\n  // textures\n\n  createSampler(texture) {\n    this.textureUtils.createSampler(texture);\n  }\n  destroySampler(texture) {\n    this.textureUtils.destroySampler(texture);\n  }\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n  createTexture(texture, options) {\n    this.textureUtils.createTexture(texture, options);\n  }\n  updateTexture(texture, options) {\n    this.textureUtils.updateTexture(texture, options);\n  }\n  generateMipmaps(texture) {\n    this.textureUtils.generateMipmaps(texture);\n  }\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n  copyTextureToBuffer(texture, x, y, width, height) {\n    return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height);\n  }\n\n  // node builder\n\n  createNodeBuilder(object, renderer, scene = null) {\n    return new WGSLNodeBuilder(object, renderer, scene);\n  }\n\n  // program\n\n  createProgram(program) {\n    const programGPU = this.get(program);\n    programGPU.module = {\n      module: this.device.createShaderModule({\n        code: program.code,\n        label: program.stage\n      }),\n      entryPoint: 'main'\n    };\n  }\n  destroyProgram(program) {\n    this.delete(program);\n  }\n\n  // pipelines\n\n  createRenderPipeline(renderObject) {\n    this.pipelineUtils.createRenderPipeline(renderObject);\n  }\n  createComputePipeline(computePipeline, bindings) {\n    this.pipelineUtils.createComputePipeline(computePipeline, bindings);\n  }\n\n  // bindings\n\n  createBindings(bindings) {\n    this.bindingUtils.createBindings(bindings);\n  }\n  updateBindings(bindings) {\n    this.bindingUtils.createBindings(bindings);\n  }\n  updateBinding(binding) {\n    this.bindingUtils.updateBinding(binding);\n  }\n\n  // attributes\n\n  createIndexAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n\n  // canvas\n\n  updateSize() {\n    this._configureContext();\n    this._setupColorBuffer();\n  }\n\n  // utils public\n\n  hasFeature(name) {\n    const adapter = this.adapter || _staticAdapter;\n\n    //\n\n    const features = Object.values(GPUFeatureName);\n    if (features.includes(name) === false) {\n      throw new Error('THREE.WebGPURenderer: Unknown WebGPU GPU feature: ' + name);\n    }\n\n    //\n\n    return adapter.features.has(name);\n  }\n  copyFramebufferToTexture(texture, renderContext) {\n    const renderContextData = this.get(renderContext);\n    const {\n      encoder,\n      descriptor\n    } = renderContextData;\n    let sourceGPU = null;\n    if (texture.isFramebufferTexture) {\n      sourceGPU = this.context.getCurrentTexture();\n    } else if (texture.isDepthTexture) {\n      sourceGPU = this._getDepthBufferGPU(renderContext);\n    }\n    const destinationGPU = this.get(texture).texture;\n    renderContextData.currentPass.end();\n    encoder.copyTextureToTexture({\n      texture: sourceGPU,\n      origin: {\n        x: 0,\n        y: 0,\n        z: 0\n      }\n    }, {\n      texture: destinationGPU\n    }, [texture.image.width, texture.image.height]);\n    if (texture.generateMipmaps) this.textureUtils.generateMipmaps(texture);\n    descriptor.colorAttachments[0].loadOp = GPULoadOp.Load;\n    if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n    if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n    renderContextData.currentPass = encoder.beginRenderPass(descriptor);\n    renderContextData.currentSets = {\n      attributes: {}\n    };\n  }\n\n  // utils\n\n  _getDepthBufferGPU(renderContext) {\n    const {\n      width,\n      height\n    } = this.getDrawingBufferSize();\n    const depthTexture = this.defaultDepthTexture;\n    const depthTextureGPU = this.get(depthTexture).texture;\n    let format, type;\n    if (renderContext.stencil) {\n      format = DepthStencilFormat;\n      type = UnsignedInt248Type;\n    } else if (renderContext.depth) {\n      format = DepthFormat;\n      type = UnsignedIntType;\n    }\n    if (depthTextureGPU !== undefined) {\n      if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type) {\n        return depthTextureGPU;\n      }\n      this.textureUtils.destroyTexture(depthTexture);\n    }\n    depthTexture.name = 'depthBuffer';\n    depthTexture.format = format;\n    depthTexture.type = type;\n    depthTexture.image.width = width;\n    depthTexture.image.height = height;\n    this.textureUtils.createTexture(depthTexture, {\n      sampleCount: this.parameters.sampleCount,\n      width,\n      height\n    });\n    return this.get(depthTexture).texture;\n  }\n  _configureContext() {\n    this.context.configure({\n      device: this.device,\n      format: GPUTextureFormat.BGRA8Unorm,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      alphaMode: 'premultiplied'\n    });\n  }\n  _setupColorBuffer() {\n    if (this.colorBuffer) this.colorBuffer.destroy();\n    const {\n      width,\n      height\n    } = this.getDrawingBufferSize();\n    //const format = navigator.gpu.getPreferredCanvasFormat(); // @TODO: Move to WebGPUUtils\n\n    this.colorBuffer = this.device.createTexture({\n      label: 'colorBuffer',\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: 1\n      },\n      sampleCount: this.parameters.sampleCount,\n      format: GPUTextureFormat.BGRA8Unorm,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n  }\n}\nexport default WebGPUBackend;","map":{"version":3,"names":["GPUFeatureName","GPUTextureFormat","GPULoadOp","GPUStoreOp","GPUIndexFormat","GPUTextureViewDimension","WGSLNodeBuilder","Backend","DepthTexture","DepthFormat","DepthStencilFormat","UnsignedInt248Type","UnsignedIntType","WebGPUCoordinateSystem","WebGPUUtils","WebGPUAttributeUtils","WebGPUBindingUtils","WebGPUPipelineUtils","WebGPUTextureUtils","_staticAdapter","navigator","gpu","undefined","requestAdapter","WebGPUBackend","constructor","parameters","antialias","sampleCount","requiredLimits","adapter","device","context","colorBuffer","defaultDepthTexture","name","utils","attributeUtils","bindingUtils","pipelineUtils","textureUtils","occludedResolveCache","Map","init","renderer","adapterOptions","powerPreference","Error","features","Object","values","supportedFeatures","has","push","deviceDescriptor","requiredFeatures","requestDevice","domElement","getContext","updateSize","coordinateSystem","getArrayBufferAsync","attribute","beginRender","renderContext","renderContextData","get","occlusionQueryCount","occlusionQuerySet","currentOcclusionQuerySet","destroy","currentOcclusionQueryBuffer","occlusionQueryBuffer","currentOcclusionQueryObjects","occlusionQueryObjects","createQuerySet","type","count","occlusionQueryIndex","Array","lastOcclusionObject","descriptor","colorAttachments","view","depthStencilAttachment","colorAttachment","textures","i","length","textureData","textureView","texture","createView","baseMipLevel","activeMipmapLevel","mipLevelCount","baseArrayLayer","activeCubeFace","dimension","TwoD","resolveTarget","msaaTexture","loadOp","Load","storeOp","Store","depthTextureData","depthTexture","stencil","format","getCurrentTexture","_getDepthBufferGPU","clearColor","clearValue","clearColorValue","Clear","depth","clearDepth","depthClearValue","clearDepthValue","depthLoadOp","depthStoreOp","clearStencil","stencilClearValue","clearStencilValue","stencilLoadOp","stencilStoreOp","encoder","createCommandEncoder","label","id","currentPass","beginRenderPass","currentSets","attributes","viewport","updateViewport","scissor","x","y","width","height","scissorValue","setScissorRect","finishRender","endOcclusionQuery","end","bufferSize","queryResolveBuffer","createBuffer","size","usage","GPUBufferUsage","QUERY_RESOLVE","COPY_SRC","set","readBuffer","COPY_DST","MAP_READ","resolveQuerySet","copyBufferToBuffer","resolveOccludedAsync","queue","submit","finish","generateMipmaps","isOccluded","object","occluded","WeakSet","mapAsync","GPUMapMode","READ","buffer","getMappedRange","results","BigUint64Array","add","minDepth","maxDepth","viewportValue","setViewport","clear","color","beginCompute","computeGroup","groupGPU","cmdEncoderGPU","passEncoderGPU","beginComputePass","compute","computeNode","bindings","pipeline","pipelineGPU","setPipeline","bindGroupGPU","group","setBindGroup","dispatchWorkgroups","dispatchCount","finishCompute","groupData","draw","renderObject","info","geometry","bindingsData","getBindings","contextData","index","getIndex","hasIndex","indexFormat","array","Uint16Array","Uint16","Uint32","setIndexBuffer","vertexBuffers","getVertexBuffers","l","vertexBuffer","setVertexBuffer","lastObject","occlusionTest","beginOcclusionQuery","drawRange","firstVertex","start","instanceCount","getInstanceCount","indexCount","Infinity","drawIndexed","update","positionAttribute","position","vertexCount","needsUpdate","renderObjectGPU","material","getSampleCount","colorSpace","getCurrentColorSpace","colorFormat","getCurrentColorFormat","depthStencilFormat","getCurrentDepthStencilFormat","primitiveTopology","getPrimitiveTopology","getCacheKey","join","createSampler","destroySampler","createDefaultTexture","createTexture","options","updateTexture","destroyTexture","copyTextureToBuffer","createNodeBuilder","scene","createProgram","program","programGPU","module","createShaderModule","code","stage","entryPoint","destroyProgram","delete","createRenderPipeline","createComputePipeline","computePipeline","createBindings","updateBindings","updateBinding","binding","createIndexAttribute","createAttribute","INDEX","VERTEX","createStorageAttribute","STORAGE","updateAttribute","destroyAttribute","_configureContext","_setupColorBuffer","hasFeature","includes","copyFramebufferToTexture","sourceGPU","isFramebufferTexture","isDepthTexture","destinationGPU","copyTextureToTexture","origin","z","image","getDrawingBufferSize","depthTextureGPU","configure","BGRA8Unorm","GPUTextureUsage","RENDER_ATTACHMENT","alphaMode","depthOrArrayLayers"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/webgpu/WebGPUBackend.js"],"sourcesContent":["/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\nimport { GPUFeatureName, GPUTextureFormat, GPULoadOp, GPUStoreOp, GPUIndexFormat, GPUTextureViewDimension } from './utils/WebGPUConstants.js';\n\nimport WGSLNodeBuilder from './nodes/WGSLNodeBuilder.js';\nimport Backend from '../common/Backend.js';\n\nimport { DepthTexture, DepthFormat, DepthStencilFormat, UnsignedInt248Type, UnsignedIntType, WebGPUCoordinateSystem } from 'three';\n\nimport WebGPUUtils from './utils/WebGPUUtils.js';\nimport WebGPUAttributeUtils from './utils/WebGPUAttributeUtils.js';\nimport WebGPUBindingUtils from './utils/WebGPUBindingUtils.js';\nimport WebGPUPipelineUtils from './utils/WebGPUPipelineUtils.js';\nimport WebGPUTextureUtils from './utils/WebGPUTextureUtils.js';\n\n// statics\n\nlet _staticAdapter = null;\n\nif ( navigator.gpu !== undefined ) {\n\n\t_staticAdapter = await navigator.gpu.requestAdapter();\n\n}\n\n//\n\nclass WebGPUBackend extends Backend {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t// some parameters require default values other than \"undefined\"\n\n\t\tthis.parameters.antialias = ( parameters.antialias === true );\n\n\t\tif ( this.parameters.antialias === true ) {\n\n\t\t\tthis.parameters.sampleCount = ( parameters.sampleCount === undefined ) ? 4 : parameters.sampleCount;\n\n\t\t} else {\n\n\t\t\tthis.parameters.sampleCount = 1;\n\n\t\t}\n\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\n\n\t\tthis.adapter = null;\n\t\tthis.device = null;\n\t\tthis.context = null;\n\t\tthis.colorBuffer = null;\n\n\t\tthis.defaultDepthTexture = new DepthTexture();\n\t\tthis.defaultDepthTexture.name = 'depthBuffer';\n\n\t\tthis.utils = new WebGPUUtils( this );\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\n\t\tthis.occludedResolveCache = new Map();\n\n\t}\n\n\tasync init( renderer ) {\n\n\t\tawait super.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\tconst adapterOptions = {\n\t\t\tpowerPreference: parameters.powerPreference\n\t\t};\n\n\t\tconst adapter = await navigator.gpu.requestAdapter( adapterOptions );\n\n\t\tif ( adapter === null ) {\n\n\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\n\n\t\t}\n\n\t\t// feature support\n\n\t\tconst features = Object.values( GPUFeatureName );\n\n\t\tconst supportedFeatures = [];\n\n\t\tfor ( const name of features ) {\n\n\t\t\tif ( adapter.features.has( name ) ) {\n\n\t\t\t\tsupportedFeatures.push( name );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst deviceDescriptor = {\n\t\t\trequiredFeatures: supportedFeatures,\n\t\t\trequiredLimits: parameters.requiredLimits\n\t\t};\n\n\t\tconst device = await adapter.requestDevice( deviceDescriptor );\n\n\t\tconst context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );\n\n\t\tthis.adapter = adapter;\n\t\tthis.device = device;\n\t\tthis.context = context;\n\n\t\tthis.updateSize();\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGPUCoordinateSystem;\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\tbeginRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst device = this.device;\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tlet occlusionQuerySet;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();\n\t\t\tif ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the buffer.mapAsyc() completes.\n\t\t\trenderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\t//\n\n\t\t\tocclusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount } );\n\n\t\t\trenderContextData.occlusionQuerySet = occlusionQuerySet;\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\n\t\t}\n\n\t\tconst descriptor = {\n\t\t\tcolorAttachments: [ {\n\t\t\t\tview: null\n\t\t\t} ],\n\t\t\tdepthStencilAttachment: {\n\t\t\t\tview: null\n\t\t\t},\n\t\t\tocclusionQuerySet\n\t\t};\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tconst antialias = this.parameters.antialias;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tdescriptor.colorAttachments = [];\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst textureData = this.get( textures[ i ] );\n\n\t\t\t\tconst textureView = textureData.texture.createView( {\n\t\t\t\t\tbaseMipLevel: renderContext.activeMipmapLevel,\n\t\t\t\t\tmipLevelCount: 1,\n\t\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\n\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t} );\n\n\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tview = textureView;\n\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttachments.push( {\n\t\t\t\t\tview,\n\t\t\t\t\tresolveTarget,\n\t\t\t\t\tloadOp: GPULoadOp.Load,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\n\t\t\tdepthStencilAttachment.view = depthTextureData.texture.createView();\n\n\t\t\tif ( renderContext.stencil && renderContext.depthTexture.format === DepthFormat ) {\n\n\t\t\t\trenderContext.stencil = false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( antialias === true ) {\n\n\t\t\t\tcolorAttachment.view = this.colorBuffer.createView();\n\t\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t\t}\n\n\t\t\tdepthStencilAttachment.view = this._getDepthBufferGPU( renderContext ).createView();\n\n\t\t}\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < colorAttachments.length; i ++ ) {\n\n\t\t\t\tconst colorAttachment = colorAttachments[ i ];\n\n\t\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderContext.depth ) {\n\n\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t\tif ( renderContext.clearStencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\n\t\tconst currentPass = encoder.beginRenderPass( descriptor );\n\n\t\t//\n\n\t\trenderContextData.descriptor = descriptor;\n\t\trenderContextData.encoder = encoder;\n\t\trenderContextData.currentPass = currentPass;\n\t\trenderContextData.currentSets = { attributes: {} };\n\n\t\t//\n\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tcurrentPass.setScissorRect( x, renderContext.height - height - y, width, height );\n\n\t\t}\n\n\t}\n\n\tfinishRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\n\t\t}\n\n\t\trenderContextData.currentPass.end();\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tconst bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n\t\t\t//\n\n\t\t\tlet queryResolveBuffer = this.occludedResolveCache.get( bufferSize );\n\n\t\t\tif ( queryResolveBuffer === undefined ) {\n\n\t\t\t\tqueryResolveBuffer = this.device.createBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.occludedResolveCache.set( bufferSize, queryResolveBuffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst readBuffer = this.device.createBuffer(\n\t\t\t\t{\n\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n\t\t\trenderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );\n\t\t\trenderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );\n\n\t\t\trenderContextData.occlusionQueryBuffer = readBuffer;\n\n\t\t\t//\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\t\t//\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps === true ) {\n\n\t\t\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\tasync resolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = null;\n\n\t\t\tawait currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );\n\n\t\t\tconst buffer = currentOcclusionQueryBuffer.getMappedRange();\n\t\t\tconst results = new BigUint64Array( buffer );\n\n\t\t\tfor ( let i = 0; i < currentOcclusionQueryObjects.length; i++ ) {\n\n\t\t\t\tif ( results[ i ] !== 0n ) {\n\n\t\t\t\t\toccluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentOcclusionQueryBuffer.destroy();\n\n\t\t\trenderContextData.occluded = occluded;\n\n\t\t}\n\n\t}\n\n\tupdateViewport( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tlet { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\n\t\tcurrentPass.setViewport( x, renderContext.height - height - y, width, height, minDepth, maxDepth );\n\n\t}\n\n\tclear( renderContext, color, depth, stencil ) {\n\n\t\tconst device = this.device;\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst { descriptor } = renderContextData;\n\n\t\tdepth = depth && renderContext.depth;\n\t\tstencil = stencil && renderContext.stencil;\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tconst antialias = this.parameters.antialias;\n\n\t\t// @TODO: Include render target in clear operation.\n\t\tif ( antialias === true ) {\n\n\t\t\tcolorAttachment.view = this.colorBuffer.createView();\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t} else {\n\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t}\n\n\t\tdescriptor.depthStencilAttachment.view = this._getDepthBufferGPU( renderContext ).createView();\n\n\t\tif ( color ) {\n\n\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\n\t\t} else {\n\n\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\n\t\t}\n\n\t\tif ( depth ) {\n\n\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\n\t\t} else {\n\n\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\n\t\t}\n\n\t\tif ( stencil ) {\n\n\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\n\t\t} else {\n\n\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t}\n\n\t\trenderContextData.encoder = device.createCommandEncoder( {} );\n\t\trenderContextData.currentPass = renderContextData.encoder.beginRenderPass( descriptor );\n\n\t\trenderContextData.currentPass.end();\n\n\t\tdevice.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\t}\n\n\t// compute\n\n\tbeginCompute( computeGroup ) {\n\n\t\tconst groupGPU = this.get( computeGroup );\n\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder( {} );\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass();\n\n\t}\n\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\n\n\t\t// pipeline\n\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t// bind group\n\n\t\tconst bindGroupGPU = this.get( bindings ).group;\n\t\tpassEncoderGPU.setBindGroup( 0, bindGroupGPU );\n\n\t\tpassEncoderGPU.dispatchWorkgroups( computeNode.dispatchCount );\n\n\t}\n\n\tfinishCompute( computeGroup ) {\n\n\t\tconst groupData = this.get( computeGroup );\n\n\t\tgroupData.passEncoderGPU.end();\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\n\n\t}\n\n\t// render object\n\n\tdraw( renderObject, info ) {\n\n\t\tconst { object, geometry, context, pipeline } = renderObject;\n\n\t\tconst bindingsData = this.get( renderObject.getBindings() );\n\t\tconst contextData = this.get( context );\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tconst currentSets = contextData.currentSets;\n\n\t\t// pipeline\n\n\t\tconst passEncoderGPU = contextData.currentPass;\n\n\t\tif ( currentSets.pipeline !== pipelineGPU ) {\n\n\t\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t\tcurrentSets.pipeline = pipelineGPU;\n\n\t\t}\n\n\t\t// bind group\n\n\t\tconst bindGroupGPU = bindingsData.group;\n\t\tpassEncoderGPU.setBindGroup( 0, bindGroupGPU );\n\n\t\t// attributes\n\n\t\tconst index = renderObject.getIndex();\n\n\t\tconst hasIndex = ( index !== null );\n\n\t\t// index\n\n\t\tif ( hasIndex === true ) {\n\n\t\t\tif ( currentSets.index !== index ) {\n\n\t\t\t\tconst buffer = this.get( index ).buffer;\n\t\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\n\n\t\t\t\tcurrentSets.index = index;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = renderObject.getVertexBuffers();\n\n\t\tfor ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {\n\n\t\t\tconst vertexBuffer = vertexBuffers[ i ];\n\n\t\t\tif ( currentSets.attributes[ i ] !== vertexBuffer ) {\n\n\t\t\t\tconst buffer = this.get( vertexBuffer ).buffer;\n\t\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\n\n\t\t\t\tcurrentSets.attributes[ i ] = vertexBuffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// occlusion queries - handle multiple consecutive draw calls for an object\n\n\t\tif ( contextData.occlusionQuerySet !== undefined  ) {\n\n\t\t\tconst lastObject = contextData.lastOcclusionObject;\n\n\t\t\tif ( lastObject !== object ) {\n\n\t\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.endOcclusionQuery();\n\t\t\t\t\tcontextData.occlusionQueryIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.beginOcclusionQuery( contextData.occlusionQueryIndex );\n\t\t\t\t\tcontextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;\n\n\t\t\t\t}\n\n\t\t\t\tcontextData.lastOcclusionObject = object;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// draw\n\n\t\tconst drawRange = geometry.drawRange;\n\t\tconst firstVertex = drawRange.start;\n\n\t\tconst instanceCount = this.getInstanceCount( renderObject );\n\t\tif ( instanceCount === 0 ) return;\n\n\t\tif ( hasIndex === true ) {\n\n\t\t\tconst indexCount = ( drawRange.count !== Infinity ) ? drawRange.count : index.count;\n\n\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstVertex, 0, 0 );\n\n\t\t\tinfo.update( object, indexCount, instanceCount );\n\n\t\t} else {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst vertexCount = ( drawRange.count !== Infinity ) ? drawRange.count : positionAttribute.count;\n\n\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\n\n\t\t\tinfo.update( object, vertexCount, instanceCount );\n\n\t\t}\n\n\t}\n\n\t// cache key\n\n\tneedsUpdate( renderObject ) {\n\n\t\tconst renderObjectGPU = this.get( renderObject );\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\n\t\tconst sampleCount = utils.getSampleCount( renderObject.context );\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderObjectGPU.sampleCount !== sampleCount || renderObjectGPU.colorSpace !== colorSpace ||\n\t\t\trenderObjectGPU.colorFormat !== colorFormat || renderObjectGPU.depthStencilFormat !== depthStencilFormat ||\n            renderObjectGPU.primitiveTopology !== primitiveTopology ) {\n\n\t\t\trenderObjectGPU.sampleCount = sampleCount;\n\t\t\trenderObjectGPU.colorSpace = colorSpace;\n\t\t\trenderObjectGPU.colorFormat = colorFormat;\n\t\t\trenderObjectGPU.depthStencilFormat = depthStencilFormat;\n\t\t\trenderObjectGPU.primitiveTopology = primitiveTopology;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate;\n\n\t}\n\n\tgetCacheKey( renderObject ) {\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\t\tconst renderContext = renderObject.context;\n\n\t\treturn [\n\t\t\tutils.getSampleCount( renderContext ),\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\n\t\t\tutils.getPrimitiveTopology( object, material )\n\t\t].join();\n\n\t}\n\n\t// textures\n\n\tcreateSampler( texture ) {\n\n\t\tthis.textureUtils.createSampler( texture );\n\n\t}\n\n\tdestroySampler( texture ) {\n\n\t\tthis.textureUtils.destroySampler( texture );\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\tcopyTextureToBuffer( texture, x, y, width, height ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height );\n\n\t}\n\n\t// node builder\n\n\tcreateNodeBuilder( object, renderer, scene = null ) {\n\n\t\treturn new WGSLNodeBuilder( object, renderer, scene );\n\n\t}\n\n\t// program\n\n\tcreateProgram( program ) {\n\n\t\tconst programGPU = this.get( program );\n\n\t\tprogramGPU.module = {\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage } ),\n\t\t\tentryPoint: 'main'\n\t\t};\n\n\t}\n\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t// pipelines\n\n\tcreateRenderPipeline( renderObject ) {\n\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject );\n\n\t}\n\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline, bindings );\n\n\t}\n\n\t// bindings\n\n\tcreateBindings( bindings ) {\n\n\t\tthis.bindingUtils.createBindings( bindings );\n\n\t}\n\n\tupdateBindings( bindings ) {\n\n\t\tthis.bindingUtils.createBindings( bindings );\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tthis.bindingUtils.updateBinding( binding );\n\n\t}\n\n\t// attributes\n\n\tcreateIndexAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t// canvas\n\n\tupdateSize() {\n\n\t\tthis._configureContext();\n\t\tthis._setupColorBuffer();\n\n\t}\n\n\t// utils public\n\n\thasFeature( name ) {\n\n\t\tconst adapter = this.adapter || _staticAdapter;\n\n\t\t//\n\n\t\tconst features = Object.values( GPUFeatureName );\n\n\t\tif ( features.includes( name ) === false ) {\n\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Unknown WebGPU GPU feature: ' + name );\n\n\t\t}\n\n\t\t//\n\n\t\treturn adapter.features.has( name );\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst { encoder, descriptor } = renderContextData;\n\n\t\tlet sourceGPU = null;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tsourceGPU = this.context.getCurrentTexture();\n\n\t\t} else if ( texture.isDepthTexture ) {\n\n\t\t\tsourceGPU = this._getDepthBufferGPU( renderContext );\n\n\t\t}\n\n\t\tconst destinationGPU = this.get( texture ).texture;\n\n\t\trenderContextData.currentPass.end();\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\torigin: { x: 0, y: 0, z: 0 }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU\n\t\t\t},\n\t\t\t[\n\t\t\t\ttexture.image.width,\n\t\t\t\ttexture.image.height\n\t\t\t]\n\t\t);\n\n\t\tif ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );\n\n\t\tdescriptor.colorAttachments[ 0 ].loadOp = GPULoadOp.Load;\n\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\n\t\trenderContextData.currentSets = { attributes: {} };\n\n\t}\n\n\t// utils\n\n\t_getDepthBufferGPU( renderContext ) {\n\n\t\tconst { width, height } = this.getDrawingBufferSize();\n\n\t\tconst depthTexture = this.defaultDepthTexture;\n\t\tconst depthTextureGPU = this.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( renderContext.depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.textureUtils.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\n\t\tthis.textureUtils.createTexture( depthTexture, { sampleCount: this.parameters.sampleCount, width, height } );\n\n\t\treturn this.get( depthTexture ).texture;\n\n\t}\n\n\t_configureContext() {\n\n\t\tthis.context.configure( {\n\t\t\tdevice: this.device,\n\t\t\tformat: GPUTextureFormat.BGRA8Unorm,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n\t\t\talphaMode: 'premultiplied'\n\t\t} );\n\n\t}\n\n\t_setupColorBuffer() {\n\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\n\n\t\tconst { width, height } = this.getDrawingBufferSize();\n\t\t//const format = navigator.gpu.getPreferredCanvasFormat(); // @TODO: Move to WebGPUUtils\n\n\t\tthis.colorBuffer = this.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: this.parameters.sampleCount,\n\t\t\tformat: GPUTextureFormat.BGRA8Unorm,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t}\n\n}\n\nexport default WebGPUBackend;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}