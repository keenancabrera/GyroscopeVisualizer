{"ast":null,"code":"import TextureNode from './TextureNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { reflectVector } from './ReflectVectorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeElement, nodeProxy, vec3 } from '../shadernode/ShaderNode.js';\nclass CubeTextureNode extends TextureNode {\n  constructor(value, uvNode = null, levelNode = null) {\n    super(value, uvNode, levelNode);\n    this.isCubeTextureNode = true;\n  }\n  getInputType( /*builder*/\n  ) {\n    return 'cubeTexture';\n  }\n  getDefaultUV() {\n    return reflectVector;\n  }\n  setUpdateMatrix( /*updateMatrix*/) {} // Ignore .updateMatrix for CubeTextureNode\n\n  generate(builder, output) {\n    const {\n      uvNode,\n      levelNode\n    } = builder.getNodeProperties(this);\n    const texture = this.value;\n    if (!texture || texture.isCubeTexture !== true) {\n      throw new Error('CubeTextureNode: Need a three.js cube texture.');\n    }\n    const textureProperty = UniformNode.prototype.generate.call(this, builder, 'cubeTexture');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeType = this.getNodeType(builder);\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const cubeUV = vec3(uvNode.x.negate(), uvNode.yz);\n        const uvSnippet = cubeUV.build(builder, 'vec3');\n        const nodeVar = builder.getVarFromNode(this, 'vec4');\n        propertyName = builder.getPropertyName(nodeVar);\n        let snippet = null;\n        if (levelNode && levelNode.isNode === true) {\n          const levelSnippet = levelNode.build(builder, 'float');\n          snippet = builder.getTextureLevel(this, textureProperty, uvSnippet, levelSnippet);\n        } else {\n          snippet = builder.getTexture(this, textureProperty, uvSnippet);\n        }\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`);\n        if (builder.context.tempWrite !== false) {\n          nodeData.snippet = snippet;\n          nodeData.propertyName = propertyName;\n        }\n      }\n      let snippet = propertyName;\n      if (builder.needsColorSpaceToLinear(this.value)) {\n        snippet = colorSpaceToLinear(expression(snippet, nodeType), this.value.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, 'vec4', output);\n    }\n  }\n}\nexport default CubeTextureNode;\nexport const cubeTexture = nodeProxy(CubeTextureNode);\naddNodeElement('cubeTexture', cubeTexture);\naddNodeClass('CubeTextureNode', CubeTextureNode);","map":{"version":3,"names":["TextureNode","UniformNode","reflectVector","addNodeClass","colorSpaceToLinear","expression","addNodeElement","nodeProxy","vec3","CubeTextureNode","constructor","value","uvNode","levelNode","isCubeTextureNode","getInputType","getDefaultUV","setUpdateMatrix","generate","builder","output","getNodeProperties","texture","isCubeTexture","Error","textureProperty","prototype","call","isReference","nodeType","getNodeType","nodeData","getDataFromNode","propertyName","undefined","cubeUV","x","negate","yz","uvSnippet","build","nodeVar","getVarFromNode","getPropertyName","snippet","isNode","levelSnippet","getTextureLevel","getTexture","addLineFlowCode","context","tempWrite","needsColorSpaceToLinear","colorSpace","setup","format","cubeTexture"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js"],"sourcesContent":["import TextureNode from './TextureNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { reflectVector } from './ReflectVectorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeElement, nodeProxy, vec3 } from '../shadernode/ShaderNode.js';\n\nclass CubeTextureNode extends TextureNode {\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode );\n\n\t\tthis.isCubeTextureNode = true;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn reflectVector;\n\n\t}\n\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode\n\n\tgenerate( builder, output ) {\n\n\t\tconst { uvNode, levelNode } = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isCubeTexture !== true ) {\n\n\t\t\tthrow new Error( 'CubeTextureNode: Need a three.js cube texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = UniformNode.prototype.generate.call( this, builder, 'cubeTexture' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst cubeUV = vec3( uvNode.x.negate(), uvNode.yz );\n\t\t\t\tconst uvSnippet = cubeUV.build( builder, 'vec3' );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, 'vec4' );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tlet snippet = null;\n\n\t\t\t\tif ( levelNode && levelNode.isNode === true ) {\n\n\t\t\t\t\tconst levelSnippet = levelNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getTextureLevel( this, textureProperty, uvSnippet, levelSnippet );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = builder.getTexture( this, textureProperty, uvSnippet );\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tif ( builder.context.tempWrite !== false ) {\n\n\t\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\n\t\t\tif ( builder.needsColorSpaceToLinear( this.value ) ) {\n\n\t\t\t\tsnippet = colorSpaceToLinear( expression( snippet, nodeType ), this.value.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, 'vec4', output );\n\n\t\t}\n\n\t}\n\n}\n\nexport default CubeTextureNode;\n\nexport const cubeTexture = nodeProxy( CubeTextureNode );\n\naddNodeElement( 'cubeTexture', cubeTexture );\n\naddNodeClass( 'CubeTextureNode', CubeTextureNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}