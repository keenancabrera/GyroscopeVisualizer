{"ast":null,"code":"import DataMap from './DataMap.js';\nimport RenderPipeline from './RenderPipeline.js';\nimport ComputePipeline from './ComputePipeline.js';\nimport ProgrammableStage from './ProgrammableStage.js';\nclass Pipelines extends DataMap {\n  constructor(backend, nodes) {\n    super();\n    this.backend = backend;\n    this.nodes = nodes;\n    this.bindings = null; // set by the bindings\n\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  getForCompute(computeNode, bindings) {\n    const {\n      backend\n    } = this;\n    const data = this.get(computeNode);\n    if (this._needsComputeUpdate(computeNode)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.computeProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilder = this.nodes.getForCompute(computeNode);\n\n      // programmable stage\n\n      let stageCompute = this.programs.compute.get(nodeBuilder.computeShader);\n      if (stageCompute === undefined) {\n        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);\n        stageCompute = new ProgrammableStage(nodeBuilder.computeShader, 'compute');\n        this.programs.compute.set(nodeBuilder.computeShader, stageCompute);\n        backend.createProgram(stageCompute);\n      }\n\n      // determine compute pipeline\n\n      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(computeNode);\n        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageCompute.usedTimes++;\n\n      //\n\n      data.version = computeNode.version;\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  getForRender(renderObject) {\n    const {\n      backend\n    } = this;\n    const data = this.get(renderObject);\n    if (this._needsRenderUpdate(renderObject)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.vertexProgram.usedTimes--;\n        previousPipeline.fragmentProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilderState = renderObject.getNodeBuilderState();\n\n      // programmable stages\n\n      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);\n      if (stageVertex === undefined) {\n        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);\n        stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex');\n        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);\n        backend.createProgram(stageVertex);\n      }\n      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);\n      if (stageFragment === undefined) {\n        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);\n        stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment');\n        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);\n        backend.createProgram(stageFragment);\n      }\n\n      // determine render pipeline\n\n      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);\n        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey);\n      } else {\n        renderObject.pipeline = pipeline;\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageVertex.usedTimes++;\n      stageFragment.usedTimes++;\n\n      //\n\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  delete(object) {\n    const pipeline = this.get(object).pipeline;\n    if (pipeline) {\n      // pipeline\n\n      pipeline.usedTimes--;\n      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);\n\n      // programs\n\n      if (pipeline.isComputePipeline) {\n        pipeline.computeProgram.usedTimes--;\n        if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);\n      } else {\n        pipeline.fragmentProgram.usedTimes--;\n        pipeline.vertexProgram.usedTimes--;\n        if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);\n        if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);\n      }\n    }\n    super.delete(object);\n  }\n  dispose() {\n    super.dispose();\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  updateForRender(renderObject) {\n    this.getForRender(renderObject);\n  }\n  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new ComputePipeline(cacheKey, stageCompute);\n      this.caches.set(cacheKey, pipeline);\n      this.backend.createComputePipeline(pipeline, bindings);\n    }\n    return pipeline;\n  }\n  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);\n      this.caches.set(cacheKey, pipeline);\n      renderObject.pipeline = pipeline;\n      this.backend.createRenderPipeline(renderObject);\n    }\n    return pipeline;\n  }\n  _getComputeCacheKey(computeNode, stageCompute) {\n    return 'compute' + computeNode.id + stageCompute.id;\n  }\n  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {\n    const {\n      material\n    } = renderObject;\n    const parameters = [stageVertex.id, stageFragment.id, material.transparent, material.blending, material.premultipliedAlpha, material.blendSrc, material.blendDst, material.blendEquation, material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha, material.colorWrite, material.depthWrite, material.depthTest, material.depthFunc, material.stencilWrite, material.stencilFunc, material.stencilFail, material.stencilZFail, material.stencilZPass, material.stencilFuncMask, material.stencilWriteMask, material.side, this.backend.getCacheKey(renderObject)];\n    return parameters.join();\n  }\n  _releasePipeline(pipeline) {\n    this.caches.delete(pipeline.cacheKey);\n  }\n  _releaseProgram(program) {\n    const code = program.code;\n    const stage = program.stage;\n    this.programs[stage].delete(code);\n  }\n  _needsComputeUpdate(computeNode) {\n    const data = this.get(computeNode);\n    return data.pipeline === undefined || data.version !== computeNode.version;\n  }\n  _needsRenderUpdate(renderObject) {\n    const data = this.get(renderObject);\n    const material = renderObject.material;\n    let needsUpdate = this.backend.needsUpdate(renderObject);\n\n    // check material state\n\n    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage) {\n      data.material = material;\n      data.materialVersion = material.version;\n      data.transparent = material.transparent;\n      data.blending = material.blending;\n      data.premultipliedAlpha = material.premultipliedAlpha;\n      data.blendSrc = material.blendSrc;\n      data.blendDst = material.blendDst;\n      data.blendEquation = material.blendEquation;\n      data.blendSrcAlpha = material.blendSrcAlpha;\n      data.blendDstAlpha = material.blendDstAlpha;\n      data.blendEquationAlpha = material.blendEquationAlpha;\n      data.colorWrite = material.colorWrite;\n      data.depthWrite = material.depthWrite;\n      data.depthTest = material.depthTest;\n      data.depthFunc = material.depthFunc;\n      data.stencilWrite = material.stencilWrite;\n      data.stencilFunc = material.stencilFunc;\n      data.stencilFail = material.stencilFail;\n      data.stencilZFail = material.stencilZFail;\n      data.stencilZPass = material.stencilZPass;\n      data.stencilFuncMask = material.stencilFuncMask;\n      data.stencilWriteMask = material.stencilWriteMask;\n      data.side = material.side;\n      data.alphaToCoverage = material.alphaToCoverage;\n      needsUpdate = true;\n    }\n    return needsUpdate || data.pipeline === undefined;\n  }\n}\nexport default Pipelines;","map":{"version":3,"names":["DataMap","RenderPipeline","ComputePipeline","ProgrammableStage","Pipelines","constructor","backend","nodes","bindings","caches","Map","programs","vertex","fragment","compute","getForCompute","computeNode","data","get","_needsComputeUpdate","previousPipeline","pipeline","usedTimes","computeProgram","nodeBuilder","stageCompute","computeShader","undefined","_releaseProgram","set","createProgram","cacheKey","_getComputeCacheKey","_releasePipeline","_getComputePipeline","version","getForRender","renderObject","_needsRenderUpdate","vertexProgram","fragmentProgram","nodeBuilderState","getNodeBuilderState","stageVertex","vertexShader","stageFragment","fragmentShader","_getRenderCacheKey","_getRenderPipeline","delete","object","isComputePipeline","dispose","updateForRender","createComputePipeline","createRenderPipeline","id","material","parameters","transparent","blending","premultipliedAlpha","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","colorWrite","depthWrite","depthTest","depthFunc","stencilWrite","stencilFunc","stencilFail","stencilZFail","stencilZPass","stencilFuncMask","stencilWriteMask","side","getCacheKey","join","program","code","stage","needsUpdate","materialVersion","alphaToCoverage"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/renderers/common/Pipelines.js"],"sourcesContent":["import DataMap from './DataMap.js';\nimport RenderPipeline from './RenderPipeline.js';\nimport ComputePipeline from './ComputePipeline.js';\nimport ProgrammableStage from './ProgrammableStage.js';\n\nclass Pipelines extends DataMap {\n\n\tconstructor( backend, nodes ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\t\tthis.nodes = nodes;\n\n\t\tthis.bindings = null; // set by the bindings\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\tgetForCompute( computeNode, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( this._needsComputeUpdate( computeNode ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.computeProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilder = this.nodes.getForCompute( computeNode );\n\n\t\t\t// programmable stage\n\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilder.computeShader );\n\n\t\t\tif ( stageCompute === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );\n\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilder.computeShader, 'compute' );\n\t\t\t\tthis.programs.compute.set( nodeBuilder.computeShader, stageCompute );\n\n\t\t\t\tbackend.createProgram( stageCompute );\n\n\t\t\t}\n\n\t\t\t// determine compute pipeline\n\n\t\t\tconst cacheKey = this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( computeNode );\n\n\t\t\t\tpipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageCompute.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.version = computeNode.version;\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\tgetForRender( renderObject ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( this._needsRenderUpdate( renderObject ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.vertexProgram.usedTimes --;\n\t\t\t\tpreviousPipeline.fragmentProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = renderObject.getNodeBuilderState();\n\n\t\t\t// programmable stages\n\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );\n\n\t\t\tif ( stageVertex === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );\n\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex' );\n\t\t\t\tthis.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );\n\n\t\t\t\tbackend.createProgram( stageVertex );\n\n\t\t\t}\n\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );\n\n\t\t\tif ( stageFragment === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );\n\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment' );\n\t\t\t\tthis.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );\n\n\t\t\t\tbackend.createProgram( stageFragment );\n\n\t\t\t}\n\n\t\t\t// determine render pipeline\n\n\t\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey );\n\n\t\t\t} else {\n\n\t\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageVertex.usedTimes ++;\n\t\t\tstageFragment.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\tdelete( object ) {\n\n\t\tconst pipeline = this.get( object ).pipeline;\n\n\t\tif ( pipeline ) {\n\n\t\t\t// pipeline\n\n\t\t\tpipeline.usedTimes --;\n\n\t\t\tif ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );\n\n\t\t\t// programs\n\n\t\t\tif ( pipeline.isComputePipeline ) {\n\n\t\t\t\tpipeline.computeProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );\n\n\t\t\t} else {\n\n\t\t\t\tpipeline.fragmentProgram.usedTimes --;\n\t\t\t\tpipeline.vertexProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );\n\t\t\t\tif ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.delete( object );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tthis.getForRender( renderObject );\n\n\t}\n\n\t_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\tthis.backend.createComputePipeline( pipeline, bindings );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\tthis.backend.createRenderPipeline( renderObject );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t_getComputeCacheKey( computeNode, stageCompute ) {\n\n\t\treturn 'compute' + computeNode.id + stageCompute.id;\n\n\t}\n\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\n\n\t\tconst { material } = renderObject;\n\n\t\tconst parameters = [\n\t\t\tstageVertex.id, stageFragment.id,\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\n\t\t\tmaterial.colorWrite,\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\n\t\t\tmaterial.side,\n\t\t\tthis.backend.getCacheKey( renderObject )\n\t\t];\n\n\t\treturn parameters.join();\n\n\t}\n\n\t_releasePipeline( pipeline ) {\n\n\t\tthis.caches.delete( pipeline.cacheKey );\n\n\t}\n\n\t_releaseProgram( program ) {\n\n\t\tconst code = program.code;\n\t\tconst stage = program.stage;\n\n\t\tthis.programs[ stage ].delete( code );\n\n\t}\n\n\t_needsComputeUpdate( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\treturn data.pipeline === undefined || data.version !== computeNode.version;\n\n\t}\n\n\t_needsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\t\tconst material = renderObject.material;\n\n\t\tlet needsUpdate = this.backend.needsUpdate( renderObject );\n\n\t\t// check material state\n\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\n\t\t\tdata.colorWrite !== material.colorWrite ||\n\t\t\tdata.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\n\t\t\tdata.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage\n\t\t) {\n\n\t\t\tdata.material = material; data.materialVersion = material.version;\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\n\t\t\tdata.colorWrite = material.colorWrite;\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\n\t\t\tdata.side = material.side; data.alphaToCoverage = material.alphaToCoverage;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate || data.pipeline === undefined;\n\n\t}\n\n}\n\nexport default Pipelines;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}