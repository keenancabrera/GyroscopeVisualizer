{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Material, ShaderMaterial, NoColorSpace, LinearSRGBColorSpace } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { output, diffuseColor } from '../core/PropertyNode.js';\nimport { materialNormal } from '../accessors/ExtendedMaterialNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { positionLocal, positionView } from '../accessors/PositionNode.js';\nimport { skinning } from '../accessors/SkinningNode.js';\nimport { morph } from '../accessors/MorphNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsWithoutWrap } from '../lighting/LightsNode.js';\nimport { mix, dFdx, dFdy } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport { lightingContext } from '../lighting/LightingContextNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nconst NodeMaterials = new Map();\nclass NodeMaterial extends ShaderMaterial {\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.type = this.constructor.type;\n    this.forceSinglePass = false;\n    this.unlit = this.constructor === NodeMaterial.prototype.constructor; // Extended materials are not unlit by default\n\n    this.fog = true;\n    this.lights = true;\n    this.normals = true;\n    this.colorSpace = true;\n    this.lightsNode = null;\n    this.envNode = null;\n    this.colorNode = null;\n    this.normalNode = null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    this.positionNode = null;\n    this.outputNode = null; // @TODO: Rename to fragmentNode\n    this.vertexNode = null;\n  }\n  customProgramCacheKey() {\n    return this.type + getCacheKey(this);\n  }\n  build(builder) {\n    this.setup(builder);\n  }\n  setup(builder) {\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    builder.stack.outputNode = this.setupPosition(builder);\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    let outputNode;\n    if (this.unlit === false) {\n      if (this.normals === true) this.setupNormal(builder);\n      this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      const outgoingLightNode = this.setupLighting(builder);\n      outputNode = this.setupOutput(builder, vec4(outgoingLightNode, diffuseColor.a));\n\n      // OUTPUT NODE\n\n      builder.stack.assign(output, outputNode);\n\n      //\n\n      if (this.outputNode !== null) outputNode = this.outputNode;\n    } else {\n      outputNode = this.setupOutput(builder, this.outputNode || vec4(0, 0, 0, 1));\n    }\n    builder.stack.outputNode = outputNode;\n    builder.addFlow('fragment', builder.removeStack());\n  }\n  setupPosition(builder) {\n    const object = builder.object;\n    const geometry = object.geometry;\n    builder.addStack();\n    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      builder.stack.add(morph(object));\n    }\n    if (object.isSkinnedMesh === true) {\n      builder.stack.add(skinning(object));\n    }\n    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable('instance') === true) {\n      builder.stack.add(instance(object));\n    }\n    if (this.positionNode !== null) {\n      builder.stack.assign(positionLocal, this.positionNode);\n    }\n    builder.context.vertex = builder.removeStack();\n    return this.vertexNode || modelViewProjection();\n  }\n  setupDiffuseColor({\n    stack,\n    geometry\n  }) {\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color')), colorNode.a);\n    }\n\n    // COLOR\n\n    stack.assign(diffuseColor, colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    stack.assign(diffuseColor.a, diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode !== null || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;\n      stack.add(diffuseColor.a.lessThanEqual(alphaTestNode).discard());\n    }\n  }\n  setupVariants( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupNormal({\n    stack\n  }) {\n    // NORMAL VIEW\n\n    if (this.flatShading === true) {\n      const fdx = dFdx(positionView);\n      const fdy = dFdy(positionView);\n      const normalNode = fdx.cross(fdy).normalize();\n      stack.assign(transformedNormalView, normalNode);\n    } else {\n      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;\n      stack.assign(transformedNormalView, normalNode);\n    }\n  }\n  getEnvNode(builder) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);\n    } else if (builder.environmentNode) {\n      node = builder.environmentNode;\n    }\n    return node;\n  }\n  setupLights(builder) {\n    const envNode = this.getEnvNode(builder);\n\n    //\n\n    const materialLightsNode = [];\n    if (envNode) {\n      materialLightsNode.push(new EnvironmentNode(envNode));\n    }\n    if (builder.material.aoMap) {\n      materialLightsNode.push(new AONode(texture(builder.material.aoMap)));\n    }\n    let lightsNode = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsNode = lightsWithoutWrap([...lightsNode.lightNodes, ...materialLightsNode]);\n    }\n    return lightsNode;\n  }\n  setupLightingModel( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.setupLights(builder) : null;\n    let outgoingLightNode = diffuseColor.rgb;\n    if (lightsNode && lightsNode.hasLight !== false) {\n      const lightingModelNode = this.setupLightingModel(builder);\n      outgoingLightNode = lightingContext(lightsNode, lightingModelNode, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));\n    }\n    return outgoingLightNode;\n  }\n  setupOutput(builder, outputNode) {\n    const renderer = builder.renderer;\n\n    // TONE MAPPING\n\n    const toneMappingNode = builder.toneMappingNode;\n    if (toneMappingNode) {\n      outputNode = vec4(toneMappingNode.context({\n        color: outputNode.rgb\n      }), outputNode.a);\n    }\n\n    // FOG\n\n    if (this.fog === true) {\n      const fogNode = builder.fogNode;\n      if (fogNode) outputNode = vec4(fogNode.mixAssign(outputNode.rgb), outputNode.a);\n    }\n\n    // ENCODING\n\n    if (this.colorSpace === true) {\n      const renderTarget = renderer.getRenderTarget();\n      let outputColorSpace;\n      if (renderTarget !== null) {\n        if (Array.isArray(renderTarget.texture)) {\n          outputColorSpace = renderTarget.texture[0].colorSpace;\n        } else {\n          outputColorSpace = renderTarget.texture.colorSpace;\n        }\n      } else {\n        outputColorSpace = renderer.outputColorSpace;\n      }\n      if (outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace) {\n        outputNode = outputNode.linearToColorSpace(outputColorSpace);\n      }\n    }\n    return outputNode;\n  }\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    Object.assign(this.defines, material.defines);\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode = source.normalNode;\n    this.opacityNode = source.opacityNode;\n    this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.positionNode = source.positionNode;\n    this.outputNode = source.outputNode;\n    this.vertexNode = source.vertexNode;\n    return super.copy(source);\n  }\n  static fromMaterial(material) {\n    if (material.isNodeMaterial === true) {\n      // is already a node material\n\n      return material;\n    }\n    const type = material.type.replace('Material', 'NodeMaterial');\n    const nodeMaterial = createNodeMaterialFromType(type);\n    if (nodeMaterial === undefined) {\n      throw new Error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n    }\n    for (const key in material) {\n      nodeMaterial[key] = material[key];\n    }\n    return nodeMaterial;\n  }\n}\nexport default NodeMaterial;\nexport function addNodeMaterial(type, nodeMaterial) {\n  if (typeof nodeMaterial !== 'function' || !type) throw new Error(`Node material ${type} is not a class`);\n  if (NodeMaterials.has(type)) throw new Error(`Redefinition of node material ${type}`);\n  NodeMaterials.set(type, nodeMaterial);\n  nodeMaterial.type = type;\n}\nexport function createNodeMaterialFromType(type) {\n  const Material = NodeMaterials.get(type);\n  if (Material !== undefined) {\n    return new Material();\n  }\n}\naddNodeMaterial('NodeMaterial', NodeMaterial);","map":{"version":3,"names":["Material","ShaderMaterial","NoColorSpace","LinearSRGBColorSpace","getNodeChildren","getCacheKey","attribute","output","diffuseColor","materialNormal","materialAlphaTest","materialColor","materialOpacity","materialEmissive","modelViewProjection","transformedNormalView","instance","positionLocal","positionView","skinning","morph","texture","cubeTexture","lightsWithoutWrap","mix","dFdx","dFdy","float","vec3","vec4","AONode","lightingContext","EnvironmentNode","NodeMaterials","Map","NodeMaterial","constructor","isNodeMaterial","type","forceSinglePass","unlit","prototype","fog","lights","normals","colorSpace","lightsNode","envNode","colorNode","normalNode","opacityNode","backdropNode","backdropAlphaNode","alphaTestNode","positionNode","outputNode","vertexNode","customProgramCacheKey","build","builder","setup","addStack","stack","setupPosition","addFlow","removeStack","setupNormal","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","setupOutput","a","assign","object","geometry","morphAttributes","position","normal","color","add","isSkinnedMesh","instanceMatrix","isInstancedBufferAttribute","isAvailable","context","vertex","vertexColors","hasAttribute","xyz","mul","alphaTest","lessThanEqual","discard","flatShading","fdx","fdy","cross","normalize","getEnvNode","node","envMap","isCubeTexture","environmentNode","setupLights","materialLightsNode","push","material","aoMap","length","lightNodes","setupLightingModel","emissiveNode","rgb","hasLight","lightingModelNode","isNode","emissive","isColor","renderer","toneMappingNode","fogNode","mixAssign","renderTarget","getRenderTarget","outputColorSpace","Array","isArray","linearToColorSpace","setDefaultValues","property","value","undefined","clone","Object","defines","descriptors","getOwnPropertyDescriptors","key","getOwnPropertyDescriptor","get","defineProperty","toJSON","meta","isRoot","textures","images","nodes","data","call","nodeChildren","inputNodes","childNode","uuid","extractFromCache","cache","values","metadata","copy","source","fromMaterial","replace","nodeMaterial","createNodeMaterialFromType","Error","addNodeMaterial","has","set"],"sources":["/Users/cabrera/Documents/GyroscopeVisualizer/frontend/node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js"],"sourcesContent":["import { Material, ShaderMaterial, NoColorSpace, LinearSRGBColorSpace } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { output, diffuseColor } from '../core/PropertyNode.js';\nimport { materialNormal } from '../accessors/ExtendedMaterialNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { positionLocal, positionView } from '../accessors/PositionNode.js';\nimport { skinning } from '../accessors/SkinningNode.js';\nimport { morph } from '../accessors/MorphNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsWithoutWrap } from '../lighting/LightsNode.js';\nimport { mix, dFdx, dFdy } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport { lightingContext } from '../lighting/LightingContextNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\n\nconst NodeMaterials = new Map();\n\nclass NodeMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isNodeMaterial = true;\n\n\t\tthis.type = this.constructor.type;\n\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.unlit = this.constructor === NodeMaterial.prototype.constructor; // Extended materials are not unlit by default\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\t\tthis.normals = true;\n\t\tthis.colorSpace = true;\n\n\t\tthis.lightsNode = null;\n\t\tthis.envNode = null;\n\n\t\tthis.colorNode = null;\n\t\tthis.normalNode = null;\n\t\tthis.opacityNode = null;\n\t\tthis.backdropNode = null;\n\t\tthis.backdropAlphaNode = null;\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.positionNode = null;\n\n\t\tthis.outputNode = null; // @TODO: Rename to fragmentNode\n\t\tthis.vertexNode = null;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey( this );\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.setupPosition( builder );\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet outputNode;\n\n\t\tif ( this.unlit === false ) {\n\n\t\t\tif ( this.normals === true ) this.setupNormal( builder );\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\toutputNode = this.setupOutput( builder, vec4( outgoingLightNode, diffuseColor.a ) );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\tbuilder.stack.assign( output, outputNode );\n\n\t\t\t//\n\n\t\t\tif ( this.outputNode !== null ) outputNode = this.outputNode;\n\n\t\t} else {\n\n\t\t\toutputNode = this.setupOutput( builder, this.outputNode || vec4( 0, 0, 0, 1 ) );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = outputNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t}\n\n\tsetupPosition( builder ) {\n\n\t\tconst object = builder.object;\n\t\tconst geometry = object.geometry;\n\n\t\tbuilder.addStack();\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tbuilder.stack.add( morph( object ) );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tbuilder.stack.add( skinning( object ) );\n\n\t\t}\n\n\t\tif ( ( object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) && builder.isAvailable( 'instance' ) === true ) {\n\n\t\t\tbuilder.stack.add( instance( object ) );\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tbuilder.stack.assign( positionLocal, this.positionNode );\n\n\t\t}\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\n\t\treturn this.vertexNode || modelViewProjection();\n\n\t}\n\n\tsetupDiffuseColor( { stack, geometry } ) {\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color' ) ), colorNode.a );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tstack.assign( diffuseColor, colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tstack.assign( diffuseColor.a, diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tstack.add( diffuseColor.a.lessThanEqual( alphaTestNode ).discard() );\n\n\t\t}\n\n\t}\n\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupNormal( { stack } ) {\n\n\t\t// NORMAL VIEW\n\n\t\tif ( this.flatShading === true ) {\n\n\t\t\tconst fdx = dFdx( positionView );\n\t\t\tconst fdy = dFdy( positionView );\n\t\t\tconst normalNode = fdx.cross( fdy ).normalize();\n\n\t\t\tstack.assign( transformedNormalView, normalNode );\n\n\t\t} else {\n\n\t\t\tconst normalNode = this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t\t\tstack.assign( transformedNormalView, normalNode );\n\n\t\t}\n\n\t}\n\n\tgetEnvNode( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? cubeTexture( this.envMap ) : texture( this.envMap );\n\n\t\t} else if ( builder.environmentNode ) {\n\n\t\t\tnode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupLights( builder ) {\n\n\t\tconst envNode = this.getEnvNode( builder );\n\n\t\t//\n\n\t\tconst materialLightsNode = [];\n\n\t\tif ( envNode ) {\n\n\t\t\tmaterialLightsNode.push( new EnvironmentNode( envNode ) );\n\n\t\t}\n\n\t\tif ( builder.material.aoMap ) {\n\n\t\t\tmaterialLightsNode.push( new AONode( texture( builder.material.aoMap ) ) );\n\n\t\t}\n\n\t\tlet lightsNode = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsNode = lightsWithoutWrap( [ ...lightsNode.lightNodes, ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsNode;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = diffuseColor.rgb;\n\n\t\tif ( lightsNode && lightsNode.hasLight !== false ) {\n\n\t\t\tconst lightingModelNode = this.setupLightingModel( builder );\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModelNode, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tsetupOutput( builder, outputNode ) {\n\n\t\tconst renderer = builder.renderer;\n\n\t\t// TONE MAPPING\n\n\t\tconst toneMappingNode = builder.toneMappingNode;\n\n\t\tif ( toneMappingNode ) {\n\n\t\t\toutputNode = vec4( toneMappingNode.context( { color: outputNode.rgb } ), outputNode.a );\n\n\t\t}\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\tconst fogNode = builder.fogNode;\n\n\t\t\tif ( fogNode ) outputNode = vec4( fogNode.mixAssign( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\t// ENCODING\n\n\t\tif ( this.colorSpace === true ) {\n\n\t\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t\tlet outputColorSpace;\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tif ( Array.isArray( renderTarget.texture ) ) {\n\n\t\t\t\t\toutputColorSpace = renderTarget.texture[ 0 ].colorSpace;\n\n\t\t\t\t} else {\n\n\t\t\t\t\toutputColorSpace = renderTarget.texture.colorSpace;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\toutputColorSpace = renderer.outputColorSpace;\n\n\t\t\t}\n\n\t\t\tif ( outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace ) {\n\n\t\t\t\toutputNode = outputNode.linearToColorSpace( outputColorSpace );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tObject.assign( this.defines, material.defines );\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.positionNode = source.positionNode;\n\n\t\tthis.outputNode = source.outputNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\tstatic fromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial === true ) { // is already a node material\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tconst type = material.type.replace( 'Material', 'NodeMaterial' );\n\n\t\tconst nodeMaterial = createNodeMaterialFromType( type );\n\n\t\tif ( nodeMaterial === undefined ) {\n\n\t\t\tthrow new Error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t}\n\n\t\tfor ( const key in material ) {\n\n\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n}\n\nexport default NodeMaterial;\n\nexport function addNodeMaterial( type, nodeMaterial ) {\n\n\tif ( typeof nodeMaterial !== 'function' || ! type ) throw new Error( `Node material ${ type } is not a class` );\n\tif ( NodeMaterials.has( type ) ) throw new Error( `Redefinition of node material ${ type }` );\n\n\tNodeMaterials.set( type, nodeMaterial );\n\tnodeMaterial.type = type;\n\n}\n\nexport function createNodeMaterialFromType( type ) {\n\n\tconst Material = NodeMaterials.get( type );\n\n\tif ( Material !== undefined ) {\n\n\t\treturn new Material();\n\n\t}\n\n}\n\naddNodeMaterial( 'NodeMaterial', NodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}